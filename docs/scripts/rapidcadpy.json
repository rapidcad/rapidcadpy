{
  "name": "rapidcadpy",
  "path": "rapidcadpy",
  "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/__init__.py",
  "description": "rapidcadpy - A Python library for CAD sequence processing and manipulation.\n\nThis package provides tools for working with CAD sequences, sketches, primitives,\nand 3D modeling operations.",
  "docstring": [],
  "attributes": [
    {
      "name": "__version__",
      "annotation": null,
      "description": null,
      "value": "'0.1.0'"
    },
    {
      "name": "__author__",
      "annotation": null,
      "description": null,
      "value": "'Your Name'"
    },
    {
      "name": "__email__",
      "annotation": null,
      "description": null,
      "value": "'your.email@example.com'"
    },
    {
      "name": "backend",
      "annotation": null,
      "description": null,
      "value": "BackendProperty()"
    },
    {
      "name": "__all__",
      "annotation": null,
      "description": null,
      "value": "['Primitive', 'Line', 'Arc', 'Circle', 'Sketch', 'Wire', 'Plane', 'Extrude', 'Vertex', 'Vector', 'Constraint', 'CoincidenceConstraint', 'StartToEndCoincidenceConstraint', 'EndToStartCoincidenceConstraint', 'HorizontalConstraint', 'VerticalConstraint', 'PerpendicularConstraint', 'ParallelConstraint', 'SketchExtrude', 'Cad', 'Feature', 'MachiningFeature', 'CounterSunkHole', 'ParallelKeyway', 'Workplane', 'set_backend', 'get_current_backend', 'get_available_backends', 'export_with_backend', 'backend']"
    }
  ],
  "modules": {
    "functions": {
      "name": "functions",
      "path": "rapidcadpy.functions",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/functions.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {},
      "functions": {
        "angle_from_vector_to_x": {
          "name": "angle_from_vector_to_x",
          "path": "rapidcadpy.functions.angle_from_vector_to_x",
          "signature": "(vec) -> float",
          "description": null,
          "parameters": [
            {
              "name": "vec",
              "annotation": "np.ndarray",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": "float",
            "description": null
          },
          "docstring": [],
          "source": "def angle_from_vector_to_x(vec: np.ndarray) -> float:\n    angle = 0.0\n    # 2 | 1\n    # -------\n    # 3 | 4\n    if vec[0] >= 0:\n        if vec[1] >= 0:\n            # Qadrant 1\n            angle = math.asin(vec[1])\n        else:\n            # Qadrant 4\n            angle = 2.0 * math.pi - math.asin(-vec[1])\n    else:\n        if vec[1] >= 0:\n            # Qadrant 2\n            angle = math.pi - math.asin(vec[1])\n        else:\n            # Qadrant 3\n            angle = math.pi + math.asin(-vec[1])\n    return angle"
        },
        "rotation_matrix_from_angles": {
          "name": "rotation_matrix_from_angles",
          "path": "rapidcadpy.functions.rotation_matrix_from_angles",
          "signature": "(theta, phi, gamma) -> np.ndarray",
          "description": null,
          "parameters": [
            {
              "name": "theta",
              "annotation": "float",
              "description": null,
              "value": null
            },
            {
              "name": "phi",
              "annotation": "float",
              "description": null,
              "value": null
            },
            {
              "name": "gamma",
              "annotation": "float",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": "numpy.numpy.ndarray",
            "description": null
          },
          "docstring": [],
          "source": "def rotation_matrix_from_angles(theta: float, phi: float, gamma: float) -> np.ndarray:\n    # Rotation matrix around z-axis\n    R_z = np.array(\n        [\n            [np.cos(theta), -np.sin(theta), 0],\n            [np.sin(theta), np.cos(theta), 0],\n            [0, 0, 1],\n        ]\n    )\n\n    # Rotation matrix around y-axis\n    R_y = np.array(\n        [[np.cos(phi), 0, np.sin(phi)], [0, 1, 0], [-np.sin(phi), 0, np.cos(phi)]]\n    )\n\n    # Rotation matrix around x-axis\n    R_x = np.array(\n        [\n            [1, 0, 0],\n            [0, np.cos(gamma), -np.sin(gamma)],\n            [0, np.sin(gamma), np.cos(gamma)],\n        ]\n    )\n\n    # Combined rotation matrix\n    R = R_z @ R_y @ R_x\n    return R"
        },
        "cartesian2polar": {
          "name": "cartesian2polar",
          "path": "rapidcadpy.functions.cartesian2polar",
          "signature": "(vec, with_radius=False) -> np.ndarray",
          "description": "convert a vector in cartesian coordinates to polar(spherical) coordinates",
          "parameters": [
            {
              "name": "vec",
              "annotation": "np.ndarray",
              "description": null,
              "value": null
            },
            {
              "name": "with_radius",
              "annotation": "bool",
              "description": null,
              "value": "False"
            }
          ],
          "returns": {
            "name": "",
            "annotation": "numpy.numpy.ndarray",
            "description": null
          },
          "docstring": [],
          "source": "def cartesian2polar(vec: np.ndarray, with_radius: bool = False) -> np.ndarray:\n    \"\"\"convert a vector in cartesian coordinates to polar(spherical) coordinates\"\"\"\n    vec = vec.round(6)\n    norm = np.linalg.norm(vec)\n    theta = np.arccos(vec[2] / norm)  # (0, pi)\n    phi = np.arctan(\n        vec[1] / (vec[0] + 1e-15)\n    )  # (-pi, pi) # FIXME: -0.0 cannot be identified here\n    if not with_radius:\n        return np.array([theta, phi])\n    else:\n        return np.array([theta, phi, norm])"
        },
        "polar2cartesian": {
          "name": "polar2cartesian",
          "path": "rapidcadpy.functions.polar2cartesian",
          "signature": "(vec) -> np.ndarray",
          "description": "convert a vector in polar(spherical) coordinates to cartesian coordinates",
          "parameters": [
            {
              "name": "vec",
              "annotation": "np.ndarray",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": "numpy.numpy.ndarray",
            "description": null
          },
          "docstring": [],
          "source": "def polar2cartesian(vec: np.ndarray) -> np.ndarray:\n    \"\"\"convert a vector in polar(spherical) coordinates to cartesian coordinates\"\"\"\n    r = 1 if len(vec) == 2 else vec[2]\n    theta, phi = vec[0], vec[1]\n    x = r * np.sin(theta) * np.cos(phi)\n    y = r * np.sin(theta) * np.sin(phi)\n    z = r * np.cos(theta)\n    return np.array([x, y, z])"
        },
        "rotate_by_y": {
          "name": "rotate_by_y",
          "path": "rapidcadpy.functions.rotate_by_y",
          "signature": "(vec, theta) -> np.ndarray",
          "description": null,
          "parameters": [
            {
              "name": "vec",
              "annotation": "np.ndarray",
              "description": null,
              "value": null
            },
            {
              "name": "theta",
              "annotation": "float",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": "numpy.numpy.ndarray",
            "description": null
          },
          "docstring": [],
          "source": "def rotate_by_y(vec: np.ndarray, theta: float) -> np.ndarray:\n    mat = np.array(\n        [\n            [np.cos(theta), 0, np.sin(theta)],\n            [0, 1, 0],\n            [-np.sin(theta), 0, np.cos(theta)],\n        ]\n    )\n    return np.dot(mat, vec)"
        },
        "rotate_by_z": {
          "name": "rotate_by_z",
          "path": "rapidcadpy.functions.rotate_by_z",
          "signature": "(vec, phi) -> np.ndarray",
          "description": null,
          "parameters": [
            {
              "name": "vec",
              "annotation": "np.ndarray",
              "description": null,
              "value": null
            },
            {
              "name": "phi",
              "annotation": "float",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": "numpy.numpy.ndarray",
            "description": null
          },
          "docstring": [],
          "source": "def rotate_by_z(vec: np.ndarray, phi: float) -> np.ndarray:\n    mat = np.array(\n        [[np.cos(phi), -np.sin(phi), 0], [np.sin(phi), np.cos(phi), 0], [0, 0, 1]]\n    )\n    return np.dot(mat, vec)"
        },
        "polar_parameterization": {
          "name": "polar_parameterization",
          "path": "rapidcadpy.functions.polar_parameterization",
          "signature": "(normal_3d, x_axis_3d) -> Tuple[float, float, float]",
          "description": "represent a coordinate system by its rotation from the standard 3D coordinate system\n\nArgs:\n    normal_3d (np.array): unit vector for normal direction (z-axis)\n    x_axis_3d (np.array): unit vector for x-axis\n\nReturns:\n    theta, phi, gamma: axis-angle rotation",
          "parameters": [
            {
              "name": "normal_3d",
              "annotation": "np.ndarray",
              "description": null,
              "value": null
            },
            {
              "name": "x_axis_3d",
              "annotation": "np.ndarray",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": "typing.Tuple[float, float, float]",
            "description": null
          },
          "docstring": [],
          "source": "def polar_parameterization(\n    normal_3d: np.ndarray, x_axis_3d: np.ndarray\n) -> Tuple[float, float, float]:\n    \"\"\"represent a coordinate system by its rotation from the standard 3D coordinate system\n\n    Args:\n        normal_3d (np.array): unit vector for normal direction (z-axis)\n        x_axis_3d (np.array): unit vector for x-axis\n\n    Returns:\n        theta, phi, gamma: axis-angle rotation\n    \"\"\"\n    normal_polar = cartesian2polar(normal_3d)\n    theta = normal_polar[0]\n    phi = normal_polar[1]\n\n    ref_x = rotate_by_z(rotate_by_y(np.array([1, 0, 0]), theta), phi)\n\n    gamma = np.arccos(np.dot(x_axis_3d, ref_x).round(6))\n    if np.dot(np.cross(ref_x, x_axis_3d), normal_3d) < 0:\n        gamma = -gamma\n    return theta, phi, gamma"
        },
        "polar_parameterization_inverse": {
          "name": "polar_parameterization_inverse",
          "path": "rapidcadpy.functions.polar_parameterization_inverse",
          "signature": "(theta, phi, gamma) -> Tuple[np.ndarray, np.ndarray]",
          "description": "build a coordinate system by the given rotation from the standard 3D coordinate system",
          "parameters": [
            {
              "name": "theta",
              "annotation": "float",
              "description": null,
              "value": null
            },
            {
              "name": "phi",
              "annotation": "float",
              "description": null,
              "value": null
            },
            {
              "name": "gamma",
              "annotation": "float",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": "typing.Tuple[numpy.numpy.ndarray, numpy.numpy.ndarray]",
            "description": null
          },
          "docstring": [],
          "source": "def polar_parameterization_inverse(\n    theta: float, phi: float, gamma: float\n) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"build a coordinate system by the given rotation from the standard 3D coordinate system\"\"\"\n    normal_3d = polar2cartesian([theta, phi])\n    ref_x = rotate_by_z(rotate_by_y(np.array([1, 0, 0]), theta), phi)\n    ref_y = np.cross(normal_3d, ref_x)\n    x_axis_3d = ref_x * np.cos(gamma) + ref_y * np.sin(gamma)\n    return normal_3d, x_axis_3d"
        },
        "render_plotly_line": {
          "name": "render_plotly_line",
          "path": "rapidcadpy.functions.render_plotly_line",
          "signature": "(edge, dashed=False, plane=None) -> Any",
          "description": "Render a line with arrows and labels in Plotly.",
          "parameters": [
            {
              "name": "edge",
              "annotation": "Any",
              "description": null,
              "value": null
            },
            {
              "name": "dashed",
              "annotation": "bool",
              "description": null,
              "value": "False"
            },
            {
              "name": "plane",
              "annotation": "Any",
              "description": null,
              "value": "None"
            }
          ],
          "returns": {
            "name": "",
            "annotation": "typing.Any",
            "description": null
          },
          "docstring": [],
          "source": "def render_plotly_line(edge: Any, dashed: bool = False, plane: Any = None) -> Any:\n    \"\"\"Render a line with arrows and labels in Plotly.\"\"\"\n    _line_style = \"dash\" if dashed else None\n    from pycad.geometry.arc import Arc as PyCadArc\n    from pycad.geometry.circle import Circle as PyCadCircle\n    from pycad.geometry.line import Line as PyCadLine\n\n    from rapidcadpy.primitive import Arc, Circle, Line\n\n    if isinstance(edge, Line) or isinstance(edge, PyCadLine):\n        if plane:\n            start = (\n                edge.start_point.x * plane.x_dir\n                + edge.start_point.y * plane.y_dir\n                + plane.origin\n            )\n            end = (\n                edge.end_point.x * plane.x_dir\n                + edge.end_point.y * plane.y_dir\n                + plane.origin\n            )\n        else:\n            start = (edge.start_point[0], edge.start_point[1])\n            end = (edge.end_point[0], edge.end_point[1])\n\n        # Add line with arrowhead and label\n        return go.Scatter(\n            x=[start[0], end[0]],\n            y=[start[1], end[1]],\n            name=\"Line\",\n            marker=dict(\n                size=12,\n                symbol=\"arrow-right\",  # Arrowhead symbol\n                angleref=\"previous\",\n                color=\"black\",\n            ),\n            text=[None, str(edge.id), str(edge.start_point), str(edge.end_point)],\n            textposition=\"top right\",\n            hoverinfo=\"text\",\n        )\n\n    elif isinstance(edge, Circle) or isinstance(edge, PyCadCircle):\n        center = (edge.center[0], edge.center[1])\n        theta = np.linspace(0, 2 * np.pi, 100)\n        x_circle = center[0] + edge.radius * np.cos(theta)\n        y_circle = center[1] + edge.radius * np.sin(theta)\n\n        return go.Scatter(\n            x=x_circle,\n            y=y_circle,\n            mode=\"lines\",\n            line=dict(color=\"green\", width=2, dash=_line_style),\n            name=\"Circle\",\n        )\n\n    elif isinstance(edge, Arc):\n        start = (edge.start_point.x, edge.start_point.y)\n        end = (edge.end_point.x, edge.end_point.y)\n        center = (edge.center.x, edge.center.y)\n\n        theta1 = np.arctan2(start[1] - center[1], start[0] - center[0])\n        theta2 = np.arctan2(end[1] - center[1], end[0] - center[0])\n        if edge.ccw and theta2 < theta1:\n            theta2 += 2 * np.pi\n        elif not edge.ccw and theta1 < theta2:\n            theta1 += 2 * np.pi\n        theta = np.linspace(theta1, theta2, 100)\n\n        x_arc = center[0] + edge.radius * np.cos(theta)\n        y_arc = center[1] + edge.radius * np.sin(theta)\n\n        return go.Scatter(\n            x=x_arc,\n            y=y_arc,\n            mode=\"lines\",\n            name=\"Arc\",\n            hovertext=f\"CCW {edge.ccw} \\n ID {edge.id}\",\n            text=[None, str(edge.id), str(edge.start_point), str(edge.end_point)],\n            textposition=\"top right\",\n            hoverinfo=\"text\",\n        )\n    elif isinstance(edge, PyCadArc):\n        start = (edge.start_point[0], edge.start_point[1])\n        end = (edge.end_point[0], edge.end_point[1])\n        center = (edge.center[0], edge.center[1])\n\n        theta1 = np.arctan2(start[1] - center[1], start[0] - center[0])\n        theta2 = np.arctan2(end[1] - center[1], end[0] - center[0])\n        if edge.ccw and theta2 < theta1:\n            theta2 += 2 * np.pi\n        elif not edge.ccw and theta1 < theta2:\n            theta1 += 2 * np.pi\n        theta = np.linspace(theta1, theta2, 100)\n\n        x_arc = center[0] + edge.radius * np.cos(theta)\n        y_arc = center[1] + edge.radius * np.sin(theta)\n\n        return go.Scatter(\n            x=x_arc,\n            y=y_arc,\n            mode=\"lines\",\n            name=\"Arc\",\n            hovertext=f\"CCW {edge.ccw} \\n ID {edge.id}\",\n            text=[None, str(edge.id), str(edge.start_point), str(edge.end_point)],\n            textposition=\"top right\",\n            hoverinfo=\"text\",\n        )"
        },
        "redner_arc_midpoints": {
          "name": "redner_arc_midpoints",
          "path": "rapidcadpy.functions.redner_arc_midpoints",
          "signature": "(arc)",
          "description": null,
          "parameters": [
            {
              "name": "arc",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def redner_arc_midpoints(arc):\n    from rapidcadpy.primitive import Arc\n\n    if isinstance(arc, Arc):\n        mid = arc.get_mid_point()\n        return go.Scatter(\n            x=[mid.x],\n            y=[mid.y],\n            mode=\"markers\",\n            name=\"Midpoint\",\n            marker=dict(size=8, color=\"red\"),\n        )"
        },
        "render_arc_centerpoints": {
          "name": "render_arc_centerpoints",
          "path": "rapidcadpy.functions.render_arc_centerpoints",
          "signature": "(arc)",
          "description": null,
          "parameters": [
            {
              "name": "arc",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def render_arc_centerpoints(arc):\n    from rapidcadpy.primitive import Arc\n\n    if isinstance(arc, Arc):\n        return go.Scatter(\n            x=[arc.center.x],\n            y=[arc.center.y],\n            mode=\"markers\",\n            name=\"Center\",\n            marker=dict(size=8, color=\"red\"),\n        )"
        },
        "render_arc_angles": {
          "name": "render_arc_angles",
          "path": "rapidcadpy.functions.render_arc_angles",
          "signature": "(arc)",
          "description": null,
          "parameters": [
            {
              "name": "arc",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def render_arc_angles(arc):\n    from rapidcadpy.primitive import Arc\n\n    if isinstance(arc, Arc):\n        start_angle = arc.start_angle\n        end_angle = arc.end_angle\n        center = np.array(arc.center)  # Assuming center is a tuple or Vertex\n        radius = arc.radius\n\n        # Calculate the start and end points based on the angles and radius\n        start_x = center[0] + radius * np.cos(start_angle)\n        start_y = center[1] + radius * np.sin(start_angle)\n\n        end_x = center[0] + radius * np.cos(end_angle)\n        end_y = center[1] + radius * np.sin(end_angle)\n\n        # Render the lines from center to start and end points\n        return go.Scatter(\n            x=[center[0], start_x, center[0], end_x],\n            y=[center[1], start_y, center[1], end_y],\n            mode=\"lines+markers\",\n            name=\"Arc Angles\",\n            marker=dict(size=8, color=\"blue\"),\n            line=dict(color=\"blue\", width=2),\n        )"
        },
        "render_arc_ref_vec": {
          "name": "render_arc_ref_vec",
          "path": "rapidcadpy.functions.render_arc_ref_vec",
          "signature": "(arc)",
          "description": null,
          "parameters": [
            {
              "name": "arc",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def render_arc_ref_vec(arc):\n    from rapidcadpy.primitive import Arc\n\n    if isinstance(arc, Arc):\n        center = np.array(arc.center)  # Assuming center is a tuple or Vertex\n        ref_vec = np.array(arc.ref_vec.get_2d())  # Assuming get_2d() gives [x, y]\n\n        # Endpoint of the reference vector\n        end_point = center + (ref_vec * arc.radius)\n\n        # Render as a line from center to endpoint\n        return go.Scatter(\n            x=[center[0], end_point[0]],\n            y=[center[1], end_point[1]],\n            mode=\"lines+markers\",\n            name=\"Ref Vec\",\n            marker=dict(size=8, color=\"green\"),\n            line=dict(color=\"green\", width=2),\n        )"
        },
        "render_choord_and_normal": {
          "name": "render_choord_and_normal",
          "path": "rapidcadpy.functions.render_choord_and_normal",
          "signature": "(arc)",
          "description": null,
          "parameters": [
            {
              "name": "arc",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def render_choord_and_normal(arc):\n    from rapidcadpy.primitive import Arc\n\n    if isinstance(arc, Arc):\n        start_to_end_vector = arc.end_point - arc.start_point\n        chord_midpoint = (arc.start_point + arc.end_point) / 2\n\n        perpendicular_vector = np.cross(start_to_end_vector, [0, 0, 1])[:2]\n        perpendicular_vector = perpendicular_vector / np.linalg.norm(\n            perpendicular_vector\n        )\n        if arc.ccw == 0:\n            perpendicular_vector = -perpendicular_vector\n\n        return go.Scatter(\n            x=[\n                chord_midpoint[0],\n                chord_midpoint[0] + (perpendicular_vector[0] * arc.radius),\n            ],\n            y=[\n                chord_midpoint[1],\n                chord_midpoint[1] + (perpendicular_vector[1] * arc.radius),\n            ],\n            mode=\"lines+markers\",\n            name=\"Normal\",\n            marker=dict(size=8, color=\"green\"),\n            line=dict(color=\"green\", width=2),\n        )"
        },
        "render_arrow_chord": {
          "name": "render_arrow_chord",
          "path": "rapidcadpy.functions.render_arrow_chord",
          "signature": "(edge)",
          "description": null,
          "parameters": [
            {
              "name": "edge",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def render_arrow_chord(edge):\n    from rapidcadpy.primitive import Arc\n\n    if isinstance(edge, Arc):\n        start = (edge.start_point.x, edge.start_point.y)\n        end = (edge.end_point.x, edge.end_point.y)\n\n        # Add an arrow representing the chord\n        arrow_trace = go.Scatter(\n            x=[start[0], end[0]],  # Chord endpoints\n            y=[start[1], end[1]],\n            mode=\"lines+markers\",\n            line=dict(width=2, color=\"red\", dash=\"solid\"),  # Customize arrow line\n            marker=dict(\n                size=12,\n                symbol=\"arrow-right\",  # Arrowhead symbol\n                angleref=\"previous\",\n                color=\"red\",\n            ),\n            name=\"Chord with Arrow\",\n        )\n\n        # Return the traces as a list (to be added to the figure)\n        return arrow_trace"
        },
        "render_constructed_center_point": {
          "name": "render_constructed_center_point",
          "path": "rapidcadpy.functions.render_constructed_center_point",
          "signature": "(arc)",
          "description": null,
          "parameters": [
            {
              "name": "arc",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def render_constructed_center_point(arc):\n    from rapidcadpy.primitive import Arc\n\n    if isinstance(arc, Arc):\n        sweep_angle = arc.end_angle - arc.start_angle\n        start_to_end_vector = arc.end_point - arc.start_point\n        chord_midpoint = (arc.start_point + arc.end_point) / 2\n\n        perpendicular_vector = np.cross(start_to_end_vector, [0, 0, 1])[:2]\n        perpendicular_vector = perpendicular_vector / np.linalg.norm(\n            perpendicular_vector\n        )\n        if arc.ccw == 0:\n            perpendicular_vector = -perpendicular_vector\n\n        center_point = chord_midpoint - perpendicular_vector * (\n            arc.radius * np.cos(sweep_angle / 2)\n        )\n\n        return go.Scatter(\n            x=[center_point[0]],\n            y=[center_point[1]],\n            mode=\"markers\",\n            name=\"Constructed Center\",\n            marker=dict(size=8, color=\"green\"),\n        )"
        },
        "visualize_lines": {
          "name": "visualize_lines",
          "path": "rapidcadpy.functions.visualize_lines",
          "signature": "(outer_edges, inner_edges=None, title='CAD', return_fig=False, plane=None)",
          "description": "Visualize a list of lines and optionally inner edges with arrows and labels.",
          "parameters": [
            {
              "name": "outer_edges",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "inner_edges",
              "annotation": null,
              "description": null,
              "value": "None"
            },
            {
              "name": "title",
              "annotation": null,
              "description": null,
              "value": "'CAD'"
            },
            {
              "name": "return_fig",
              "annotation": null,
              "description": null,
              "value": "False"
            },
            {
              "name": "plane",
              "annotation": null,
              "description": null,
              "value": "None"
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def visualize_lines(\n    outer_edges, inner_edges=None, title=\"CAD\", return_fig=False, plane=None\n):\n    \"\"\"Visualize a list of lines and optionally inner edges with arrows and labels.\"\"\"\n    if inner_edges is None:\n        inner_edges = []\n\n    fig = go.Figure()\n\n    traces = []\n    for edge in outer_edges:\n        trace = render_plotly_line(edge, plane=plane)\n        traces.append(trace)\n\n    # Plot each inner edge with dashed lines and store the traces\n    for edge in inner_edges:\n        trace = render_plotly_line(edge, dashed=True)\n        traces.append(trace)\n\n    # mark arc midpoints for three point arc\n    # for edge in outer_edges:\n    # traces.append(redner_arc_midpoints(edge))\n    # traces.append(render_arc_centerpoints(edge))\n    # traces.append(render_arc_ref_vec(edge))\n    # traces.append(render_choord_and_normal(edge))\n    # traces.append(render_constructed_center_point(edge))\n    # traces.append(render_arrow_chord(edge))\n\n    traces = [trace for trace in traces if trace is not None]\n\n    if return_fig:\n        return traces\n\n    # else plot the result\n    for trace in traces:\n        fig.add_trace(trace)\n    fig.update_layout(\n        title=title,\n        scene=dict(aspectmode=\"cube\"),\n        xaxis=dict(scaleanchor=\"y\", title=\"X Axis\"),\n        yaxis=dict(title=\"Y Axis\"),\n        showlegend=False,\n        autosize=True,\n    )\n    fig.show()"
        },
        "angle_between_points": {
          "name": "angle_between_points",
          "path": "rapidcadpy.functions.angle_between_points",
          "signature": "(center, start, end)",
          "description": "Calculate angle (in radians) between two points on a circle with a given center.",
          "parameters": [
            {
              "name": "center",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "start",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "end",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def angle_between_points(center, start, end):\n    \"\"\"Calculate angle (in radians) between two points on a circle with a given center.\"\"\"\n    dx1, dy1 = start.x - center.x, start.y - center.y\n    dx2, dy2 = end.x - center.x, end.y - center.y\n    angle1 = math.atan2(dy1, dx1)\n    angle2 = math.atan2(dy2, dx2)\n    return abs(angle2 - angle1) % (2 * math.pi)"
        },
        "visualize_logits": {
          "name": "visualize_logits",
          "path": "rapidcadpy.functions.visualize_logits",
          "signature": "(logits, top_k=20, title='Logits Distribution')",
          "description": "Visualize logits distribution with highlighted top-k values.\n\nArgs:\n    logits: torch.Tensor of shape [vocab_size]\n    top_k: Number of top logits to highlight\n    title: Plot title",
          "parameters": [
            {
              "name": "logits",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "top_k",
              "annotation": null,
              "description": null,
              "value": "20"
            },
            {
              "name": "title",
              "annotation": null,
              "description": null,
              "value": "'Logits Distribution'"
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def visualize_logits(logits, top_k=20, title=\"Logits Distribution\"):\n    \"\"\"\n    Visualize logits distribution with highlighted top-k values.\n\n    Args:\n        logits: torch.Tensor of shape [vocab_size]\n        top_k: Number of top logits to highlight\n        title: Plot title\n    \"\"\"\n    # Convert to numpy\n    logits_np = logits.cpu().detach().numpy()\n\n    # Get top-k indices and values\n    top_k_values, top_k_indices = torch.topk(logits, k=top_k)\n    # top_k_indices += 1  # Adjust for the +1 offset in your model\n    top_k_values = top_k_values.cpu().detach().numpy().tolist()\n    top_k_indices = top_k_indices.cpu().detach().numpy().tolist()\n\n    # Create the plot\n    plt.figure(figsize=(15, 6))\n\n    # Plot all logits\n    plt.plot(range(len(logits_np)), logits_np, \"b-\", alpha=0.3, label=\"All logits\")\n\n    # Highlight top-k values\n    plt.scatter(\n        top_k_indices,\n        top_k_values,\n        color=\"red\",\n        s=100,\n        alpha=0.5,\n        label=f\"Top {top_k} logits\",\n    )\n\n    # Add token indices for top-k values\n    for idx, val in zip(top_k_indices, top_k_values):\n        plt.annotate(\n            f\"Token {idx}\",  # Adjust for the +1 offset in your model\n            (idx, val),\n            xytext=(0, 10),\n            textcoords=\"offset points\",\n            ha=\"center\",\n            rotation=45,\n        )\n\n    # Customize the plot\n    plt.title(title)\n    plt.xlabel(\"Token Index\")\n    plt.ylabel(\"Logit Value\")\n    plt.grid(True, alpha=0.3)\n    plt.legend()\n    plt.show()"
        },
        "visualize_output_tensors": {
          "name": "visualize_output_tensors",
          "path": "rapidcadpy.functions.visualize_output_tensors",
          "signature": "(pre_fcn, post_fcn, seq_length=None)",
          "description": "Visualize output tensors before and after FCN layer.\n\nArgs:\n    pre_fcn: Output tensor before FCN [seq_len, vocab_size]\n    post_fcn: Output tensor after FCN [seq_len, vocab_size]\n    seq_length: Optional sequence length to plot",
          "parameters": [
            {
              "name": "pre_fcn",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "post_fcn",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "seq_length",
              "annotation": null,
              "description": null,
              "value": "None"
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def visualize_output_tensors(pre_fcn, post_fcn, seq_length=None):\n    \"\"\"\n    Visualize output tensors before and after FCN layer.\n\n    Args:\n        pre_fcn: Output tensor before FCN [seq_len, vocab_size]\n        post_fcn: Output tensor after FCN [seq_len, vocab_size]\n        seq_length: Optional sequence length to plot\n    \"\"\"\n    import seaborn as sns\n\n    plt.close(\"all\")\n\n    # Convert to numpy and get argmax\n    pre_fcn = pre_fcn.detach().cpu().numpy()\n    post_fcn = post_fcn.detach().cpu().numpy()\n\n    if seq_length is None:\n        seq_length = min(pre_fcn.shape[0], 20)\n\n    # Create subplots\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 10))\n\n    # Plot heatmap for pre-FCN outputs\n    sns.heatmap(pre_fcn[:seq_length], ax=ax1, cmap=\"coolwarm\", center=0)\n    ax1.set_title(\"Output Distribution Before FCN\")\n    ax1.set_xlabel(\"Vocabulary Index\")\n    ax1.set_ylabel(\"Sequence Position\")\n\n    # Plot heatmap for post-FCN outputs\n    sns.heatmap(post_fcn[:seq_length], ax=ax2, cmap=\"coolwarm\", center=0)\n    ax2.set_title(\"Output Distribution After FCN\")\n    ax2.set_xlabel(\"Vocabulary Index\")\n    ax2.set_ylabel(\"Sequence Position\")\n\n    # Add colorbar\n    plt.colorbar(ax1.collections[0], ax=ax1, label=\"Value\")\n    plt.colorbar(ax2.collections[0], ax=ax2, label=\"Value\")\n\n    plt.tight_layout()\n\n    # Print statistics\n    print_statistics = False\n    if print_statistics:\n        print(\"\\nPre-FCN Statistics:\")\n        print(f\"Mean: {pre_fcn.mean():.4f}\")\n        print(f\"Std: {pre_fcn.std():.4f}\")\n        print(f\"Max: {pre_fcn.max():.4f}\")\n        print(f\"Min: {pre_fcn.min():.4f}\")\n\n        print(\"\\nPost-FCN Statistics:\")\n        print(f\"Mean: {post_fcn.mean():.4f}\")\n        print(f\"Std: {post_fcn.std():.4f}\")\n        print(f\"Max: {post_fcn.max():.4f}\")\n        print(f\"Min: {post_fcn.min():.4f}\")\n\n        # Show argmax for each position\n        print(\"\\nArgmax tokens per position:\")\n        for pos in range(seq_length):\n            pre_max = pre_fcn[pos].argmax()\n            post_max = post_fcn[pos].argmax()\n            print(\n                f\"Position {pos}: Pre-FCN: {pre_max - 1}, Post-FCN: {post_max - 1}\"\n            )  # -1 for token offset\n\n    plt.show()"
        },
        "visualize_cad_vec": {
          "name": "visualize_cad_vec",
          "path": "rapidcadpy.functions.visualize_cad_vec",
          "signature": "(source, target=None)",
          "description": null,
          "parameters": [
            {
              "name": "source",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "target",
              "annotation": null,
              "description": null,
              "value": "None"
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def visualize_cad_vec(source, target=None):\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))\n    sns.heatmap(source, ax=ax1, annot=True, cmap=\"viridis\", fmt=\"d\", cbar=False)\n    ax1.set_xlabel(\"Sequence Index\")\n    ax1.set_ylabel(\"Source\")\n    if target is not None:\n        sns.heatmap(target, ax=ax2, annot=True, cmap=\"viridis\", fmt=\"d\", cbar=False)\n        ax2.set_xlabel(\"Sequence Index\")\n        ax2.set_ylabel(\"Target\")\n    plt.show()"
        }
      }
    },
    "constraint": {
      "name": "constraint",
      "path": "rapidcadpy.constraint",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/constraint.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "ConstraintType": {
          "name": "ConstraintType",
          "path": "rapidcadpy.constraint.ConstraintType",
          "description": "This enumeration represents the type of the constraint.",
          "parameters": [],
          "attributes": [
            {
              "name": "Coincident",
              "annotation": null,
              "description": null,
              "value": "'Coincident'"
            },
            {
              "name": "Projected",
              "annotation": null,
              "description": null,
              "value": "'Projected'"
            },
            {
              "name": "Mirror",
              "annotation": null,
              "description": null,
              "value": "'Mirror'"
            },
            {
              "name": "Distance",
              "annotation": null,
              "description": null,
              "value": "'Distance'"
            },
            {
              "name": "Horizontal",
              "annotation": null,
              "description": null,
              "value": "'Horizontal'"
            },
            {
              "name": "Parallel",
              "annotation": null,
              "description": null,
              "value": "'Parallel'"
            },
            {
              "name": "Vertical",
              "annotation": null,
              "description": null,
              "value": "'Vertical'"
            },
            {
              "name": "Tangent",
              "annotation": null,
              "description": null,
              "value": "'Tangent'"
            },
            {
              "name": "Length",
              "annotation": null,
              "description": null,
              "value": "'Length'"
            },
            {
              "name": "Perpendicular",
              "annotation": null,
              "description": null,
              "value": "'Perpendicular'"
            },
            {
              "name": "Midpoint",
              "annotation": null,
              "description": null,
              "value": "'Midpoint'"
            },
            {
              "name": "Equal",
              "annotation": null,
              "description": null,
              "value": "'Equal'"
            },
            {
              "name": "Diameter",
              "annotation": null,
              "description": null,
              "value": "'Diameter'"
            },
            {
              "name": "Offset",
              "annotation": null,
              "description": null,
              "value": "'Offset'"
            },
            {
              "name": "Radius",
              "annotation": null,
              "description": null,
              "value": "'Radius'"
            },
            {
              "name": "Concentric",
              "annotation": null,
              "description": null,
              "value": "'Concentric'"
            },
            {
              "name": "Fix",
              "annotation": null,
              "description": null,
              "value": "'Fix'"
            },
            {
              "name": "Angle",
              "annotation": null,
              "description": null,
              "value": "'Angle'"
            },
            {
              "name": "Circular_Pattern",
              "annotation": null,
              "description": null,
              "value": "'Circular_Pattern'"
            },
            {
              "name": "Pierce",
              "annotation": null,
              "description": null,
              "value": "'Pierce'"
            },
            {
              "name": "Linear_Pattern",
              "annotation": null,
              "description": null,
              "value": "'Linear_Pattern'"
            },
            {
              "name": "Centerline_Dimension",
              "annotation": null,
              "description": null,
              "value": "'Centerline_Dimension'"
            },
            {
              "name": "Intersected",
              "annotation": null,
              "description": null,
              "value": "'Intersected'"
            },
            {
              "name": "Silhoutted",
              "annotation": null,
              "description": null,
              "value": "'Silhoutted'"
            },
            {
              "name": "Quadrant",
              "annotation": null,
              "description": null,
              "value": "'Quadrant'"
            },
            {
              "name": "Normal",
              "annotation": null,
              "description": null,
              "value": "'Normal'"
            },
            {
              "name": "Minor_Diameter",
              "annotation": null,
              "description": null,
              "value": "'Minor_Diameter'"
            },
            {
              "name": "Major_Diameter",
              "annotation": null,
              "description": null,
              "value": "'Major_Diameter'"
            },
            {
              "name": "Rho",
              "annotation": null,
              "description": null,
              "value": "'Rho'"
            },
            {
              "name": "Unknown",
              "annotation": null,
              "description": null,
              "value": "'Unknown'"
            },
            {
              "name": "Subnode",
              "annotation": null,
              "description": null,
              "value": "'Subnode'"
            }
          ],
          "docstring": [],
          "functions": {
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.constraint.ConstraintType.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    return self.value"
            },
            "from_value": {
              "name": "from_value",
              "path": "rapidcadpy.constraint.ConstraintType.from_value",
              "signature": "(cls, value)",
              "description": "Get an enum member by its string value.",
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "value",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@classmethod\ndef from_value(cls, value: str):\n    \"\"\"Get an enum member by its string value.\"\"\"\n    for item in cls:\n        if item.value == value:\n            return item\n    raise ValueError(f\"{value} is not a valid {cls.__name__}\")"
            }
          },
          "source": "class ConstraintType(StrEnum):\n    \"\"\"This enumeration represents the type of the constraint.\"\"\"\n\n    Coincident = \"Coincident\"\n    Projected = \"Projected\"\n    Mirror = \"Mirror\"\n    Distance = \"Distance\"\n    Horizontal = \"Horizontal\"\n    Parallel = \"Parallel\"\n    Vertical = \"Vertical\"\n    Tangent = \"Tangent\"\n    Length = \"Length\"\n    Perpendicular = \"Perpendicular\"\n    Midpoint = \"Midpoint\"\n    Equal = \"Equal\"\n    Diameter = \"Diameter\"\n    Offset = \"Offset\"\n    Radius = \"Radius\"\n    Concentric = \"Concentric\"\n    Fix = \"Fix\"\n    Angle = \"Angle\"\n    Circular_Pattern = \"Circular_Pattern\"\n    Pierce = \"Pierce\"\n    Linear_Pattern = \"Linear_Pattern\"\n    Centerline_Dimension = \"Centerline_Dimension\"\n    Intersected = \"Intersected\"\n    Silhoutted = \"Silhoutted\"\n    Quadrant = \"Quadrant\"\n    Normal = \"Normal\"\n    Minor_Diameter = \"Minor_Diameter\"\n    Major_Diameter = \"Major_Diameter\"\n    Rho = \"Rho\"\n    Unknown = \"Unknown\"\n    Subnode = \"Subnode\"\n\n    def __str__(self):\n        return self.value\n\n    @classmethod\n    def from_value(cls, value: str):\n        \"\"\"Get an enum member by its string value.\"\"\"\n        for item in cls:\n            if item.value == value:\n                return item\n        raise ValueError(f\"{value} is not a valid {cls.__name__}\")",
          "inherited_members": {}
        },
        "Constraint": {
          "name": "Constraint",
          "path": "rapidcadpy.constraint.Constraint",
          "description": "This class represents a constraint.\n\nA constraint is represented by a given type, and a list of parameters,\nwhich specify the concrete effect of the constraint.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "identifier",
              "annotation": "ConstraintType",
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.constraint.Constraint.__init__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self):\n    pass"
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.constraint.Constraint.to_json",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self):\n    raise NotImplementedError"
            }
          },
          "source": "class Constraint(ABC):\n    \"\"\"This class represents a constraint.\n\n    A constraint is represented by a given type, and a list of parameters,\n    which specify the concrete effect of the constraint.\n    \"\"\"\n\n    identifier: ConstraintType\n\n    def __init__(self):\n        pass\n\n    def to_json(self):\n        raise NotImplementedError",
          "inherited_members": {}
        },
        "CoincidenceConstraint": {
          "name": "CoincidenceConstraint",
          "path": "rapidcadpy.constraint.CoincidenceConstraint",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "vertex",
              "annotation": "Vertex",
              "description": null,
              "value": null
            },
            {
              "name": "entity",
              "annotation": "typing.Union[Vertex, Primitive]",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "vertex",
              "annotation": null,
              "description": null,
              "value": "vertex"
            },
            {
              "name": "entity",
              "annotation": null,
              "description": null,
              "value": "entity"
            },
            {
              "name": "identifier",
              "annotation": null,
              "description": null,
              "value": "ConstraintType.Coincident"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.constraint.CoincidenceConstraint.__init__",
              "signature": "(self, vertex, entity)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "vertex",
                  "annotation": "Vertex",
                  "description": null,
                  "value": null
                },
                {
                  "name": "entity",
                  "annotation": "typing.Union[Vertex, Primitive]",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, vertex: Vertex, entity: typing.Union[Vertex, Primitive]):\n    super().__init__()\n    self.vertex = vertex\n    self.entity = entity\n    self.identifier = ConstraintType.Coincident"
            },
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.constraint.CoincidenceConstraint.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    return f\"CoincidenceConstraint({self.vertex}, {self.entity})\""
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.constraint.CoincidenceConstraint.to_json",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self):\n    return {\n        \"type\": self.identifier,\n        \"vertex\": str(self.vertex.name),\n        \"entity\": str(self.entity.name),\n    }"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "rapidcadpy.constraint.CoincidenceConstraint.__repr__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self):\n    return f\"CoincidenceConstraint({self.vertex}, {self.entity})\""
            }
          },
          "source": "class CoincidenceConstraint(Constraint):\n    def __init__(self, vertex: Vertex, entity: typing.Union[Vertex, Primitive]):\n        super().__init__()\n        self.vertex = vertex\n        self.entity = entity\n        self.identifier = ConstraintType.Coincident\n\n    def __str__(self):\n        return f\"CoincidenceConstraint({self.vertex}, {self.entity})\"\n\n    def to_json(self):\n        return {\n            \"type\": self.identifier,\n            \"vertex\": str(self.vertex.name),\n            \"entity\": str(self.entity.name),\n        }\n\n    def __repr__(self):\n        return f\"CoincidenceConstraint({self.vertex}, {self.entity})\"",
          "inherited_members": {}
        },
        "StartToEndCoincidenceConstraint": {
          "name": "StartToEndCoincidenceConstraint",
          "path": "rapidcadpy.constraint.StartToEndCoincidenceConstraint",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "end_primitive",
              "annotation": "Primitive",
              "description": null,
              "value": null
            },
            {
              "name": "start_primitive",
              "annotation": "Primitive",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "end_primitive",
              "annotation": null,
              "description": null,
              "value": "end_primitive"
            },
            {
              "name": "start_primitive",
              "annotation": null,
              "description": null,
              "value": "start_primitive"
            },
            {
              "name": "identifier",
              "annotation": null,
              "description": null,
              "value": "ConstraintType.Coincident"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.constraint.StartToEndCoincidenceConstraint.__init__",
              "signature": "(self, end_primitive, start_primitive)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "end_primitive",
                  "annotation": "Primitive",
                  "description": null,
                  "value": null
                },
                {
                  "name": "start_primitive",
                  "annotation": "Primitive",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, end_primitive: Primitive, start_primitive: Primitive):\n    super().__init__()\n    self.end_primitive = end_primitive\n    self.start_primitive = start_primitive\n    self.identifier = ConstraintType.Coincident"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "rapidcadpy.constraint.StartToEndCoincidenceConstraint.__repr__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self):\n    return f\"StartToEndCoincidenceConstraint({self.end_primitive}, {self.start_primitive})\""
            }
          },
          "source": "class StartToEndCoincidenceConstraint(Constraint):\n    def __init__(self, end_primitive: Primitive, start_primitive: Primitive):\n        super().__init__()\n        self.end_primitive = end_primitive\n        self.start_primitive = start_primitive\n        self.identifier = ConstraintType.Coincident\n\n    def __repr__(self):\n        return f\"StartToEndCoincidenceConstraint({self.end_primitive}, {self.start_primitive})\"",
          "inherited_members": {
            "rapidcadpy.constraint.Constraint": [
              {
                "kind": "function",
                "path": "rapidcadpy.constraint.Constraint.to_json"
              }
            ]
          }
        },
        "EndToStartCoincidenceConstraint": {
          "name": "EndToStartCoincidenceConstraint",
          "path": "rapidcadpy.constraint.EndToStartCoincidenceConstraint",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "end_primitive",
              "annotation": "Primitive",
              "description": null,
              "value": null
            },
            {
              "name": "start_primitive",
              "annotation": "Primitive",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "end_primitive",
              "annotation": null,
              "description": null,
              "value": "end_primitive"
            },
            {
              "name": "start_primitive",
              "annotation": null,
              "description": null,
              "value": "start_primitive"
            },
            {
              "name": "identifier",
              "annotation": null,
              "description": null,
              "value": "ConstraintType.Coincident"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.constraint.EndToStartCoincidenceConstraint.__init__",
              "signature": "(self, end_primitive, start_primitive)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "end_primitive",
                  "annotation": "Primitive",
                  "description": null,
                  "value": null
                },
                {
                  "name": "start_primitive",
                  "annotation": "Primitive",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, end_primitive: Primitive, start_primitive: Primitive):\n    super().__init__()\n    self.end_primitive = end_primitive\n    self.start_primitive = start_primitive\n    self.identifier = ConstraintType.Coincident"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "rapidcadpy.constraint.EndToStartCoincidenceConstraint.__repr__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self):\n    return f\"EndToStartCoincidenceConstraint({self.end_primitive}, {self.start_primitive})\""
            }
          },
          "source": "class EndToStartCoincidenceConstraint(Constraint):\n    def __init__(self, end_primitive: Primitive, start_primitive: Primitive):\n        super().__init__()\n        self.end_primitive = end_primitive\n        self.start_primitive = start_primitive\n        self.identifier = ConstraintType.Coincident\n\n    def __repr__(self):\n        return f\"EndToStartCoincidenceConstraint({self.end_primitive}, {self.start_primitive})\"",
          "inherited_members": {
            "rapidcadpy.constraint.Constraint": [
              {
                "kind": "function",
                "path": "rapidcadpy.constraint.Constraint.to_json"
              }
            ]
          }
        },
        "ConcentricConstraint": {
          "name": "ConcentricConstraint",
          "path": "rapidcadpy.constraint.ConcentricConstraint",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "first",
              "annotation": "Circle",
              "description": null,
              "value": null
            },
            {
              "name": "second",
              "annotation": "Circle",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "first",
              "annotation": null,
              "description": null,
              "value": "first"
            },
            {
              "name": "second",
              "annotation": null,
              "description": null,
              "value": "second"
            },
            {
              "name": "identifier",
              "annotation": null,
              "description": null,
              "value": "ConstraintType.Concentric"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.constraint.ConcentricConstraint.__init__",
              "signature": "(self, first, second)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "first",
                  "annotation": "Circle",
                  "description": null,
                  "value": null
                },
                {
                  "name": "second",
                  "annotation": "Circle",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, first: Circle, second: Circle):\n    self.first = first\n    self.second = second\n    self.identifier = ConstraintType.Concentric\n    super().__init__()"
            },
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.constraint.ConcentricConstraint.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    return f\"ConcentricConstraint({self.first}, {self.second})\""
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.constraint.ConcentricConstraint.to_json",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self):\n    return {\n        \"type\": self.identifier,\n        \"first\": self.first,\n        \"second\": self.second,\n    }"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "rapidcadpy.constraint.ConcentricConstraint.__repr__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self):\n    return f\"ConcentricConstraint({self.first}, {self.second})\""
            }
          },
          "source": "class ConcentricConstraint(Constraint):\n    def __init__(self, first: Circle, second: Circle):\n        self.first = first\n        self.second = second\n        self.identifier = ConstraintType.Concentric\n        super().__init__()\n\n    def __str__(self):\n        return f\"ConcentricConstraint({self.first}, {self.second})\"\n\n    def to_json(self):\n        return {\n            \"type\": self.identifier,\n            \"first\": self.first,\n            \"second\": self.second,\n        }\n\n    def __repr__(self):\n        return f\"ConcentricConstraint({self.first}, {self.second})\"",
          "inherited_members": {}
        },
        "HorizontalConstraint": {
          "name": "HorizontalConstraint",
          "path": "rapidcadpy.constraint.HorizontalConstraint",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "primitive",
              "annotation": "Primitive",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "primitive",
              "annotation": null,
              "description": null,
              "value": "primitive"
            },
            {
              "name": "identifier",
              "annotation": null,
              "description": null,
              "value": "ConstraintType.Horizontal"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.constraint.HorizontalConstraint.__init__",
              "signature": "(self, primitive)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "primitive",
                  "annotation": "Primitive",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, primitive: Primitive):\n    self.primitive = primitive\n    self.identifier = ConstraintType.Horizontal\n    super().__init__()"
            },
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.constraint.HorizontalConstraint.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    return f\"HorizontalConstraint({self.primitive})\""
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.constraint.HorizontalConstraint.to_json",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self):\n    return {\"type\": self.identifier, \"primitive\": str(self.primitive.name)}"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "rapidcadpy.constraint.HorizontalConstraint.__repr__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self):\n    return f\"HorizontalConstraint({self.primitive.__repr__()})\""
            }
          },
          "source": "class HorizontalConstraint(Constraint):\n    def __init__(self, primitive: Primitive):\n        self.primitive = primitive\n        self.identifier = ConstraintType.Horizontal\n        super().__init__()\n\n    def __str__(self):\n        return f\"HorizontalConstraint({self.primitive})\"\n\n    def to_json(self):\n        return {\"type\": self.identifier, \"primitive\": str(self.primitive.name)}\n\n    def __repr__(self):\n        return f\"HorizontalConstraint({self.primitive.__repr__()})\"",
          "inherited_members": {}
        },
        "VerticalConstraint": {
          "name": "VerticalConstraint",
          "path": "rapidcadpy.constraint.VerticalConstraint",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "primitive",
              "annotation": "Primitive",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "primitive",
              "annotation": null,
              "description": null,
              "value": "primitive"
            },
            {
              "name": "identifier",
              "annotation": null,
              "description": null,
              "value": "ConstraintType.Vertical"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.constraint.VerticalConstraint.__init__",
              "signature": "(self, primitive)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "primitive",
                  "annotation": "Primitive",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, primitive: Primitive):\n    self.primitive = primitive\n    self.identifier = ConstraintType.Vertical\n    super().__init__()"
            },
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.constraint.VerticalConstraint.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    return f\"VerticalConstraint({self.primitive})\""
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.constraint.VerticalConstraint.to_json",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self):\n    return {\"type\": self.identifier, \"primitive\": str(self.primitive.name)}"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "rapidcadpy.constraint.VerticalConstraint.__repr__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self):\n    return f\"VerticalConstraint({self.primitive.__repr__()})\""
            }
          },
          "source": "class VerticalConstraint(Constraint):\n    def __init__(self, primitive: Primitive):\n        self.primitive = primitive\n        self.identifier = ConstraintType.Vertical\n        super().__init__()\n\n    def __str__(self):\n        return f\"VerticalConstraint({self.primitive})\"\n\n    def to_json(self):\n        return {\"type\": self.identifier, \"primitive\": str(self.primitive.name)}\n\n    def __repr__(self):\n        return f\"VerticalConstraint({self.primitive.__repr__()})\"",
          "inherited_members": {}
        },
        "PerpendicularConstraint": {
          "name": "PerpendicularConstraint",
          "path": "rapidcadpy.constraint.PerpendicularConstraint",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "first",
              "annotation": "Primitive",
              "description": null,
              "value": null
            },
            {
              "name": "second",
              "annotation": "Primitive",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "first",
              "annotation": null,
              "description": null,
              "value": "first"
            },
            {
              "name": "second",
              "annotation": null,
              "description": null,
              "value": "second"
            },
            {
              "name": "identifier",
              "annotation": null,
              "description": null,
              "value": "ConstraintType.Perpendicular"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.constraint.PerpendicularConstraint.__init__",
              "signature": "(self, first, second)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "first",
                  "annotation": "Primitive",
                  "description": null,
                  "value": null
                },
                {
                  "name": "second",
                  "annotation": "Primitive",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, first: Primitive, second: Primitive):\n    self.first = first\n    self.second = second\n    self.identifier = ConstraintType.Perpendicular\n    super().__init__()"
            },
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.constraint.PerpendicularConstraint.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    return f\"PerpendicularConstraint({self.first}, {self.second})\""
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.constraint.PerpendicularConstraint.to_json",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self):\n    return {\n        \"type\": self.identifier,\n        \"first\": str(self.first.id),\n        \"second\": str(self.second.id),\n    }"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "rapidcadpy.constraint.PerpendicularConstraint.__repr__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self):\n    return f\"PerpendicularConstraint({self.first}, {self.second})\""
            }
          },
          "source": "class PerpendicularConstraint(Constraint):\n    def __init__(self, first: Primitive, second: Primitive):\n        self.first = first\n        self.second = second\n        self.identifier = ConstraintType.Perpendicular\n        super().__init__()\n\n    def __str__(self):\n        return f\"PerpendicularConstraint({self.first}, {self.second})\"\n\n    def to_json(self):\n        return {\n            \"type\": self.identifier,\n            \"first\": str(self.first.id),\n            \"second\": str(self.second.id),\n        }\n\n    def __repr__(self):\n        return f\"PerpendicularConstraint({self.first}, {self.second})\"",
          "inherited_members": {}
        },
        "ParallelConstraint": {
          "name": "ParallelConstraint",
          "path": "rapidcadpy.constraint.ParallelConstraint",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "first",
              "annotation": "Primitive",
              "description": null,
              "value": null
            },
            {
              "name": "second",
              "annotation": "Primitive",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "first",
              "annotation": null,
              "description": null,
              "value": "first"
            },
            {
              "name": "second",
              "annotation": null,
              "description": null,
              "value": "second"
            },
            {
              "name": "identifier",
              "annotation": null,
              "description": null,
              "value": "ConstraintType.Parallel"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.constraint.ParallelConstraint.__init__",
              "signature": "(self, first, second)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "first",
                  "annotation": "Primitive",
                  "description": null,
                  "value": null
                },
                {
                  "name": "second",
                  "annotation": "Primitive",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, first: Primitive, second: Primitive):\n    self.first = first\n    self.second = second\n    self.identifier = ConstraintType.Parallel\n    super().__init__()"
            },
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.constraint.ParallelConstraint.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    return f\"ParallelConstraint({self.first}, {self.second})\""
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.constraint.ParallelConstraint.to_json",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self):\n    return {\n        \"type\": self.identifier,\n        \"first\": str(self.first.id),\n        \"second\": str(self.second.id),\n    }"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "rapidcadpy.constraint.ParallelConstraint.__repr__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self):\n    return f\"ParallelConstraint({self.first}, {self.second})\""
            }
          },
          "source": "class ParallelConstraint(Constraint):\n    def __init__(self, first: Primitive, second: Primitive):\n        self.first = first\n        self.second = second\n        self.identifier = ConstraintType.Parallel\n        super().__init__()\n\n    def __str__(self):\n        return f\"ParallelConstraint({self.first}, {self.second})\"\n\n    def to_json(self):\n        return {\n            \"type\": self.identifier,\n            \"first\": str(self.first.id),\n            \"second\": str(self.second.id),\n        }\n\n    def __repr__(self):\n        return f\"ParallelConstraint({self.first}, {self.second})\"",
          "inherited_members": {}
        },
        "TangentConstraint": {
          "name": "TangentConstraint",
          "path": "rapidcadpy.constraint.TangentConstraint",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "first",
              "annotation": "Primitive",
              "description": null,
              "value": null
            },
            {
              "name": "second",
              "annotation": "Primitive",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "first",
              "annotation": null,
              "description": null,
              "value": "first"
            },
            {
              "name": "second",
              "annotation": null,
              "description": null,
              "value": "second"
            },
            {
              "name": "identifier",
              "annotation": null,
              "description": null,
              "value": "ConstraintType.Tangent"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.constraint.TangentConstraint.__init__",
              "signature": "(self, first, second)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "first",
                  "annotation": "Primitive",
                  "description": null,
                  "value": null
                },
                {
                  "name": "second",
                  "annotation": "Primitive",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, first: Primitive, second: Primitive):\n    self.first = first\n    self.second = second\n    self.identifier = ConstraintType.Tangent\n    super().__init__()"
            },
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.constraint.TangentConstraint.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    return f\"TangentConstraint({self.first}, {self.second})\""
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.constraint.TangentConstraint.to_json",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self):\n    return {\n        \"type\": self.identifier,\n        \"first\": str(self.first.id),\n        \"second\": str(self.second.id),\n    }"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "rapidcadpy.constraint.TangentConstraint.__repr__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self):\n    return f\"TangentConstraint({self.first}, {self.second})\""
            }
          },
          "source": "class TangentConstraint(Constraint):\n    def __init__(self, first: Primitive, second: Primitive):\n        self.first = first\n        self.second = second\n        self.identifier = ConstraintType.Tangent\n        super().__init__()\n\n    def __str__(self):\n        return f\"TangentConstraint({self.first}, {self.second})\"\n\n    def to_json(self):\n        return {\n            \"type\": self.identifier,\n            \"first\": str(self.first.id),\n            \"second\": str(self.second.id),\n        }\n\n    def __repr__(self):\n        return f\"TangentConstraint({self.first}, {self.second})\"",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "machining_feature": {
      "name": "machining_feature",
      "path": "rapidcadpy.machining_feature",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/machining_feature.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "MachiningFeature": {
          "name": "MachiningFeature",
          "path": "rapidcadpy.machining_feature.MachiningFeature",
          "description": "Abstract base class for machining features.\n\nMachining features represent subtractive operations like holes, slots, and cuts.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "sketch_plane",
              "annotation": "Plane",
              "description": null,
              "value": "Plane()"
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "uuid.uuid4()"
            },
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": "'Feature'"
            }
          ],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.machining_feature.MachiningFeature.__init__",
              "signature": "(self, sketch_plane=Plane(), id=uuid.uuid4(), name='Feature') -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "sketch_plane",
                  "annotation": "Plane",
                  "description": null,
                  "value": "Plane()"
                },
                {
                  "name": "id",
                  "annotation": "Optional[uuid.UUID]",
                  "description": null,
                  "value": "uuid.uuid4()"
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "'Feature'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass\nclass MachiningFeature(Feature, ABC):\n    \"\"\"\n    Abstract base class for machining features.\n\n    Machining features represent subtractive operations like holes, slots, and cuts.\n    \"\"\"\n\n    pass",
          "inherited_members": {
            "rapidcadpy.feature.Feature": [
              {
                "kind": "attribute",
                "path": "rapidcadpy.feature.Feature.sketch_plane"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.feature.Feature.id"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.feature.Feature.name"
              },
              {
                "kind": "function",
                "path": "rapidcadpy.feature.Feature.to_json"
              },
              {
                "kind": "function",
                "path": "rapidcadpy.feature.Feature.to_python"
              },
              {
                "kind": "function",
                "path": "rapidcadpy.feature.Feature.__post_init__"
              }
            ]
          }
        },
        "CounterSunkHole": {
          "name": "CounterSunkHole",
          "path": "rapidcadpy.machining_feature.CounterSunkHole",
          "description": "A counter-sunk hole feature.\n\nRepresents a hole with a conical countersink at the top.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "sketch_plane",
              "annotation": "Plane",
              "description": null,
              "value": "Plane()"
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "uuid.uuid4()"
            },
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": "'Feature'"
            },
            {
              "name": "diameter",
              "annotation": "float",
              "description": null,
              "value": "5.0"
            },
            {
              "name": "depth",
              "annotation": "float",
              "description": null,
              "value": "10.0"
            },
            {
              "name": "countersink_diameter",
              "annotation": "float",
              "description": null,
              "value": "8.0"
            },
            {
              "name": "countersink_angle",
              "annotation": "float",
              "description": null,
              "value": "90.0"
            }
          ],
          "attributes": [
            {
              "name": "diameter",
              "annotation": "float",
              "description": null,
              "value": "5.0"
            },
            {
              "name": "depth",
              "annotation": "float",
              "description": null,
              "value": "10.0"
            },
            {
              "name": "countersink_diameter",
              "annotation": "float",
              "description": null,
              "value": "8.0"
            },
            {
              "name": "countersink_angle",
              "annotation": "float",
              "description": null,
              "value": "90.0"
            }
          ],
          "docstring": [],
          "functions": {
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.machining_feature.CounterSunkHole.to_json",
              "signature": "(self) -> Dict[str, Any]",
              "description": "Convert to JSON representation.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Dict[str, typing.Any]",
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self) -> Dict[str, Any]:\n    \"\"\"Convert to JSON representation.\"\"\"\n    return {\n        \"type\": \"CounterSunkHole\",\n        \"id\": str(self.id),\n        \"name\": self.name,\n        \"sketch_plane\": self.sketch_plane.to_json(),\n        \"diameter\": self.diameter,\n        \"depth\": self.depth,\n        \"countersink_diameter\": self.countersink_diameter,\n        \"countersink_angle\": self.countersink_angle,\n    }"
            },
            "to_python": {
              "name": "to_python",
              "path": "rapidcadpy.machining_feature.CounterSunkHole.to_python",
              "signature": "(self, index=0) -> str",
              "description": "Generate Python code to recreate this feature.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "index",
                  "annotation": "int",
                  "description": null,
                  "value": "0"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "    def to_python(self, index: int = 0) -> str:\n        \"\"\"Generate Python code to recreate this feature.\"\"\"\n        return f\"\"\"countersunk_hole_{index} = CounterSunkHole(\n    diameter={self.diameter},\n    depth={self.depth},\n    countersink_diameter={self.countersink_diameter},\n    countersink_angle={self.countersink_angle},\n    sketch_plane={self.sketch_plane.to_python() if hasattr(self.sketch_plane, 'to_python') else 'Plane()'},\n    name=\"{self.name}\"\n)\"\"\""
            },
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.machining_feature.CounterSunkHole.__init__",
              "signature": "(self, sketch_plane=Plane(), id=uuid.uuid4(), name='Feature', diameter=5.0, depth=10.0, countersink_diameter=8.0, countersink_angle=90.0) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "sketch_plane",
                  "annotation": "Plane",
                  "description": null,
                  "value": "Plane()"
                },
                {
                  "name": "id",
                  "annotation": "Optional[uuid.UUID]",
                  "description": null,
                  "value": "uuid.uuid4()"
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "'Feature'"
                },
                {
                  "name": "diameter",
                  "annotation": "float",
                  "description": null,
                  "value": "5.0"
                },
                {
                  "name": "depth",
                  "annotation": "float",
                  "description": null,
                  "value": "10.0"
                },
                {
                  "name": "countersink_diameter",
                  "annotation": "float",
                  "description": null,
                  "value": "8.0"
                },
                {
                  "name": "countersink_angle",
                  "annotation": "float",
                  "description": null,
                  "value": "90.0"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass\nclass CounterSunkHole(MachiningFeature):\n    \"\"\"\n    A counter-sunk hole feature.\n\n    Represents a hole with a conical countersink at the top.\n    \"\"\"\n\n    diameter: float = 5.0\n    depth: float = 10.0\n    countersink_diameter: float = 8.0\n    countersink_angle: float = 90.0  # degrees\n\n    def to_json(self) -> Dict[str, Any]:\n        \"\"\"Convert to JSON representation.\"\"\"\n        return {\n            \"type\": \"CounterSunkHole\",\n            \"id\": str(self.id),\n            \"name\": self.name,\n            \"sketch_plane\": self.sketch_plane.to_json(),\n            \"diameter\": self.diameter,\n            \"depth\": self.depth,\n            \"countersink_diameter\": self.countersink_diameter,\n            \"countersink_angle\": self.countersink_angle,\n        }\n\n    def to_python(self, index: int = 0) -> str:\n        \"\"\"Generate Python code to recreate this feature.\"\"\"\n        return f\"\"\"countersunk_hole_{index} = CounterSunkHole(\n    diameter={self.diameter},\n    depth={self.depth},\n    countersink_diameter={self.countersink_diameter},\n    countersink_angle={self.countersink_angle},\n    sketch_plane={self.sketch_plane.to_python() if hasattr(self.sketch_plane, 'to_python') else 'Plane()'},\n    name=\"{self.name}\"\n)\"\"\"",
          "inherited_members": {
            "rapidcadpy.feature.Feature": [
              {
                "kind": "attribute",
                "path": "rapidcadpy.feature.Feature.sketch_plane"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.feature.Feature.id"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.feature.Feature.name"
              },
              {
                "kind": "function",
                "path": "rapidcadpy.feature.Feature.__post_init__"
              }
            ]
          }
        },
        "ParallelKeyway": {
          "name": "ParallelKeyway",
          "path": "rapidcadpy.machining_feature.ParallelKeyway",
          "description": "A parallel keyway feature.\n\nRepresents a rectangular slot cut parallel to an axis.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "sketch_plane",
              "annotation": "Plane",
              "description": null,
              "value": "Plane()"
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "uuid.uuid4()"
            },
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": "'Feature'"
            },
            {
              "name": "width",
              "annotation": "float",
              "description": null,
              "value": "5.0"
            },
            {
              "name": "depth",
              "annotation": "float",
              "description": null,
              "value": "3.0"
            },
            {
              "name": "length",
              "annotation": "float",
              "description": null,
              "value": "20.0"
            },
            {
              "name": "orientation",
              "annotation": "Literal['horizontal', 'vertical']",
              "description": null,
              "value": "'horizontal'"
            }
          ],
          "attributes": [
            {
              "name": "width",
              "annotation": "float",
              "description": null,
              "value": "5.0"
            },
            {
              "name": "depth",
              "annotation": "float",
              "description": null,
              "value": "3.0"
            },
            {
              "name": "length",
              "annotation": "float",
              "description": null,
              "value": "20.0"
            },
            {
              "name": "orientation",
              "annotation": "Literal['horizontal', 'vertical']",
              "description": null,
              "value": "'horizontal'"
            }
          ],
          "docstring": [],
          "functions": {
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.machining_feature.ParallelKeyway.to_json",
              "signature": "(self) -> Dict[str, Any]",
              "description": "Convert to JSON representation.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Dict[str, typing.Any]",
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self) -> Dict[str, Any]:\n    \"\"\"Convert to JSON representation.\"\"\"\n    return {\n        \"type\": \"ParallelKeyway\",\n        \"id\": str(self.id),\n        \"name\": self.name,\n        \"sketch_plane\": self.sketch_plane.to_json(),\n        \"width\": self.width,\n        \"depth\": self.depth,\n        \"length\": self.length,\n        \"orientation\": self.orientation,\n    }"
            },
            "to_python": {
              "name": "to_python",
              "path": "rapidcadpy.machining_feature.ParallelKeyway.to_python",
              "signature": "(self, index=0) -> str",
              "description": "Generate Python code to recreate this feature.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "index",
                  "annotation": "int",
                  "description": null,
                  "value": "0"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "    def to_python(self, index: int = 0) -> str:\n        \"\"\"Generate Python code to recreate this feature.\"\"\"\n        return f\"\"\"parallel_keyway_{index} = ParallelKeyway(\n    width={self.width},\n    depth={self.depth},\n    length={self.length},\n    orientation=\"{self.orientation}\",\n    sketch_plane={self.sketch_plane.to_python() if hasattr(self.sketch_plane, 'to_python') else 'Plane()'},\n    name=\"{self.name}\"\n)\"\"\""
            },
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.machining_feature.ParallelKeyway.__init__",
              "signature": "(self, sketch_plane=Plane(), id=uuid.uuid4(), name='Feature', width=5.0, depth=3.0, length=20.0, orientation='horizontal') -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "sketch_plane",
                  "annotation": "Plane",
                  "description": null,
                  "value": "Plane()"
                },
                {
                  "name": "id",
                  "annotation": "Optional[uuid.UUID]",
                  "description": null,
                  "value": "uuid.uuid4()"
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "'Feature'"
                },
                {
                  "name": "width",
                  "annotation": "float",
                  "description": null,
                  "value": "5.0"
                },
                {
                  "name": "depth",
                  "annotation": "float",
                  "description": null,
                  "value": "3.0"
                },
                {
                  "name": "length",
                  "annotation": "float",
                  "description": null,
                  "value": "20.0"
                },
                {
                  "name": "orientation",
                  "annotation": "Literal['horizontal', 'vertical']",
                  "description": null,
                  "value": "'horizontal'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass\nclass ParallelKeyway(MachiningFeature):\n    \"\"\"\n    A parallel keyway feature.\n\n    Represents a rectangular slot cut parallel to an axis.\n    \"\"\"\n\n    width: float = 5.0\n    depth: float = 3.0\n    length: float = 20.0\n    orientation: Literal[\"horizontal\", \"vertical\"] = \"horizontal\"\n\n    def to_json(self) -> Dict[str, Any]:\n        \"\"\"Convert to JSON representation.\"\"\"\n        return {\n            \"type\": \"ParallelKeyway\",\n            \"id\": str(self.id),\n            \"name\": self.name,\n            \"sketch_plane\": self.sketch_plane.to_json(),\n            \"width\": self.width,\n            \"depth\": self.depth,\n            \"length\": self.length,\n            \"orientation\": self.orientation,\n        }\n\n    def to_python(self, index: int = 0) -> str:\n        \"\"\"Generate Python code to recreate this feature.\"\"\"\n        return f\"\"\"parallel_keyway_{index} = ParallelKeyway(\n    width={self.width},\n    depth={self.depth},\n    length={self.length},\n    orientation=\"{self.orientation}\",\n    sketch_plane={self.sketch_plane.to_python() if hasattr(self.sketch_plane, 'to_python') else 'Plane()'},\n    name=\"{self.name}\"\n)\"\"\"",
          "inherited_members": {
            "rapidcadpy.feature.Feature": [
              {
                "kind": "attribute",
                "path": "rapidcadpy.feature.Feature.sketch_plane"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.feature.Feature.id"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.feature.Feature.name"
              },
              {
                "kind": "function",
                "path": "rapidcadpy.feature.Feature.__post_init__"
              }
            ]
          }
        }
      },
      "functions": {}
    },
    "constants": {
      "name": "constants",
      "path": "rapidcadpy.constants",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/constants.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "TORCH_AVAILABLE",
          "annotation": null,
          "description": null,
          "value": "True"
        },
        {
          "name": "ALL_COMMANDS",
          "annotation": null,
          "description": null,
          "value": "['Line', 'Arc', 'Circle', 'EOS', 'SOS', 'Ext', 'Sketch', 'EOL']"
        },
        {
          "name": "LINE_IDX",
          "annotation": null,
          "description": null,
          "value": "ALL_COMMANDS.index('Line')"
        },
        {
          "name": "ARC_IDX",
          "annotation": null,
          "description": null,
          "value": "ALL_COMMANDS.index('Arc')"
        },
        {
          "name": "CIRCLE_IDX",
          "annotation": null,
          "description": null,
          "value": "ALL_COMMANDS.index('Circle')"
        },
        {
          "name": "EOS_IDX",
          "annotation": null,
          "description": null,
          "value": "ALL_COMMANDS.index('EOS')"
        },
        {
          "name": "SOL_IDX",
          "annotation": null,
          "description": null,
          "value": "ALL_COMMANDS.index('SOS')"
        },
        {
          "name": "EXT_IDX",
          "annotation": null,
          "description": null,
          "value": "ALL_COMMANDS.index('Ext')"
        },
        {
          "name": "SKETCH_IDX",
          "annotation": null,
          "description": null,
          "value": "ALL_COMMANDS.index('Sketch')"
        },
        {
          "name": "EOL_IDX",
          "annotation": null,
          "description": null,
          "value": "ALL_COMMANDS.index('EOL')"
        },
        {
          "name": "PAD_VAL",
          "annotation": null,
          "description": null,
          "value": "-1"
        },
        {
          "name": "PAD_GRAPH",
          "annotation": null,
          "description": null,
          "value": "HeteroData()"
        },
        {
          "name": "PAD_TENSOR",
          "annotation": null,
          "description": null,
          "value": "torch.zeros(7, dtype=(torch.float32))"
        },
        {
          "name": "UNUSED_PARAM",
          "annotation": null,
          "description": null,
          "value": "257"
        },
        {
          "name": "N_COMMANDS",
          "annotation": null,
          "description": null,
          "value": "len(ALL_COMMANDS)"
        },
        {
          "name": "N_ARGS",
          "annotation": null,
          "description": null,
          "value": "15"
        },
        {
          "name": "QUANTIZATION_SCALE",
          "annotation": null,
          "description": null,
          "value": "256"
        },
        {
          "name": "N_BIT",
          "annotation": null,
          "description": null,
          "value": "8"
        },
        {
          "name": "COMMAND_MASK",
          "annotation": null,
          "description": null,
          "value": "{LINE_IDX: [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ARC_IDX: [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], CIRCLE_IDX: [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], SKETCH_IDX: [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0], EXT_IDX: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], EOL_IDX: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], SOL_IDX: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], EOS_IDX: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}"
        },
        {
          "name": "COMMAND_PARAMETER_COUNTS",
          "annotation": null,
          "description": null,
          "value": "{LINE_IDX + QUANTIZATION_SCALE + 1: 2, ARC_IDX + QUANTIZATION_SCALE + 1: 4, CIRCLE_IDX + QUANTIZATION_SCALE + 1: 3, EOS_IDX + QUANTIZATION_SCALE + 1: 0, SOL_IDX + QUANTIZATION_SCALE + 1: 0, EXT_IDX + QUANTIZATION_SCALE + 1: 1, SKETCH_IDX + QUANTIZATION_SCALE + 1: 6, EOL_IDX + QUANTIZATION_SCALE + 1: 0}"
        },
        {
          "name": "EXTRUDE_OPERATIONS",
          "annotation": null,
          "description": null,
          "value": "['NewBodyFeatureOperation', 'JoinFeatureOperation', 'CutFeatureOperation', 'IntersectFeatureOperation']"
        },
        {
          "name": "EXTENT_TYPE",
          "annotation": null,
          "description": null,
          "value": "['OneSideFeatureExtentType', 'SymmetricFeatureExtentType', 'TwoSidesFeatureExtentType']"
        },
        {
          "name": "NODE_TYPES",
          "annotation": null,
          "description": null,
          "value": "['primitive']"
        },
        {
          "name": "CONSTRAINT_TYPES",
          "annotation": null,
          "description": null,
          "value": "['horizontal', 'vertical', 'endtostartcoincidence', 'perpendicular', 'parallel']"
        },
        {
          "name": "CONSTRAINTS",
          "annotation": null,
          "description": null,
          "value": "[('primitive', 'horizontal', 'primitive'), ('primitive', 'vertical', 'primitive'), ('primitive', 'endtostartcoincidence', 'primitive'), ('primitive', 'perpendicular', 'primitive'), ('primitive', 'parallel', 'primitive')]"
        },
        {
          "name": "PRECISION",
          "annotation": null,
          "description": null,
          "value": "1e-05"
        },
        {
          "name": "NORM_FACTOR",
          "annotation": null,
          "description": null,
          "value": "0.75"
        },
        {
          "name": "MAX_N_EXT",
          "annotation": null,
          "description": null,
          "value": "10"
        },
        {
          "name": "MAX_N_LOOPS",
          "annotation": null,
          "description": null,
          "value": "6"
        },
        {
          "name": "MAX_N_CURVES",
          "annotation": null,
          "description": null,
          "value": "15"
        },
        {
          "name": "MAX_TOTAL_LEN",
          "annotation": null,
          "description": null,
          "value": "70"
        },
        {
          "name": "MAX_NODES",
          "annotation": null,
          "description": null,
          "value": "200"
        },
        {
          "name": "MAX_EDGES",
          "annotation": null,
          "description": null,
          "value": "800"
        },
        {
          "name": "ARGS_DIM",
          "annotation": null,
          "description": null,
          "value": "256"
        }
      ],
      "modules": {},
      "classes": {},
      "functions": {}
    },
    "extrude": {
      "name": "extrude",
      "path": "rapidcadpy.extrude",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/extrude.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "Extrude": {
          "name": "Extrude",
          "path": "rapidcadpy.extrude.Extrude",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "extent_one",
              "annotation": "float",
              "description": null,
              "value": null
            },
            {
              "name": "extent_two",
              "annotation": "Optional[float]",
              "description": null,
              "value": "0.0"
            },
            {
              "name": "extent_type",
              "annotation": "str",
              "description": null,
              "value": "'OneSideFeatureExtentType'"
            },
            {
              "name": "operation",
              "annotation": "str",
              "description": null,
              "value": "'NewBodyFeatureOperation'"
            },
            {
              "name": "direction",
              "annotation": "int",
              "description": null,
              "value": "1"
            },
            {
              "name": "symmetric",
              "annotation": "Optional[bool]",
              "description": null,
              "value": "False"
            },
            {
              "name": "taper_angle_one",
              "annotation": "Optional[float]",
              "description": null,
              "value": "0.0"
            },
            {
              "name": "taper_angle_two",
              "annotation": "Optional[float]",
              "description": null,
              "value": "0.0"
            },
            {
              "name": "name",
              "annotation": "Optional[str]",
              "description": null,
              "value": "None"
            }
          ],
          "attributes": [
            {
              "name": "extent_one",
              "annotation": "float",
              "description": null,
              "value": null
            },
            {
              "name": "extent_two",
              "annotation": "Optional[float]",
              "description": null,
              "value": "0.0"
            },
            {
              "name": "extent_type",
              "annotation": "str",
              "description": null,
              "value": "'OneSideFeatureExtentType'"
            },
            {
              "name": "operation",
              "annotation": "str",
              "description": null,
              "value": "'NewBodyFeatureOperation'"
            },
            {
              "name": "direction",
              "annotation": "int",
              "description": null,
              "value": "1"
            },
            {
              "name": "symmetric",
              "annotation": "Optional[bool]",
              "description": null,
              "value": "False"
            },
            {
              "name": "taper_angle_one",
              "annotation": "Optional[float]",
              "description": null,
              "value": "0.0"
            },
            {
              "name": "taper_angle_two",
              "annotation": "Optional[float]",
              "description": null,
              "value": "0.0"
            },
            {
              "name": "name",
              "annotation": "Optional[str]",
              "description": null,
              "value": "None"
            }
          ],
          "docstring": [],
          "functions": {
            "__post_init__": {
              "name": "__post_init__",
              "path": "rapidcadpy.extrude.Extrude.__post_init__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __post_init__(self):\n    self.extent_one = round(self.extent_one, 6)"
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.extrude.Extrude.to_json",
              "signature": "(self) -> Dict[str, Any]",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Dict[str, typing.Any]",
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self) -> Dict[str, Any]:\n    return {\n        \"extent_one\": self.extent_one,\n        \"extent_two\": self.extent_two,\n        \"symmetric\": self.symmetric,\n        \"taper_angle_one\": self.taper_angle_one,\n        \"taper_angle_two\": self.taper_angle_two,\n        \"extent_type\": self.extent_type,\n        \"operation\": self.operation,\n    }"
            },
            "to_tensor": {
              "name": "to_tensor",
              "path": "rapidcadpy.extrude.Extrude.to_tensor",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_tensor(self):\n    # Define constants locally since we can't import from models\n    EXTENT_TYPE = [\n        \"OneSideFeatureExtentType\",\n        \"TwoSidesFeatureExtentType\",\n        \"SymmetricFeatureExtentType\",\n    ]\n    EXTRUDE_OPERATIONS = [\n        \"NewBodyFeatureOperation\",\n        \"JoinFeatureOperation\",\n        \"CutFeatureOperation\",\n        \"IntersectFeatureOperation\",\n    ]\n\n    return torch.tensor(\n        [\n            float(self.extent_one),\n            float(self.extent_two),\n            float(self.symmetric),\n            float(self.taper_angle_one),\n            float(self.taper_angle_two),\n            EXTENT_TYPE.index(self.extent_type),\n            EXTRUDE_OPERATIONS.index(self.operation),\n        ],\n        dtype=torch.float,\n    )"
            },
            "from_tensor": {
              "name": "from_tensor",
              "path": "rapidcadpy.extrude.Extrude.from_tensor",
              "signature": "(cls, tensor) -> Extrude",
              "description": null,
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "tensor",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "rapidcadpy.extrude.Extrude",
                "description": null
              },
              "docstring": [],
              "source": "@classmethod\ndef from_tensor(cls, tensor) -> \"Extrude\":\n    # Define constants locally since we can't import from models\n    EXTENT_TYPE = [\n        \"OneSideFeatureExtentType\",\n        \"TwoSidesFeatureExtentType\",\n        \"SymmetricFeatureExtentType\",\n    ]\n    EXTRUDE_OPERATIONS = [\n        \"NewBodyFeatureOperation\",\n        \"JoinFeatureOperation\",\n        \"CutFeatureOperation\",\n        \"IntersectFeatureOperation\",\n    ]\n\n    return cls(\n        extent_one=float(tensor[0]),\n        extent_two=float(tensor[1]),\n        symmetric=bool(tensor[2]),\n        taper_angle_one=float(tensor[3]),\n        taper_angle_two=float(tensor[4]),\n        extent_type=EXTENT_TYPE[int(tensor[5])],\n        operation=EXTRUDE_OPERATIONS[int(tensor[6])],\n    )"
            },
            "from_json": {
              "name": "from_json",
              "path": "rapidcadpy.extrude.Extrude.from_json",
              "signature": "(json)",
              "description": null,
              "parameters": [
                {
                  "name": "json",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_json(json):\n    return Extrude(\n        extent_one=json[\"extent_one\"],\n        extent_two=json[\"extent_two\"],\n        symmetric=json[\"symmetric\"],\n        taper_angle_one=json[\"taper_angle_one\"],\n        taper_angle_two=json[\"taper_angle_two\"],\n        extent_type=json[\"extent_type\"],\n        operation=json[\"operation\"],\n    )"
            },
            "to_python": {
              "name": "to_python",
              "path": "rapidcadpy.extrude.Extrude.to_python",
              "signature": "(self, index=0)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "index",
                  "annotation": "Optional[int]",
                  "description": null,
                  "value": "0"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_python(self, index: Optional[int] = 0):\n    return f\"Extrude(extent_one={self.extent_one}, extent_two={self.extent_two}, symmetric={self.symmetric}, taper_angle_one={self.taper_angle_one}, taper_angle_two={self.taper_angle_two})\""
            },
            "__eq__": {
              "name": "__eq__",
              "path": "rapidcadpy.extrude.Extrude.__eq__",
              "signature": "(self, other)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "other",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __eq__(self, other):\n    return (\n        self.extent_one == other.extent_one\n        and self.extent_two == other.extent_two\n        and self.symmetric == other.symmetric\n        and self.taper_angle_one == other.taper_angle_one\n        and self.taper_angle_two == other.taper_angle_two\n    )"
            },
            "transform": {
              "name": "transform",
              "path": "rapidcadpy.extrude.Extrude.transform",
              "signature": "(self, scale)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "scale",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def transform(self, scale):\n    self.extent_one *= scale\n    self.extent_two *= scale\n    return self"
            },
            "numericalize": {
              "name": "numericalize",
              "path": "rapidcadpy.extrude.Extrude.numericalize",
              "signature": "(self, n=256)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": "256"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def numericalize(self, n=256):\n    n -= 1\n    self.extent_one = round(self.extent_one * n)\n    self.extent_two = round(self.extent_two * n)\n    self.taper_angle_one = round(self.taper_angle_one * n)\n    self.taper_angle_two = round(self.taper_angle_two * n)\n    return self"
            },
            "denumericalize": {
              "name": "denumericalize",
              "path": "rapidcadpy.extrude.Extrude.denumericalize",
              "signature": "(self, n)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def denumericalize(self, n):\n    self.extent_one = self.extent_one / n\n    self.extent_two = self.extent_two / n\n    self.taper_angle_one = self.taper_angle_one / n\n    self.taper_angle_two = self.taper_angle_two / n\n    return self"
            },
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.extrude.Extrude.__init__",
              "signature": "(self, extent_one, extent_two=0.0, extent_type='OneSideFeatureExtentType', operation='NewBodyFeatureOperation', direction=1, symmetric=False, taper_angle_one=0.0, taper_angle_two=0.0, name=None) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "extent_one",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "extent_two",
                  "annotation": "Optional[float]",
                  "description": null,
                  "value": "0.0"
                },
                {
                  "name": "extent_type",
                  "annotation": "str",
                  "description": null,
                  "value": "'OneSideFeatureExtentType'"
                },
                {
                  "name": "operation",
                  "annotation": "str",
                  "description": null,
                  "value": "'NewBodyFeatureOperation'"
                },
                {
                  "name": "direction",
                  "annotation": "int",
                  "description": null,
                  "value": "1"
                },
                {
                  "name": "symmetric",
                  "annotation": "Optional[bool]",
                  "description": null,
                  "value": "False"
                },
                {
                  "name": "taper_angle_one",
                  "annotation": "Optional[float]",
                  "description": null,
                  "value": "0.0"
                },
                {
                  "name": "taper_angle_two",
                  "annotation": "Optional[float]",
                  "description": null,
                  "value": "0.0"
                },
                {
                  "name": "name",
                  "annotation": "Optional[str]",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass\nclass Extrude:\n    extent_one: float\n    extent_two: Optional[float] = 0.0\n    extent_type: str = \"OneSideFeatureExtentType\"\n    operation: str = \"NewBodyFeatureOperation\"\n    direction: int = 1\n    symmetric: Optional[bool] = False\n    taper_angle_one: Optional[float] = 0.0\n    taper_angle_two: Optional[float] = 0.0\n    name: Optional[str] = None\n\n    def __post_init__(self):\n        self.extent_one = round(self.extent_one, 6)\n\n    def to_json(self) -> Dict[str, Any]:\n        return {\n            \"extent_one\": self.extent_one,\n            \"extent_two\": self.extent_two,\n            \"symmetric\": self.symmetric,\n            \"taper_angle_one\": self.taper_angle_one,\n            \"taper_angle_two\": self.taper_angle_two,\n            \"extent_type\": self.extent_type,\n            \"operation\": self.operation,\n        }\n\n    def to_tensor(self):\n        # Define constants locally since we can't import from models\n        EXTENT_TYPE = [\n            \"OneSideFeatureExtentType\",\n            \"TwoSidesFeatureExtentType\",\n            \"SymmetricFeatureExtentType\",\n        ]\n        EXTRUDE_OPERATIONS = [\n            \"NewBodyFeatureOperation\",\n            \"JoinFeatureOperation\",\n            \"CutFeatureOperation\",\n            \"IntersectFeatureOperation\",\n        ]\n\n        return torch.tensor(\n            [\n                float(self.extent_one),\n                float(self.extent_two),\n                float(self.symmetric),\n                float(self.taper_angle_one),\n                float(self.taper_angle_two),\n                EXTENT_TYPE.index(self.extent_type),\n                EXTRUDE_OPERATIONS.index(self.operation),\n            ],\n            dtype=torch.float,\n        )\n\n    @classmethod\n    def from_tensor(cls, tensor) -> \"Extrude\":\n        # Define constants locally since we can't import from models\n        EXTENT_TYPE = [\n            \"OneSideFeatureExtentType\",\n            \"TwoSidesFeatureExtentType\",\n            \"SymmetricFeatureExtentType\",\n        ]\n        EXTRUDE_OPERATIONS = [\n            \"NewBodyFeatureOperation\",\n            \"JoinFeatureOperation\",\n            \"CutFeatureOperation\",\n            \"IntersectFeatureOperation\",\n        ]\n\n        return cls(\n            extent_one=float(tensor[0]),\n            extent_two=float(tensor[1]),\n            symmetric=bool(tensor[2]),\n            taper_angle_one=float(tensor[3]),\n            taper_angle_two=float(tensor[4]),\n            extent_type=EXTENT_TYPE[int(tensor[5])],\n            operation=EXTRUDE_OPERATIONS[int(tensor[6])],\n        )\n\n    @staticmethod\n    def from_json(json):\n        return Extrude(\n            extent_one=json[\"extent_one\"],\n            extent_two=json[\"extent_two\"],\n            symmetric=json[\"symmetric\"],\n            taper_angle_one=json[\"taper_angle_one\"],\n            taper_angle_two=json[\"taper_angle_two\"],\n            extent_type=json[\"extent_type\"],\n            operation=json[\"operation\"],\n        )\n\n    def to_python(self, index: Optional[int] = 0):\n        return f\"Extrude(extent_one={self.extent_one}, extent_two={self.extent_two}, symmetric={self.symmetric}, taper_angle_one={self.taper_angle_one}, taper_angle_two={self.taper_angle_two})\"\n\n    def __eq__(self, other):\n        return (\n            self.extent_one == other.extent_one\n            and self.extent_two == other.extent_two\n            and self.symmetric == other.symmetric\n            and self.taper_angle_one == other.taper_angle_one\n            and self.taper_angle_two == other.taper_angle_two\n        )\n\n    def transform(self, scale):\n        self.extent_one *= scale\n        self.extent_two *= scale\n        return self\n\n    def numericalize(self, n=256):\n        n -= 1\n        self.extent_one = round(self.extent_one * n)\n        self.extent_two = round(self.extent_two * n)\n        self.taper_angle_one = round(self.taper_angle_one * n)\n        self.taper_angle_two = round(self.taper_angle_two * n)\n        return self\n\n    def denumericalize(self, n):\n        self.extent_one = self.extent_one / n\n        self.extent_two = self.extent_two / n\n        self.taper_angle_one = self.taper_angle_one / n\n        self.taper_angle_two = self.taper_angle_two / n\n        return self",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "feature": {
      "name": "feature",
      "path": "rapidcadpy.feature",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/feature.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "Feature": {
          "name": "Feature",
          "path": "rapidcadpy.feature.Feature",
          "description": "Abstract base class for all CAD features.\n\nFeatures represent operations that can be applied to create or modify 3D geometry.\nEach feature is localized on a specific plane.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "sketch_plane",
              "annotation": "Plane",
              "description": null,
              "value": "Plane()"
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "uuid.uuid4()"
            },
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": "'Feature'"
            }
          ],
          "attributes": [
            {
              "name": "sketch_plane",
              "annotation": "Plane",
              "description": null,
              "value": "field(default_factory=Plane)"
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "field(default_factory=(uuid.uuid4))"
            },
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": "'Feature'"
            }
          ],
          "docstring": [],
          "functions": {
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.feature.Feature.to_json",
              "signature": "(self) -> Dict[str, Any]",
              "description": "Convert the feature to JSON representation.\n\nReturns:\n    Dict[str, Any]: JSON representation of the feature",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Dict[str, typing.Any]",
                "description": null
              },
              "docstring": [],
              "source": "@abstractmethod\ndef to_json(self) -> Dict[str, Any]:\n    \"\"\"\n    Convert the feature to JSON representation.\n\n    Returns:\n        Dict[str, Any]: JSON representation of the feature\n    \"\"\"\n    pass"
            },
            "to_python": {
              "name": "to_python",
              "path": "rapidcadpy.feature.Feature.to_python",
              "signature": "(self, index=0) -> str",
              "description": "Generate Python code to recreate this feature.\n\nArgs:\n    index: Index for variable naming\n\nReturns:\n    str: Python code string",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "index",
                  "annotation": "int",
                  "description": null,
                  "value": "0"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "@abstractmethod\ndef to_python(self, index: int = 0) -> str:\n    \"\"\"\n    Generate Python code to recreate this feature.\n\n    Args:\n        index: Index for variable naming\n\n    Returns:\n        str: Python code string\n    \"\"\"\n    pass"
            },
            "__post_init__": {
              "name": "__post_init__",
              "path": "rapidcadpy.feature.Feature.__post_init__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __post_init__(self):\n    if self.id is None:\n        self.id = uuid.uuid4()"
            },
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.feature.Feature.__init__",
              "signature": "(self, sketch_plane=Plane(), id=uuid.uuid4(), name='Feature') -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "sketch_plane",
                  "annotation": "Plane",
                  "description": null,
                  "value": "Plane()"
                },
                {
                  "name": "id",
                  "annotation": "Optional[uuid.UUID]",
                  "description": null,
                  "value": "uuid.uuid4()"
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "'Feature'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass\nclass Feature(ABC):\n    \"\"\"\n    Abstract base class for all CAD features.\n\n    Features represent operations that can be applied to create or modify 3D geometry.\n    Each feature is localized on a specific plane.\n    \"\"\"\n\n    sketch_plane: Plane = field(default_factory=Plane)\n    id: Optional[uuid.UUID] = field(default_factory=uuid.uuid4)\n    name: str = \"Feature\"\n\n    @abstractmethod\n    def to_json(self) -> Dict[str, Any]:\n        \"\"\"\n        Convert the feature to JSON representation.\n\n        Returns:\n            Dict[str, Any]: JSON representation of the feature\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def to_python(self, index: int = 0) -> str:\n        \"\"\"\n        Generate Python code to recreate this feature.\n\n        Args:\n            index: Index for variable naming\n\n        Returns:\n            str: Python code string\n        \"\"\"\n        pass\n\n    def __post_init__(self):\n        if self.id is None:\n            self.id = uuid.uuid4()",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "wire": {
      "name": "wire",
      "path": "rapidcadpy.wire",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/wire.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "Wire": {
          "name": "Wire",
          "path": "rapidcadpy.wire.Wire",
          "description": "A wire is a sequence of connected primitives that form a closed loop.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "edges",
              "annotation": "List[Union[Line, Circle, Arc]]",
              "description": null,
              "value": null
            },
            {
              "name": "constraints",
              "annotation": "Optional[list]",
              "description": null,
              "value": "None"
            }
          ],
          "attributes": [
            {
              "name": "edges",
              "annotation": "List[Union[Line, Circle, Arc]]",
              "description": null,
              "value": null
            },
            {
              "name": "constraints",
              "annotation": "Optional[list]",
              "description": null,
              "value": "None"
            }
          ],
          "docstring": [],
          "functions": {
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.wire.Wire.to_json",
              "signature": "(self) -> Dict[str, Any]",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Dict[str, typing.Any]",
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self) -> Dict[str, Any]:\n    return {\n        \"edges\": [e.to_json() for e in self.edges],\n    }"
            },
            "to_python": {
              "name": "to_python",
              "path": "rapidcadpy.wire.Wire.to_python",
              "signature": "(self, index=0) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "index",
                  "annotation": "Optional[int]",
                  "description": null,
                  "value": "0"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def to_python(self, index: Optional[int] = 0) -> str:\n    return f\"Wire([{', '.join(e.name for e in self.edges)}])\""
            },
            "bounding_box_area": {
              "name": "bounding_box_area",
              "path": "rapidcadpy.wire.Wire.bounding_box_area",
              "signature": "(self) -> float",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "float",
                "description": null
              },
              "docstring": [],
              "source": "def bounding_box_area(self) -> float:\n    all_points = np.concatenate([edge.bbox for edge in self.edges], axis=0)\n    bbox = np.stack(\n        [np.min(all_points, axis=0), np.max(all_points, axis=0)], axis=0\n    )\n\n    bbox_min, bbox_max = bbox[0], bbox[1]\n\n    return np.prod(bbox_max - bbox_min)"
            },
            "plot": {
              "name": "plot",
              "path": "rapidcadpy.wire.Wire.plot",
              "signature": "(self) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def plot(self) -> None:\n    visualize_lines(self.edges, inner_edges=[], ax=None)\n    plt.show()"
            },
            "to_occ": {
              "name": "to_occ",
              "path": "rapidcadpy.wire.Wire.to_occ",
              "signature": "(self) -> Any",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Any",
                "description": null
              },
              "docstring": [],
              "source": "def to_occ(self) -> Any:\n    from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeWire\n\n    wire_builder = BRepBuilderAPI_MakeWire()\n    for edge in self.edges:\n        occ_edge = edge.to_occ()\n        wire_builder.Add(occ_edge)\n    return wire_builder.Wire()"
            },
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.wire.Wire.__init__",
              "signature": "(self, edges, constraints=None) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "edges",
                  "annotation": "List[Union[Line, Circle, Arc]]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "constraints",
                  "annotation": "Optional[list]",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass\nclass Wire:\n    \"\"\"A wire is a sequence of connected primitives that form a closed loop.\"\"\"\n\n    edges: List[Union[Line, Circle, Arc]]\n    constraints: Optional[list] = None\n\n    def to_json(self) -> Dict[str, Any]:\n        return {\n            \"edges\": [e.to_json() for e in self.edges],\n        }\n\n    def to_python(self, index: Optional[int] = 0) -> str:\n        return f\"Wire([{', '.join(e.name for e in self.edges)}])\"\n\n    def bounding_box_area(self) -> float:\n        all_points = np.concatenate([edge.bbox for edge in self.edges], axis=0)\n        bbox = np.stack(\n            [np.min(all_points, axis=0), np.max(all_points, axis=0)], axis=0\n        )\n\n        bbox_min, bbox_max = bbox[0], bbox[1]\n\n        return np.prod(bbox_max - bbox_min)\n\n    def plot(self) -> None:\n        visualize_lines(self.edges, inner_edges=[], ax=None)\n        plt.show()\n\n    def to_occ(self) -> Any:\n        from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeWire\n\n        wire_builder = BRepBuilderAPI_MakeWire()\n        for edge in self.edges:\n            occ_edge = edge.to_occ()\n            wire_builder.Add(occ_edge)\n        return wire_builder.Wire()",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "primitive": {
      "name": "primitive",
      "path": "rapidcadpy.primitive",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/primitive.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "ENTITY_TYPE_TO_CLASS",
          "annotation": null,
          "description": null,
          "value": "{EntityType.Line: Line, EntityType.Circle: Circle, EntityType.Arc: Arc}"
        }
      ],
      "modules": {},
      "classes": {
        "Primitive": {
          "name": "Primitive",
          "path": "rapidcadpy.primitive.Primitive",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "None"
            },
            {
              "name": "name",
              "annotation": "Optional[str]",
              "description": null,
              "value": "None"
            }
          ],
          "attributes": [
            {
              "name": "id",
              "annotation": null,
              "description": null,
              "value": "id if id else uuid.uuid4()"
            },
            {
              "name": "name",
              "annotation": null,
              "description": null,
              "value": "name if name else self.__class__.__name__"
            }
          ],
          "docstring": [],
          "functions": {
            "from_dict": {
              "name": "from_dict",
              "path": "rapidcadpy.primitive.Primitive.from_dict",
              "signature": "(ent_dict)",
              "description": "Creates an entity from its json representation as a dictionary.\n\nParameters\n----------\nent_dict : dict\n    The dictionary containing the json data representing the entity.\n\nReturns\n-------\nPrimitive\n    An entity of the appropriate type according to the dictionar data.",
              "parameters": [
                {
                  "name": "ent_dict",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_dict(ent_dict):\n    \"\"\"Creates an entity from its json representation as a dictionary.\n\n    Parameters\n    ----------\n    ent_dict : dict\n        The dictionary containing the json data representing the entity.\n\n    Returns\n    -------\n    Primitive\n        An entity of the appropriate type according to the dictionar data.\n    \"\"\"\n    entity_type = inspect_entity_type(ent_dict)\n\n    EntityClass = ENTITY_TYPE_TO_CLASS.get(entity_type)\n    return EntityClass.from_fs_dict(ent_dict)"
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.primitive.Primitive.to_json",
              "signature": "()",
              "description": null,
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef to_json():\n    raise NotImplementedError"
            },
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.primitive.Primitive.__init__",
              "signature": "(self, id=None, name=None)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "id",
                  "annotation": "Optional[uuid.UUID]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "name",
                  "annotation": "Optional[str]",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, id: Optional[uuid.UUID] = None, name: Optional[str] = None):\n    self.id = id if id else uuid.uuid4()\n    self.name = name if name else self.__class__.__name__"
            }
          },
          "source": "class Primitive(ABC):\n    @staticmethod\n    def from_dict(ent_dict):\n        \"\"\"Creates an entity from its json representation as a dictionary.\n\n        Parameters\n        ----------\n        ent_dict : dict\n            The dictionary containing the json data representing the entity.\n\n        Returns\n        -------\n        Primitive\n            An entity of the appropriate type according to the dictionar data.\n        \"\"\"\n        entity_type = inspect_entity_type(ent_dict)\n\n        EntityClass = ENTITY_TYPE_TO_CLASS.get(entity_type)\n        return EntityClass.from_fs_dict(ent_dict)\n\n    @staticmethod\n    def to_json():\n        raise NotImplementedError\n\n    def __init__(self, id: Optional[uuid.UUID] = None, name: Optional[str] = None):\n        self.id = id if id else uuid.uuid4()\n        self.name = name if name else self.__class__.__name__",
          "inherited_members": {}
        },
        "Arc": {
          "name": "Arc",
          "path": "rapidcadpy.primitive.Arc",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "start_point",
              "annotation": "Vertex",
              "description": null,
              "value": null
            },
            {
              "name": "mid_point",
              "annotation": "Vertex",
              "description": null,
              "value": null
            },
            {
              "name": "end_point",
              "annotation": "Vertex",
              "description": null,
              "value": null
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "None"
            },
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": "'arc'"
            }
          ],
          "attributes": [
            {
              "name": "start_point",
              "annotation": null,
              "description": null,
              "value": "start_point"
            },
            {
              "name": "mid_point",
              "annotation": null,
              "description": null,
              "value": "mid_point"
            },
            {
              "name": "end_point",
              "annotation": null,
              "description": null,
              "value": "end_point"
            },
            {
              "name": "bbox",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.primitive.Arc.__init__",
              "signature": "(self, start_point, mid_point, end_point, id=None, name='arc')",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "start_point",
                  "annotation": "Vertex",
                  "description": null,
                  "value": null
                },
                {
                  "name": "mid_point",
                  "annotation": "Vertex",
                  "description": null,
                  "value": null
                },
                {
                  "name": "end_point",
                  "annotation": "Vertex",
                  "description": null,
                  "value": null
                },
                {
                  "name": "id",
                  "annotation": "Optional[uuid.UUID]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "'arc'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(\n    self,\n    start_point: Vertex,\n    mid_point: Vertex,\n    end_point: Vertex,\n    id: Optional[uuid.UUID] = None,\n    name: str = \"arc\",\n):\n    super().__init__(id, name)\n    self.start_point = start_point\n    self.mid_point = mid_point\n    self.end_point = end_point\n    self._is_numerical = False"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "rapidcadpy.primitive.Arc.__repr__",
              "signature": "(self) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self) -> str:\n    return (\n        f\"Arc(start={self.start_point}, mid={self.mid_point}, end={self.end_point})\"\n    )"
            },
            "__eq__": {
              "name": "__eq__",
              "path": "rapidcadpy.primitive.Arc.__eq__",
              "signature": "(self, other) -> bool",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "other",
                  "annotation": "Any",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bool",
                "description": null
              },
              "docstring": [],
              "source": "def __eq__(self, other: Any) -> bool:\n    return (\n        isinstance(other, Arc)\n        and np.allclose(self.start_point, other.start_point)\n        and np.allclose(self.mid_point, other.mid_point)\n        and np.allclose(self.end_point, other.end_point)\n    )"
            },
            "__hash__": {
              "name": "__hash__",
              "path": "rapidcadpy.primitive.Arc.__hash__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __hash__(self):\n    return hash(\n        (hash(self.start_point), hash(self.mid_point), hash(self.end_point))\n    )"
            },
            "to_python": {
              "name": "to_python",
              "path": "rapidcadpy.primitive.Arc.to_python",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_python(self):\n    return f\"Arc(start_point={self.start_point.to_python()}, mid_point={self.mid_point.to_python()}, end_point={self.end_point.to_python()})\""
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.primitive.Arc.to_json",
              "signature": "(self, dereferenced=True)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "dereferenced",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self, dereferenced=True):\n    return {\n        \"type\": \"Arc\",\n        \"id\": str(self.id),\n        \"start_point\": self.start_point.to_json(),\n        \"mid_point\": self.mid_point.to_json(),\n        \"end_point\": self.end_point.to_json(),\n    }"
            },
            "transform": {
              "name": "transform",
              "path": "rapidcadpy.primitive.Arc.transform",
              "signature": "(self, translate, scale)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "translate",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "scale",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def transform(self, translate, scale):\n    self.start_point = (self.start_point + translate) * scale\n    self.mid_point = (self.mid_point + translate) * scale\n    self.end_point = (self.end_point + translate) * scale"
            },
            "to_vector": {
              "name": "to_vector",
              "path": "rapidcadpy.primitive.Arc.to_vector",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_vector(self):\n    vector = np.array(\n        [\n            ARC_IDX,\n            self.end_point[0],\n            self.end_point[1],\n            self.mid_point[0],\n            self.mid_point[1],\n        ]\n    )\n    return np.pad(\n        vector,\n        (0, N_ARGS - len(vector) + 1),\n        \"constant\",\n        constant_values=UNUSED_PARAM,\n    )"
            },
            "from_vector": {
              "name": "from_vector",
              "path": "rapidcadpy.primitive.Arc.from_vector",
              "signature": "(vec, start_point=None, is_numerical=False)",
              "description": null,
              "parameters": [
                {
                  "name": "vec",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "start_point",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "is_numerical",
                  "annotation": null,
                  "description": null,
                  "value": "False"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_vector(vec, start_point=None, is_numerical=False):\n    mid_point = np.array([vec[2], vec[3]])\n    end_point = np.array([vec[0], vec[1]])\n    if is_numerical:\n        mid_point = mid_point / QUANTIZATION_SCALE\n        end_point = end_point / QUANTIZATION_SCALE\n    return Arc(\n        start_point=Vertex(*start_point),\n        mid_point=Vertex(*mid_point),\n        end_point=Vertex(*end_point),\n    )"
            },
            "numericalize": {
              "name": "numericalize",
              "path": "rapidcadpy.primitive.Arc.numericalize",
              "signature": "(self, n=256)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": "256"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def numericalize(self, n=256):\n    self.start_point = (\n        (self.start_point * n).round().clip(min=0, max=n - 1).astype(int)\n    )\n    self.mid_point = (self.mid_point * n).round().clip(min=0, max=n - 1).astype(int)\n    self.end_point = (self.end_point * n).round().clip(min=0, max=n - 1).astype(int)\n    self._is_numerical = True"
            },
            "denumericalize": {
              "name": "denumericalize",
              "path": "rapidcadpy.primitive.Arc.denumericalize",
              "signature": "(self, n=256)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": "256"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def denumericalize(self, n=256):\n    self.start_point = self.start_point / n\n    self.mid_point = self.mid_point / n\n    self.end_point = self.end_point / n"
            }
          },
          "source": "class Arc(Primitive):\n    def __init__(\n        self,\n        start_point: Vertex,\n        mid_point: Vertex,\n        end_point: Vertex,\n        id: Optional[uuid.UUID] = None,\n        name: str = \"arc\",\n    ):\n        super().__init__(id, name)\n        self.start_point = start_point\n        self.mid_point = mid_point\n        self.end_point = end_point\n        self._is_numerical = False\n\n    def __repr__(self) -> str:\n        return (\n            f\"Arc(start={self.start_point}, mid={self.mid_point}, end={self.end_point})\"\n        )\n\n    def __eq__(self, other: Any) -> bool:\n        return (\n            isinstance(other, Arc)\n            and np.allclose(self.start_point, other.start_point)\n            and np.allclose(self.mid_point, other.mid_point)\n            and np.allclose(self.end_point, other.end_point)\n        )\n\n    def __hash__(self):\n        return hash(\n            (hash(self.start_point), hash(self.mid_point), hash(self.end_point))\n        )\n\n    def to_python(self):\n        return f\"Arc(start_point={self.start_point.to_python()}, mid_point={self.mid_point.to_python()}, end_point={self.end_point.to_python()})\"\n\n    def to_json(self, dereferenced=True):\n        return {\n            \"type\": \"Arc\",\n            \"id\": str(self.id),\n            \"start_point\": self.start_point.to_json(),\n            \"mid_point\": self.mid_point.to_json(),\n            \"end_point\": self.end_point.to_json(),\n        }\n\n    @property\n    def bbox(self):\n        points = np.array(\n            [\n                self.start_point,\n                self.mid_point,\n                self.end_point,\n            ]\n        )\n        return np.stack([np.min(points, axis=0), np.max(points, axis=0)], axis=0)\n\n    def transform(self, translate, scale):\n        self.start_point = (self.start_point + translate) * scale\n        self.mid_point = (self.mid_point + translate) * scale\n        self.end_point = (self.end_point + translate) * scale\n\n    def to_vector(self):\n        vector = np.array(\n            [\n                ARC_IDX,\n                self.end_point[0],\n                self.end_point[1],\n                self.mid_point[0],\n                self.mid_point[1],\n            ]\n        )\n        return np.pad(\n            vector,\n            (0, N_ARGS - len(vector) + 1),\n            \"constant\",\n            constant_values=UNUSED_PARAM,\n        )\n\n    @staticmethod\n    def from_vector(vec, start_point=None, is_numerical=False):\n        mid_point = np.array([vec[2], vec[3]])\n        end_point = np.array([vec[0], vec[1]])\n        if is_numerical:\n            mid_point = mid_point / QUANTIZATION_SCALE\n            end_point = end_point / QUANTIZATION_SCALE\n        return Arc(\n            start_point=Vertex(*start_point),\n            mid_point=Vertex(*mid_point),\n            end_point=Vertex(*end_point),\n        )\n\n    def numericalize(self, n=256):\n        self.start_point = (\n            (self.start_point * n).round().clip(min=0, max=n - 1).astype(int)\n        )\n        self.mid_point = (self.mid_point * n).round().clip(min=0, max=n - 1).astype(int)\n        self.end_point = (self.end_point * n).round().clip(min=0, max=n - 1).astype(int)\n        self._is_numerical = True\n\n    def denumericalize(self, n=256):\n        self.start_point = self.start_point / n\n        self.mid_point = self.mid_point / n\n        self.end_point = self.end_point / n",
          "inherited_members": {
            "rapidcadpy.primitive.Primitive": [
              {
                "kind": "function",
                "path": "rapidcadpy.primitive.Primitive.from_dict"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.primitive.Primitive.id"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.primitive.Primitive.name"
              }
            ]
          }
        },
        "Circle": {
          "name": "Circle",
          "path": "rapidcadpy.primitive.Circle",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "center",
              "annotation": "Union[Iterable, Vertex]",
              "description": null,
              "value": null
            },
            {
              "name": "radius",
              "annotation": "float",
              "description": null,
              "value": null
            },
            {
              "name": "normal",
              "annotation": null,
              "description": null,
              "value": "None"
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "None"
            },
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": "'circle'"
            }
          ],
          "attributes": [
            {
              "name": "center",
              "annotation": null,
              "description": null,
              "value": "center"
            },
            {
              "name": "radius",
              "annotation": "float",
              "description": null,
              "value": "round(radius, 6)"
            },
            {
              "name": "normal",
              "annotation": "np.array",
              "description": null,
              "value": "normal"
            },
            {
              "name": "bbox",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "start_point",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "end_point",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.primitive.Circle.__init__",
              "signature": "(self, center, radius, normal=None, id=None, name='circle')",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "center",
                  "annotation": "Union[Iterable, Vertex]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "radius",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "normal",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "id",
                  "annotation": "Optional[uuid.UUID]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "'circle'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(\n    self,\n    center: Union[Iterable, Vertex],\n    radius: float,\n    normal=None,\n    id: Optional[uuid.UUID] = None,\n    name: str = \"circle\",\n):\n    super(Circle, self).__init__(id, name)\n    if not isinstance(center, Vertex):\n        center = Vertex(x=center[0], y=center[1])\n    self.center = center\n    self.radius: float = round(radius, 6)\n    self.normal: np.array = normal"
            },
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.primitive.Circle.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    return \"Circle: center({}), radius({})\".format(\n        self.center.round(4), round(self.radius, 4)\n    )"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "rapidcadpy.primitive.Circle.__repr__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self):\n    return f\"Circle(center={self.center}, radius={self.radius})\""
            },
            "from_dict": {
              "name": "from_dict",
              "path": "rapidcadpy.primitive.Circle.from_dict",
              "signature": "(stat)",
              "description": null,
              "parameters": [
                {
                  "name": "stat",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_dict(stat):\n    assert stat[\"type\"] == \"Circle3D\"\n    center = np.array([stat[\"center_point\"][\"x\"], stat[\"center_point\"][\"y\"]])\n    radius = stat[\"radius\"]\n    normal = np.array(\n        [stat[\"normal\"][\"x\"], stat[\"normal\"][\"y\"], stat[\"normal\"][\"z\"]]\n    )\n    return Circle(center, radius, normal)"
            },
            "from_fs_dict": {
              "name": "from_fs_dict",
              "path": "rapidcadpy.primitive.Circle.from_fs_dict",
              "signature": "(entity_dict)",
              "description": null,
              "parameters": [
                {
                  "name": "entity_dict",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_fs_dict(entity_dict):\n    center = [\n        entity_dict[\"geometry\"][\"message\"][\"xCenter\"],\n        entity_dict[\"geometry\"][\"message\"][\"yCenter\"],\n    ]\n    radius = entity_dict[\"geometry\"][\"message\"][\"radius\"]\n    return Circle(center, radius)"
            },
            "direction": {
              "name": "direction",
              "path": "rapidcadpy.primitive.Circle.direction",
              "signature": "(self, from_start=True)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "from_start",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def direction(self, from_start=True):\n    return self.center - self.start_point"
            },
            "physical_len": {
              "name": "physical_len",
              "path": "rapidcadpy.primitive.Circle.physical_len",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def physical_len(self):\n    return 2 * np.pi * self.radius"
            },
            "transform": {
              "name": "transform",
              "path": "rapidcadpy.primitive.Circle.transform",
              "signature": "(self, translate, scale)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "translate",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "scale",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def transform(self, translate, scale):\n    self.center = (self.center + translate) * scale\n    self.radius = self.radius * scale"
            },
            "flip": {
              "name": "flip",
              "path": "rapidcadpy.primitive.Circle.flip",
              "signature": "(self, axis)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "axis",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def flip(self, axis):\n    if axis == \"x\":\n        self.center[1] = -self.center[1]\n    elif axis == \"y\":\n        self.center[0] = -self.center[0]\n    elif axis == \"xy\":\n        self.center = self.center * -1\n    else:\n        raise ValueError(\"axis = {}\".format(axis))"
            },
            "reverse": {
              "name": "reverse",
              "path": "rapidcadpy.primitive.Circle.reverse",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def reverse(self):\n    pass"
            },
            "numericalize": {
              "name": "numericalize",
              "path": "rapidcadpy.primitive.Circle.numericalize",
              "signature": "(self, n=256)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": "256"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def numericalize(self, n=256):\n    self.center = (self.center * n).round().clip(min=0, max=n - 1).astype(int)\n    self.radius = max(1, min(int(round(self.radius * n)), n - 1))"
            },
            "denumericalize": {
              "name": "denumericalize",
              "path": "rapidcadpy.primitive.Circle.denumericalize",
              "signature": "(self, n=256)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": "256"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def denumericalize(self, n=256):\n    self.center = self.center / n\n    self.radius = self.radius / n"
            },
            "sample_points": {
              "name": "sample_points",
              "path": "rapidcadpy.primitive.Circle.sample_points",
              "signature": "(self, n=32)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": "32"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def sample_points(self, n=32):\n    angles = np.linspace(0, 2 * np.pi, n, endpoint=False)\n    x = self.center.x + self.radius * np.cos(angles)\n    y = self.center.y + self.radius * np.sin(angles)\n    return np.column_stack([x, y])"
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.primitive.Circle.to_json",
              "signature": "(self, dereferenced=True)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "dereferenced",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self, dereferenced=True):\n    return {\n        \"type\": \"Circle\",\n        \"id\": str(self.id),\n        \"center\": {\"x\": float(self.center[0]), \"y\": float(self.center[1])},\n        \"radius\": self.radius,\n    }"
            },
            "from_json": {
              "name": "from_json",
              "path": "rapidcadpy.primitive.Circle.from_json",
              "signature": "(stat)",
              "description": null,
              "parameters": [
                {
                  "name": "stat",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_json(stat):\n    assert stat[\"type\"] == \"Circle\"\n    center = Vertex(x=stat[\"center\"][\"x\"], y=stat[\"center\"][\"y\"])\n    radius = stat[\"radius\"]\n    return Circle(center, radius)"
            }
          },
          "source": "class Circle(Primitive):\n    def __init__(\n        self,\n        center: Union[Iterable, Vertex],\n        radius: float,\n        normal=None,\n        id: Optional[uuid.UUID] = None,\n        name: str = \"circle\",\n    ):\n        super(Circle, self).__init__(id, name)\n        if not isinstance(center, Vertex):\n            center = Vertex(x=center[0], y=center[1])\n        self.center = center\n        self.radius: float = round(radius, 6)\n        self.normal: np.array = normal\n\n    def __str__(self):\n        return \"Circle: center({}), radius({})\".format(\n            self.center.round(4), round(self.radius, 4)\n        )\n\n    def __repr__(self):\n        return f\"Circle(center={self.center}, radius={self.radius})\"\n\n    @staticmethod\n    def from_dict(stat):\n        assert stat[\"type\"] == \"Circle3D\"\n        center = np.array([stat[\"center_point\"][\"x\"], stat[\"center_point\"][\"y\"]])\n        radius = stat[\"radius\"]\n        normal = np.array(\n            [stat[\"normal\"][\"x\"], stat[\"normal\"][\"y\"], stat[\"normal\"][\"z\"]]\n        )\n        return Circle(center, radius, normal)\n\n    @staticmethod\n    def from_fs_dict(entity_dict):\n        center = [\n            entity_dict[\"geometry\"][\"message\"][\"xCenter\"],\n            entity_dict[\"geometry\"][\"message\"][\"yCenter\"],\n        ]\n        radius = entity_dict[\"geometry\"][\"message\"][\"radius\"]\n        return Circle(center, radius)\n\n    @property\n    def bbox(self):\n        return np.stack([self.center - self.radius, self.center + self.radius], axis=0)\n\n    def direction(self, from_start=True):\n        return self.center - self.start_point\n\n    def physical_len(self):\n        return 2 * np.pi * self.radius\n\n    @property\n    def start_point(self):\n        return np.array([self.center[0] - self.radius, self.center[1]])\n\n    @property\n    def end_point(self):\n        return np.array([self.center[0] + self.radius, self.center[1]])\n\n    def transform(self, translate, scale):\n        self.center = (self.center + translate) * scale\n        self.radius = self.radius * scale\n\n    def flip(self, axis):\n        if axis == \"x\":\n            self.center[1] = -self.center[1]\n        elif axis == \"y\":\n            self.center[0] = -self.center[0]\n        elif axis == \"xy\":\n            self.center = self.center * -1\n        else:\n            raise ValueError(\"axis = {}\".format(axis))\n\n    def reverse(self):\n        pass\n\n    def numericalize(self, n=256):\n        self.center = (self.center * n).round().clip(min=0, max=n - 1).astype(int)\n        self.radius = max(1, min(int(round(self.radius * n)), n - 1))\n\n    def denumericalize(self, n=256):\n        self.center = self.center / n\n        self.radius = self.radius / n\n\n    def sample_points(self, n=32):\n        angles = np.linspace(0, 2 * np.pi, n, endpoint=False)\n        x = self.center.x + self.radius * np.cos(angles)\n        y = self.center.y + self.radius * np.sin(angles)\n        return np.column_stack([x, y])\n\n    def to_json(self, dereferenced=True):\n        return {\n            \"type\": \"Circle\",\n            \"id\": str(self.id),\n            \"center\": {\"x\": float(self.center[0]), \"y\": float(self.center[1])},\n            \"radius\": self.radius,\n        }\n\n    @staticmethod\n    def from_json(stat):\n        assert stat[\"type\"] == \"Circle\"\n        center = Vertex(x=stat[\"center\"][\"x\"], y=stat[\"center\"][\"y\"])\n        radius = stat[\"radius\"]\n        return Circle(center, radius)",
          "inherited_members": {
            "rapidcadpy.primitive.Primitive": [
              {
                "kind": "attribute",
                "path": "rapidcadpy.primitive.Primitive.id"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.primitive.Primitive.name"
              }
            ]
          }
        },
        "EntityType": {
          "name": "EntityType",
          "path": "rapidcadpy.primitive.EntityType",
          "description": "Enumeration indicating the type of entity represented.",
          "parameters": [],
          "attributes": [
            {
              "name": "Point",
              "annotation": null,
              "description": null,
              "value": "0"
            },
            {
              "name": "Line",
              "annotation": null,
              "description": null,
              "value": "1"
            },
            {
              "name": "Circle",
              "annotation": null,
              "description": null,
              "value": "2"
            },
            {
              "name": "Ellipse",
              "annotation": null,
              "description": null,
              "value": "3"
            },
            {
              "name": "Spline",
              "annotation": null,
              "description": null,
              "value": "4"
            },
            {
              "name": "Conic",
              "annotation": null,
              "description": null,
              "value": "5"
            },
            {
              "name": "Arc",
              "annotation": null,
              "description": null,
              "value": "6"
            },
            {
              "name": "External",
              "annotation": null,
              "description": null,
              "value": "7"
            },
            {
              "name": "Stop",
              "annotation": null,
              "description": null,
              "value": "8"
            },
            {
              "name": "Unknown",
              "annotation": null,
              "description": null,
              "value": "9"
            }
          ],
          "docstring": [],
          "functions": {},
          "source": "class EntityType(enum.IntEnum):\n    \"\"\"Enumeration indicating the type of entity represented.\"\"\"\n\n    Point = 0\n    Line = 1\n    Circle = 2\n    Ellipse = 3\n    Spline = 4\n    Conic = 5\n    Arc = 6\n    External = 7\n    Stop = 8\n    Unknown = 9",
          "inherited_members": {}
        },
        "Line": {
          "name": "Line",
          "path": "rapidcadpy.primitive.Line",
          "description": "A line entity defined by a start point and a direction.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "start_point",
              "annotation": "Union[Iterable, Vertex]",
              "description": null,
              "value": null
            },
            {
              "name": "end_point",
              "annotation": "Union[Iterable, Vertex]",
              "description": null,
              "value": null
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "None"
            },
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": "'line'"
            }
          ],
          "attributes": [
            {
              "name": "start_point",
              "annotation": null,
              "description": null,
              "value": "start_point"
            },
            {
              "name": "end_point",
              "annotation": null,
              "description": null,
              "value": "end_point"
            },
            {
              "name": "bbox",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.primitive.Line.__init__",
              "signature": "(self, start_point, end_point, id=None, name='line')",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "start_point",
                  "annotation": "Union[Iterable, Vertex]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "end_point",
                  "annotation": "Union[Iterable, Vertex]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "id",
                  "annotation": "Optional[uuid.UUID]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "'line'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(\n    self,\n    start_point: Union[Iterable, Vertex],\n    end_point: Union[Iterable, Vertex],\n    id: Optional[uuid.UUID] = None,\n    name: str = \"line\",\n):\n    super(Line, self).__init__(id, name)\n    if isinstance(start_point, Vertex):\n        self.start_point = start_point\n    else:\n        if len(start_point) > 2:\n            raise\n        self.start_point = Vertex(x=float(start_point[0]), y=float(start_point[1]))\n\n    if isinstance(end_point, Vertex):\n        self.end_point = end_point\n    else:\n        if len(end_point) > 2:\n            raise\n        self.end_point = Vertex(x=float(end_point[0]), y=float(end_point[1]))"
            },
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.primitive.Line.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    return f\"Line: start({self.start_point}), end({self.end_point})\""
            },
            "__repr__": {
              "name": "__repr__",
              "path": "rapidcadpy.primitive.Line.__repr__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self):\n    return f\"Line(start_point={self.start_point}, end_point={self.end_point})\""
            },
            "__eq__": {
              "name": "__eq__",
              "path": "rapidcadpy.primitive.Line.__eq__",
              "signature": "(self, other)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "other",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __eq__(self, other):\n    return np.allclose(self.start_point, other.start_point) and np.allclose(\n        self.end_point, other.end_point\n    )"
            },
            "__hash__": {
              "name": "__hash__",
              "path": "rapidcadpy.primitive.Line.__hash__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __hash__(self):\n    return hash((hash(self.start_point), hash(self.end_point)))"
            },
            "from_f360_dict": {
              "name": "from_f360_dict",
              "path": "rapidcadpy.primitive.Line.from_f360_dict",
              "signature": "(stat)",
              "description": null,
              "parameters": [
                {
                  "name": "stat",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_f360_dict(stat):\n    assert stat[\"type\"] == \"Line3D\"\n    start_point = np.array([stat[\"start_point\"][\"x\"], stat[\"start_point\"][\"y\"]])\n    end_point = np.array([stat[\"end_point\"][\"x\"], stat[\"end_point\"][\"y\"]])\n    return Line(start_point, end_point)"
            },
            "from_fs_dict": {
              "name": "from_fs_dict",
              "path": "rapidcadpy.primitive.Line.from_fs_dict",
              "signature": "(entity_dict)",
              "description": null,
              "parameters": [
                {
                  "name": "entity_dict",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_fs_dict(entity_dict):\n    entity_dict = entity_dict[\"message\"]\n    geometry_dict = entity_dict[\"geometry\"][\"message\"]\n    pnt_x = geometry_dict[\"pntX\"]\n    pnt_y = geometry_dict[\"pntY\"]\n    dir_x = geometry_dict[\"dirX\"]\n    dir_y = geometry_dict[\"dirY\"]\n    start_param = entity_dict[\"startParam\"]\n    end_param = entity_dict[\"endParam\"]\n\n    startX = pnt_x + start_param * dir_x\n    startY = pnt_y + start_param * dir_y\n\n    endX = pnt_x + end_param * dir_x\n    endY = pnt_y + end_param * dir_y\n    return Line([startX, startY], [endX, endY])"
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.primitive.Line.to_json",
              "signature": "(self, dereferenced=True)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "dereferenced",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self, dereferenced=True):\n    if dereferenced:\n        return {\n            \"type\": \"Line\",\n            \"start\": self.start_point.to_json(),\n            \"end\": self.end_point.to_json(),\n        }\n    return {\n        \"type\": \"Line\",\n        \"start\": str(self.start_point.name),\n        \"end\": str(self.end_point.name),\n    }"
            },
            "from_json": {
              "name": "from_json",
              "path": "rapidcadpy.primitive.Line.from_json",
              "signature": "(stat, vertices=None)",
              "description": null,
              "parameters": [
                {
                  "name": "stat",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "vertices",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_json(stat, vertices=None):\n    if vertices is None:\n        start_point = stat[\"start\"]\n        end_point = stat[\"end\"]\n        return Line(\n            np.array([start_point[\"x\"], start_point[\"y\"]]),\n            np.array([end_point[\"x\"], end_point[\"y\"]]),\n        )\n    else:\n        assert stat[\"type\"] == \"Line\"\n        start_point = vertices[stat[\"start\"]]\n        end_point = vertices[stat[\"end\"]]\n        return Line(start_point, end_point)"
            },
            "flip": {
              "name": "flip",
              "path": "rapidcadpy.primitive.Line.flip",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def flip(self):\n    self.start_point, self.end_point = self.end_point, self.start_point"
            },
            "transform": {
              "name": "transform",
              "path": "rapidcadpy.primitive.Line.transform",
              "signature": "(self, translate, scale)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "translate",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "scale",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def transform(self, translate, scale):\n    self.start_point = (self.start_point + translate) * scale\n    self.end_point = (self.end_point + translate) * scale"
            },
            "numericalize": {
              "name": "numericalize",
              "path": "rapidcadpy.primitive.Line.numericalize",
              "signature": "(self, n=256)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": "256"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def numericalize(self, n=256):\n    self.start_point.numericalize(n)\n    self.end_point.numericalize(n)"
            },
            "denumericalize": {
              "name": "denumericalize",
              "path": "rapidcadpy.primitive.Line.denumericalize",
              "signature": "(self, n=256)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": "256"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def denumericalize(self, n=256):\n    self.start_point.denumericalize(n)\n    self.end_point.denumericalize(n)"
            },
            "to_occ": {
              "name": "to_occ",
              "path": "rapidcadpy.primitive.Line.to_occ",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_occ(self):\n    from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeEdge\n    from OCC.Core.gp import gp_Pnt\n\n    p1 = gp_Pnt(\n        self.start_point.x, self.start_point.y, getattr(self.start_point, \"z\", 0.0)\n    )\n    p2 = gp_Pnt(\n        self.end_point.x, self.end_point.y, getattr(self.end_point, \"z\", 0.0)\n    )\n    return BRepBuilderAPI_MakeEdge(p1, p2).Edge()"
            }
          },
          "source": "class Line(Primitive):\n    \"\"\"\n    A line entity defined by a start point and a direction.\n    \"\"\"\n\n    def __init__(\n        self,\n        start_point: Union[Iterable, Vertex],\n        end_point: Union[Iterable, Vertex],\n        id: Optional[uuid.UUID] = None,\n        name: str = \"line\",\n    ):\n        super(Line, self).__init__(id, name)\n        if isinstance(start_point, Vertex):\n            self.start_point = start_point\n        else:\n            if len(start_point) > 2:\n                raise\n            self.start_point = Vertex(x=float(start_point[0]), y=float(start_point[1]))\n\n        if isinstance(end_point, Vertex):\n            self.end_point = end_point\n        else:\n            if len(end_point) > 2:\n                raise\n            self.end_point = Vertex(x=float(end_point[0]), y=float(end_point[1]))\n\n    def __str__(self):\n        return f\"Line: start({self.start_point}), end({self.end_point})\"\n\n    def __repr__(self):\n        return f\"Line(start_point={self.start_point}, end_point={self.end_point})\"\n\n    def __eq__(self, other):\n        return np.allclose(self.start_point, other.start_point) and np.allclose(\n            self.end_point, other.end_point\n        )\n\n    def __hash__(self):\n        return hash((hash(self.start_point), hash(self.end_point)))\n\n    @staticmethod\n    def from_f360_dict(stat):\n        assert stat[\"type\"] == \"Line3D\"\n        start_point = np.array([stat[\"start_point\"][\"x\"], stat[\"start_point\"][\"y\"]])\n        end_point = np.array([stat[\"end_point\"][\"x\"], stat[\"end_point\"][\"y\"]])\n        return Line(start_point, end_point)\n\n    @staticmethod\n    def from_fs_dict(entity_dict):\n        entity_dict = entity_dict[\"message\"]\n        geometry_dict = entity_dict[\"geometry\"][\"message\"]\n        pnt_x = geometry_dict[\"pntX\"]\n        pnt_y = geometry_dict[\"pntY\"]\n        dir_x = geometry_dict[\"dirX\"]\n        dir_y = geometry_dict[\"dirY\"]\n        start_param = entity_dict[\"startParam\"]\n        end_param = entity_dict[\"endParam\"]\n\n        startX = pnt_x + start_param * dir_x\n        startY = pnt_y + start_param * dir_y\n\n        endX = pnt_x + end_param * dir_x\n        endY = pnt_y + end_param * dir_y\n        return Line([startX, startY], [endX, endY])\n\n    def to_json(self, dereferenced=True):\n        if dereferenced:\n            return {\n                \"type\": \"Line\",\n                \"start\": self.start_point.to_json(),\n                \"end\": self.end_point.to_json(),\n            }\n        return {\n            \"type\": \"Line\",\n            \"start\": str(self.start_point.name),\n            \"end\": str(self.end_point.name),\n        }\n\n    @staticmethod\n    def from_json(stat, vertices=None):\n        if vertices is None:\n            start_point = stat[\"start\"]\n            end_point = stat[\"end\"]\n            return Line(\n                np.array([start_point[\"x\"], start_point[\"y\"]]),\n                np.array([end_point[\"x\"], end_point[\"y\"]]),\n            )\n        else:\n            assert stat[\"type\"] == \"Line\"\n            start_point = vertices[stat[\"start\"]]\n            end_point = vertices[stat[\"end\"]]\n            return Line(start_point, end_point)\n\n    def flip(self):\n        self.start_point, self.end_point = self.end_point, self.start_point\n\n    @property\n    def bbox(self):\n        points = np.stack([self.start_point, self.end_point], axis=0)\n        return np.stack([np.min(points, axis=0), np.max(points, axis=0)], axis=0)\n\n    def transform(self, translate, scale):\n        self.start_point = (self.start_point + translate) * scale\n        self.end_point = (self.end_point + translate) * scale\n\n    def numericalize(self, n=256):\n        self.start_point.numericalize(n)\n        self.end_point.numericalize(n)\n\n    def denumericalize(self, n=256):\n        self.start_point.denumericalize(n)\n        self.end_point.denumericalize(n)\n\n    def to_occ(self):\n        from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeEdge\n        from OCC.Core.gp import gp_Pnt\n\n        p1 = gp_Pnt(\n            self.start_point.x, self.start_point.y, getattr(self.start_point, \"z\", 0.0)\n        )\n        p2 = gp_Pnt(\n            self.end_point.x, self.end_point.y, getattr(self.end_point, \"z\", 0.0)\n        )\n        return BRepBuilderAPI_MakeEdge(p1, p2).Edge()",
          "inherited_members": {
            "rapidcadpy.primitive.Primitive": [
              {
                "kind": "function",
                "path": "rapidcadpy.primitive.Primitive.from_dict"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.primitive.Primitive.id"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.primitive.Primitive.name"
              }
            ]
          }
        }
      },
      "functions": {
        "inspect_entity_type": {
          "name": "inspect_entity_type",
          "path": "rapidcadpy.primitive.inspect_entity_type",
          "signature": "(entity_dict) -> EntityType",
          "description": "Inspects the entity dictionary and determines the corresponding entity type.",
          "parameters": [
            {
              "name": "entity_dict",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": "rapidcadpy.primitive.EntityType",
            "description": null
          },
          "docstring": [],
          "source": "def inspect_entity_type(entity_dict) -> EntityType:\n    \"\"\"Inspects the entity dictionary and determines the corresponding entity type.\"\"\"\n\n    if entity_dict[\"typeName\"].startswith(\"BTMSketchPoint\"):\n        return EntityType.Point\n\n    if \"geometry\" not in entity_dict[\"message\"]:\n        # Non-geometry entity (e.g. Text), simply treat as unknown\n        return EntityType.Unknown\n\n    geom_type = entity_dict[\"message\"][\"geometry\"][\"typeName\"]\n    options = [\n        (\"Line\", EntityType.Line),\n        (\"Circle\", EntityType.Circle),\n        (\"Ellipse\", EntityType.Ellipse),\n        (\"Spline\", EntityType.Spline),\n        (\"Conic\", EntityType.Conic),\n    ]\n    for option, entity_type in options:\n        if option in geom_type:\n            break\n    else:\n        return EntityType.Unknown\n\n    if option == \"Circle\":\n        if entity_dict[\"typeName\"] == \"BTMSketchCurveSegment\":\n            return EntityType.Arc\n    if option == \"Ellipse\":\n        if entity_dict[\"typeName\"] == \"BTMSketchCurveSegment\":\n            # really should be EllipseArc here\n            return EntityType.Unknown\n\n    if option == \"Spline\":\n        if entity_dict[\"message\"][\"geometry\"][\"type\"] == 117:\n            return EntityType.Spline\n        # BTCurveGeometryInterpolatedSpline\n        return EntityType.Unknown\n\n    return entity_type"
        }
      }
    },
    "cad_types": {
      "name": "cad_types",
      "path": "rapidcadpy.cad_types",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/cad_types.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "VectorLike",
          "annotation": null,
          "description": null,
          "value": "Union[Tuple[float, float], Tuple[float, float, float], Vector]"
        }
      ],
      "modules": {},
      "classes": {
        "Vector": {
          "name": "Vector",
          "path": "rapidcadpy.cad_types.Vector",
          "description": null,
          "parameters": [],
          "attributes": [
            {
              "name": "x",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "y",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "z",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__new__": {
              "name": "__new__",
              "path": "rapidcadpy.cad_types.Vector.__new__",
              "signature": "(cls, x, y, z=0) -> Vector",
              "description": null,
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "x",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "y",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "z",
                  "annotation": "float",
                  "description": null,
                  "value": "0"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "rapidcadpy.cad_types.Vector",
                "description": null
              },
              "docstring": [],
              "source": "def __new__(cls, x: float, y: float, z: float = 0) -> \"Vector\":\n    return np.asarray([x, y, z]).view(cls)"
            },
            "__eq__": {
              "name": "__eq__",
              "path": "rapidcadpy.cad_types.Vector.__eq__",
              "signature": "(self, other) -> bool",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "other",
                  "annotation": "object",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bool",
                "description": null
              },
              "docstring": [],
              "source": "def __eq__(self, other: object) -> bool:\n    return np.allclose(self, other)"
            },
            "normalize": {
              "name": "normalize",
              "path": "rapidcadpy.cad_types.Vector.normalize",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def normalize(self):\n    return self / np.linalg.norm(self)"
            },
            "get_2d": {
              "name": "get_2d",
              "path": "rapidcadpy.cad_types.Vector.get_2d",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def get_2d(self):\n    return np.array((self[0], self[1]))"
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.cad_types.Vector.to_json",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self):\n    return {\n        \"x\": float(self.x),\n        \"y\": float(self.y),\n        \"z\": float(self.z),\n    }"
            },
            "from_json": {
              "name": "from_json",
              "path": "rapidcadpy.cad_types.Vector.from_json",
              "signature": "(json_data)",
              "description": null,
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_json(json_data):\n    return Vector(json_data[\"x\"], json_data[\"y\"], json_data[\"z\"])"
            },
            "to_python": {
              "name": "to_python",
              "path": "rapidcadpy.cad_types.Vector.to_python",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_python(self):\n    return f\"Vector({self.x}, {self.y}, {self.z})\""
            }
          },
          "source": "class Vector(np.ndarray):\n    def __new__(cls, x: float, y: float, z: float = 0) -> \"Vector\":\n        return np.asarray([x, y, z]).view(cls)\n\n    def __eq__(self, other: object) -> bool:\n        return np.allclose(self, other)\n\n    def normalize(self):\n        return self / np.linalg.norm(self)\n\n    def get_2d(self):\n        return np.array((self[0], self[1]))\n\n    @property\n    def x(self):\n        return self[0]\n\n    @property\n    def y(self):\n        return self[1]\n\n    @property\n    def z(self):\n        return self[2]\n\n    def to_json(self):\n        return {\n            \"x\": float(self.x),\n            \"y\": float(self.y),\n            \"z\": float(self.z),\n        }\n\n    @staticmethod\n    def from_json(json_data):\n        return Vector(json_data[\"x\"], json_data[\"y\"], json_data[\"z\"])\n\n    def to_python(self):\n        return f\"Vector({self.x}, {self.y}, {self.z})\"",
          "inherited_members": {}
        },
        "Vertex": {
          "name": "Vertex",
          "path": "rapidcadpy.cad_types.Vertex",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "x",
              "annotation": "float",
              "description": null,
              "value": null
            },
            {
              "name": "y",
              "annotation": "float",
              "description": null,
              "value": null
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "None"
            },
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": "'unnamed_vertex'"
            }
          ],
          "attributes": [
            {
              "name": "id",
              "annotation": null,
              "description": null,
              "value": "id if id else uuid.uuid4()"
            },
            {
              "name": "name",
              "annotation": null,
              "description": null,
              "value": "name"
            },
            {
              "name": "x",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "y",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__new__": {
              "name": "__new__",
              "path": "rapidcadpy.cad_types.Vertex.__new__",
              "signature": "(cls, x, y, id=None, name='unnamed_vertex')",
              "description": null,
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "x",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "y",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "id",
                  "annotation": "Optional[uuid.UUID]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "'unnamed_vertex'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __new__(\n    cls,\n    x: float,\n    y: float,\n    id: Optional[uuid.UUID] = None,\n    name: str = \"unnamed_vertex\",\n):\n    obj = np.asarray([float(x), float(y)])\n    obj = np.round(obj, 6).view(cls)\n    return obj"
            },
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.cad_types.Vertex.__init__",
              "signature": "(self, x, y, id=None, name='unnamed_vertex')",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "x",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "y",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "id",
                  "annotation": "Optional[uuid.UUID]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "'unnamed_vertex'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(\n    self,\n    x: float,\n    y: float,\n    id: Optional[uuid.UUID] = None,\n    name: str = \"unnamed_vertex\",\n):\n    # Assign the extra attributes\n    self.id = id if id else uuid.uuid4()\n    self.name = name"
            },
            "__array_finalize__": {
              "name": "__array_finalize__",
              "path": "rapidcadpy.cad_types.Vertex.__array_finalize__",
              "signature": "(self, obj)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "obj",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __array_finalize__(self, obj):\n    if obj is None:\n        return\n    self.id = getattr(obj, \"id\", None)\n    self.name = getattr(obj, \"name\", \"unnamed_vertex\")"
            },
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.cad_types.Vertex.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    return f\"Vertex(x={self.x}, y={self.y})\""
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.cad_types.Vertex.to_json",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self):\n    return {\n        \"x\": round(float(self.x), 6),\n        \"y\": round(float(self.y), 6),\n    }"
            },
            "from_json": {
              "name": "from_json",
              "path": "rapidcadpy.cad_types.Vertex.from_json",
              "signature": "(json_data)",
              "description": null,
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_json(json_data):\n    return Vertex(json_data[\"x\"], json_data[\"y\"])"
            },
            "__eq__": {
              "name": "__eq__",
              "path": "rapidcadpy.cad_types.Vertex.__eq__",
              "signature": "(self, other)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "other",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __eq__(self, other):\n    tolerance = 1e-9\n    if not isinstance(other, Vertex):\n        return math.isclose(self.x, other[0], abs_tol=tolerance) and math.isclose(\n            self.y, other[1], abs_tol=tolerance\n        )\n    return math.isclose(self.x, other.x, abs_tol=tolerance) and math.isclose(\n        self.y, other.y, abs_tol=tolerance\n    )"
            },
            "__hash__": {
              "name": "__hash__",
              "path": "rapidcadpy.cad_types.Vertex.__hash__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __hash__(self):\n    return hash((round(self.x, 6), round(self.y, 6)))"
            },
            "to_python": {
              "name": "to_python",
              "path": "rapidcadpy.cad_types.Vertex.to_python",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_python(self):\n    return f\"Vertex(x={self.x}, y={self.y})\""
            },
            "round": {
              "name": "round",
              "path": "rapidcadpy.cad_types.Vertex.round",
              "signature": "(self, decimals=0)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "decimals",
                  "annotation": null,
                  "description": null,
                  "value": "0"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def round(self, decimals=0):\n    self[0] = round(self[0], decimals)\n    self[1] = round(self[1], decimals)"
            }
          },
          "source": "class Vertex(np.ndarray):\n    def __new__(\n        cls,\n        x: float,\n        y: float,\n        id: Optional[uuid.UUID] = None,\n        name: str = \"unnamed_vertex\",\n    ):\n        obj = np.asarray([float(x), float(y)])\n        obj = np.round(obj, 6).view(cls)\n        return obj\n\n    def __init__(\n        self,\n        x: float,\n        y: float,\n        id: Optional[uuid.UUID] = None,\n        name: str = \"unnamed_vertex\",\n    ):\n        # Assign the extra attributes\n        self.id = id if id else uuid.uuid4()\n        self.name = name\n\n    def __array_finalize__(self, obj):\n        if obj is None:\n            return\n        self.id = getattr(obj, \"id\", None)\n        self.name = getattr(obj, \"name\", \"unnamed_vertex\")\n\n    def __str__(self):\n        return f\"Vertex(x={self.x}, y={self.y})\"\n\n    @property\n    def x(self):\n        return np.round(self[0], 6)\n\n    @property\n    def y(self):\n        return np.round(self[1], 6)\n\n    def to_json(self):\n        return {\n            \"x\": round(float(self.x), 6),\n            \"y\": round(float(self.y), 6),\n        }\n\n    @staticmethod\n    def from_json(json_data):\n        return Vertex(json_data[\"x\"], json_data[\"y\"])\n\n    def __eq__(self, other):\n        tolerance = 1e-9\n        if not isinstance(other, Vertex):\n            return math.isclose(self.x, other[0], abs_tol=tolerance) and math.isclose(\n                self.y, other[1], abs_tol=tolerance\n            )\n        return math.isclose(self.x, other.x, abs_tol=tolerance) and math.isclose(\n            self.y, other.y, abs_tol=tolerance\n        )\n\n    def __hash__(self):\n        return hash((round(self.x, 6), round(self.y, 6)))\n\n    def to_python(self):\n        return f\"Vertex(x={self.x}, y={self.y})\"\n\n    def round(self, decimals=0):\n        self[0] = round(self[0], decimals)\n        self[1] = round(self[1], decimals)",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "custom_extrude": {
      "name": "custom_extrude",
      "path": "rapidcadpy.custom_extrude",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/custom_extrude.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {},
      "functions": {
        "custom_extrude": {
          "name": "custom_extrude",
          "path": "rapidcadpy.custom_extrude.custom_extrude",
          "signature": "(to_extrude=None, plane=Plane(origin=(0, 0, 0), x_dir=(1, 0, 0), z_dir=(0, 0, 1)), amount=None, dir=None, until=None, target=None, both=False, taper=0.0, clean=True, mode=Mode.ADD) -> Part",
          "description": "Part Operation: extrude\n\nExtrude a sketch or face by an amount or until another object.\n\nArgs:\n    to_extrude (Union[Face, Sketch], optional): object to extrude. Defaults to None.\n    amount (float, optional): distance to extrude, sign controls direction. Defaults to None.\n    dir (VectorLike, optional): direction. Defaults to None.\n    until (Until, optional): extrude limit. Defaults to None.\n    target (Shape, optional): extrude until target. Defaults to None.\n    both (bool, optional): extrude in both directions. Defaults to False.\n    taper (float, optional): taper angle. Defaults to 0.0.\n    clean (bool, optional): Remove extraneous internal structure. Defaults to True.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: No object to extrude\n    ValueError: No target object\n\nReturns:\n    Part: extruded object\n    :param to_extrude:\n    :param plane:",
          "parameters": [
            {
              "name": "to_extrude",
              "annotation": "Union[Face, Sketch]",
              "description": null,
              "value": "None"
            },
            {
              "name": "plane",
              "annotation": "Plane",
              "description": null,
              "value": "Plane(origin=(0, 0, 0), x_dir=(1, 0, 0), z_dir=(0, 0, 1))"
            },
            {
              "name": "amount",
              "annotation": "float",
              "description": null,
              "value": "None"
            },
            {
              "name": "dir",
              "annotation": "VectorLike",
              "description": null,
              "value": "None"
            },
            {
              "name": "until",
              "annotation": "Until",
              "description": null,
              "value": "None"
            },
            {
              "name": "target",
              "annotation": "Union[Compound, Solid]",
              "description": null,
              "value": "None"
            },
            {
              "name": "both",
              "annotation": "bool",
              "description": null,
              "value": "False"
            },
            {
              "name": "taper",
              "annotation": "float",
              "description": null,
              "value": "0.0"
            },
            {
              "name": "clean",
              "annotation": "bool",
              "description": null,
              "value": "True"
            },
            {
              "name": "mode",
              "annotation": "Mode",
              "description": null,
              "value": "Mode.ADD"
            }
          ],
          "returns": {
            "name": "",
            "annotation": "build123d.topology.Part",
            "description": null
          },
          "docstring": [],
          "source": "def custom_extrude(\n    to_extrude: Union[Face, Sketch] = None,\n    plane: Plane = Plane(origin=(0, 0, 0), x_dir=(1, 0, 0), z_dir=(0, 0, 1)),\n    amount: float = None,\n    dir: VectorLike = None,  # pylint: disable=redefined-builtin\n    until: Until = None,\n    target: Union[Compound, Solid] = None,\n    both: bool = False,\n    taper: float = 0.0,\n    clean: bool = True,\n    mode: Mode = Mode.ADD,\n) -> Part:\n    \"\"\"Part Operation: extrude\n\n    Extrude a sketch or face by an amount or until another object.\n\n    Args:\n        to_extrude (Union[Face, Sketch], optional): object to extrude. Defaults to None.\n        amount (float, optional): distance to extrude, sign controls direction. Defaults to None.\n        dir (VectorLike, optional): direction. Defaults to None.\n        until (Until, optional): extrude limit. Defaults to None.\n        target (Shape, optional): extrude until target. Defaults to None.\n        both (bool, optional): extrude in both directions. Defaults to False.\n        taper (float, optional): taper angle. Defaults to 0.0.\n        clean (bool, optional): Remove extraneous internal structure. Defaults to True.\n        mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\n    Raises:\n        ValueError: No object to extrude\n        ValueError: No target object\n\n    Returns:\n        Part: extruded object\n        :param to_extrude:\n        :param plane:\n    \"\"\"\n    # pylint: disable=too-many-locals, too-many-branches\n    to_extrude_faces: list[Face]\n\n    to_extrude_faces = (\n        [*to_extrude]\n        if isinstance(to_extrude, (tuple, list, filter))\n        else to_extrude.faces()\n    )\n\n    new_solids: list[Solid] = []\n\n    for face in to_extrude_faces:\n        for direction in [1, -1] if both else [1]:\n            if amount:\n                if taper == 0:\n                    new_solids.append(\n                        Solid.extrude(\n                            face,\n                            direction=plane.z_dir * amount * direction,\n                        )\n                    )\n                else:\n                    new_solids.append(\n                        Solid.extrude_taper(\n                            face,\n                            direction=plane.z_dir * amount * direction,\n                            taper=taper,\n                        )\n                    )\n\n            else:\n                new_solids.append(\n                    Solid.extrude_until(\n                        section=face,\n                        target_object=target,\n                        direction=plane.z_dir * direction,\n                        until=until,\n                    )\n                )\n\n    return Part(ShapeList(new_solids).solids())"
        }
      }
    },
    "inventor_backend": {
      "name": "inventor_backend",
      "path": "rapidcadpy.inventor_backend",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/inventor_backend.py",
      "description": "Simplified Inventor backend - bridges to the full InventorIntegration.\n\nThis module provides a simple interface that bridges the fluent API\nto the comprehensive InventorIntegration class.",
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {},
      "functions": {
        "add_inventor_backend_to_cad": {
          "name": "add_inventor_backend_to_cad",
          "path": "rapidcadpy.inventor_backend.add_inventor_backend_to_cad",
          "signature": "()",
          "description": "Add the to_inventor method to the CAD class (legacy support).",
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def add_inventor_backend_to_cad():\n    \"\"\"Add the to_inventor method to the CAD class (legacy support).\"\"\"\n    from .cad import Cad\n\n    def to_inventor(\n        self,\n        inventor_app=None,\n        part_doc=None,\n        filename: Optional[str] = None,\n        close_on_save: bool = False,\n    ):\n        \"\"\"\n        Export this CAD object to Inventor.\n\n        This method now uses the backend manager system for improved flexibility.\n\n        Args:\n            inventor_app: Inventor application (optional)\n            part_doc: Inventor part document (optional)\n            filename: Optional filename to save to\n            close_on_save: Whether to close the document after saving\n        \"\"\"\n        # Use the backend manager system\n        return self.to_inventor(inventor_app, part_doc, filename, close_on_save)\n\n    # Only add if not already present (backend_manager already adds it)\n    if not hasattr(Cad, \"to_inventor\"):\n        Cad.to_inventor = to_inventor"
        }
      }
    },
    "json_to_brep": {
      "name": "json_to_brep",
      "path": "rapidcadpy.json_to_brep",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/json_to_brep.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "cad_json_dir",
          "annotation": null,
          "description": null,
          "value": "pathlib.Path(__file__).parent.parent.joinpath('data').joinpath('cad_json')"
        },
        {
          "name": "brep_dir",
          "annotation": null,
          "description": null,
          "value": "pathlib.Path(__file__).parent.parent.joinpath('data').joinpath('cad_brep')"
        },
        {
          "name": "total_failed",
          "annotation": null,
          "description": null,
          "value": "0"
        },
        {
          "name": "total",
          "annotation": null,
          "description": null,
          "value": "0"
        },
        {
          "name": "cad_json_file",
          "annotation": null,
          "description": null,
          "value": "os.path.join(cad_json_dir, entry)"
        },
        {
          "name": "cad_json",
          "annotation": null,
          "description": null,
          "value": "json.load(f)"
        },
        {
          "name": "cad_seq",
          "annotation": null,
          "description": null,
          "value": "Cad.from_json(cad_json)"
        },
        {
          "name": "step_path",
          "annotation": null,
          "description": null,
          "value": "os.path.join(brep_dir, dir.name, entry.name.replace('.json', '.step'))"
        },
        {
          "name": "occ_parts",
          "annotation": null,
          "description": null,
          "value": "cad_seq.assemble_3d()"
        },
        {
          "name": "assembly",
          "annotation": null,
          "description": null,
          "value": "Compound(children=occ_parts)"
        },
        {
          "name": "ret",
          "annotation": null,
          "description": null,
          "value": "export_step(assembly, step_path)"
        }
      ],
      "modules": {},
      "classes": {},
      "functions": {}
    },
    "cad": {
      "name": "cad",
      "path": "rapidcadpy.cad",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/cad.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "Cad": {
          "name": "Cad",
          "path": "rapidcadpy.cad.Cad",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "construction_sequence",
              "annotation": "List[Feature]",
              "description": null,
              "value": null
            },
            {
              "name": "bounding_box",
              "annotation": "Optional[Any]",
              "description": null,
              "value": "None"
            }
          ],
          "attributes": [
            {
              "name": "construction_history",
              "annotation": null,
              "description": null,
              "value": "construction_sequence"
            },
            {
              "name": "bbox",
              "annotation": null,
              "description": null,
              "value": "bounding_box"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.cad.Cad.__init__",
              "signature": "(self, construction_sequence, bounding_box=None)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "construction_sequence",
                  "annotation": "List[Feature]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "bounding_box",
                  "annotation": "Optional[Any]",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(\n    self, construction_sequence: List[Feature], bounding_box: Optional[Any] = None\n):\n    self.construction_history = construction_sequence\n    self.bbox = bounding_box"
            },
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.cad.Cad.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    construction_hist_str = \"\\n\".join(\n        [\n            str(sketch_extrude)\n            for i, sketch_extrude in enumerate(self.construction_history)\n        ]\n    )\n    return construction_hist_str"
            },
            "create_edge_3d": {
              "name": "create_edge_3d",
              "path": "rapidcadpy.cad.Cad.create_edge_3d",
              "signature": "(curve, sketch_plane)",
              "description": "create a 3D edge",
              "parameters": [
                {
                  "name": "curve",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "sketch_plane",
                  "annotation": "Plane",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef create_edge_3d(curve, sketch_plane: Plane):\n    \"\"\"create a 3D edge\"\"\"\n    from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeEdge\n    from OCC.Core.GC import GC_MakeArcOfCircle\n    from OCC.Core.gp import gp_Ax2, gp_Circ, gp_Dir\n\n    if isinstance(curve, Line):\n        if np.allclose(curve.start_point, curve.end_point):\n            return -1\n\n        # translate to global coordinates\n        start_point = (\n            curve.start_point.x * sketch_plane.x_dir\n            + curve.start_point.y * sketch_plane.y_dir\n        ) + sketch_plane.origin\n        end_point = (\n            curve.end_point.x * sketch_plane.x_dir\n            + curve.end_point.y * sketch_plane.y_dir\n        ) + sketch_plane.origin\n\n        start_point = gp_Pnt(*start_point)\n        end_point = gp_Pnt(*end_point)\n\n        topo_edge = BRepBuilderAPI_MakeEdge(start_point, end_point)\n    elif isinstance(curve, Circle):\n        center = (\n            curve.center.x * sketch_plane.x_dir\n            + curve.center.y * sketch_plane.y_dir\n            + sketch_plane.origin\n        )\n        center = gp_Pnt(*center)\n        axis = gp_Dir(*[float(v) for v in sketch_plane.z_dir])\n        gp_circle = gp_Circ(gp_Ax2(center, axis), abs(float(curve.radius)))\n        topo_edge = BRepBuilderAPI_MakeEdge(gp_circle)\n    elif isinstance(curve, Arc):\n        start_point = (\n            curve.start_point.x * sketch_plane.x_dir\n            + curve.start_point.y * sketch_plane.y_dir\n        ) + sketch_plane.origin\n        end_point = (\n            curve.end_point.x * sketch_plane.x_dir\n            + curve.end_point.y * sketch_plane.y_dir\n        ) + sketch_plane.origin\n        mid_point = (\n            curve.mid_point.x * sketch_plane.x_dir\n            + curve.mid_point.y * sketch_plane.y_dir\n        ) + sketch_plane.origin\n\n        start_point = gp_Pnt(*start_point)\n        mid_point = gp_Pnt(*mid_point)\n        end_point = gp_Pnt(*end_point)\n        arc = GC_MakeArcOfCircle(start_point, mid_point, end_point).Value()\n\n        topo_edge = BRepBuilderAPI_MakeEdge(arc)\n    else:\n        raise NotImplementedError(type(curve))\n    return topo_edge.Edge()"
            },
            "_create_profile_face": {
              "name": "_create_profile_face",
              "path": "rapidcadpy.cad.Cad._create_profile_face",
              "signature": "(outer_wire, inner_wires=None)",
              "description": "create a face from a sketch profile and the sketch plane",
              "parameters": [
                {
                  "name": "outer_wire",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "inner_wires",
                  "annotation": "List[TopoDS_Wire]",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef _create_profile_face(outer_wire, inner_wires: List[TopoDS_Wire] = None):\n    \"\"\"create a face from a sketch profile and the sketch plane\"\"\"\n    from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeFace\n\n    topo_face = BRepBuilderAPI_MakeFace(outer_wire)\n    if inner_wires:\n        for inner_wire in inner_wires:\n            topo_face.Add(inner_wire.Reversed())\n    return topo_face.Face()"
            },
            "_create_loop_3d": {
              "name": "_create_loop_3d",
              "path": "rapidcadpy.cad.Cad._create_loop_3d",
              "signature": "(outer_wire, sketch_plane) -> TopoDS_Wire",
              "description": "create a 3D sketch loop",
              "parameters": [
                {
                  "name": "outer_wire",
                  "annotation": "Wire",
                  "description": null,
                  "value": null
                },
                {
                  "name": "sketch_plane",
                  "annotation": "Plane",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "OCC.Core.TopoDS.TopoDS_Wire",
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef _create_loop_3d(outer_wire: Wire, sketch_plane: Plane) -> TopoDS_Wire:\n    \"\"\"create a 3D sketch loop\"\"\"\n    from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeWire\n    from OCC.Core.ShapeFix import ShapeFix_Wire\n\n    topo_wire = BRepBuilderAPI_MakeWire()\n    for edge in outer_wire.edges:\n        topo_edge = Cad.create_edge_3d(edge, sketch_plane)\n        if topo_edge == -1:  # omitted\n            continue\n        topo_wire.Add(topo_edge)\n    wire = topo_wire.Wire()\n\n    fixer = ShapeFix_Wire()\n    fixer.Load(wire)\n    fixer.FixReorder()  # Reorder edges\n    fixer.FixConnected()  # Ensure continuity\n    fixer.FixClosed()  # Ensure closure\n    fixer.Perform()\n\n    return fixer.Wire()"
            },
            "_create_by_extrude": {
              "name": "_create_by_extrude",
              "path": "rapidcadpy.cad.Cad._create_by_extrude",
              "signature": "(sk_ex)",
              "description": null,
              "parameters": [
                {
                  "name": "sk_ex",
                  "annotation": "SketchExtrude",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef _create_by_extrude(sk_ex: SketchExtrude):\n    from OCC.Core.BRepAlgoAPI import BRepAlgoAPI_Fuse\n    from OCC.Core.BRepPrimAPI import BRepPrimAPI_MakePrism\n    from OCC.Core.gp import gp_Vec\n\n    \"\"\"create a solid body from Extrude instance.\"\"\"\n    bodies = []\n    for sketch in sk_ex.sketch:\n        outer_wire = copy(sketch.outer_wire)\n        sketch_plane = copy(sketch.sketch_plane)\n        sketch_plane.origin = sketch.sketch_plane.origin\n        try:\n            outer_wire = Cad._create_loop_3d(outer_wire, sketch_plane)\n            inner_wires: List[TopoDS_Wire] = []\n            for inner_wire in sketch.inner_wires:\n                inner_wires.append(Cad._create_loop_3d(inner_wire, sketch_plane))\n            face = Cad._create_profile_face(outer_wire, inner_wires)\n\n            normal = gp_Dir(\n                *[float(v) * sk_ex.extrude.direction for v in sketch_plane.z_dir]\n            )\n\n            ext_vec = gp_Vec(normal).Multiplied(float(sk_ex.extrude.extent_one))\n\n            body = BRepPrimAPI_MakePrism(face, ext_vec).Shape()\n            bodies.append(body)\n        except RuntimeError:\n            continue\n\n    # fuse bodies into one\n    if len(bodies) > 1:\n        body = bodies[0]\n        for b in bodies[1:]:\n            body = BRepAlgoAPI_Fuse(body, b).Shape()\n    elif len(bodies) == 1:\n        body = bodies[0]\n    else:\n        return None\n\n    return body"
            },
            "to_occ": {
              "name": "to_occ",
              "path": "rapidcadpy.cad.Cad.to_occ",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_occ(self):\n    from OCC.Core.BRepAlgoAPI import (\n        BRepAlgoAPI_Common,\n        BRepAlgoAPI_Cut,\n        BRepAlgoAPI_Fuse,\n    )\n\n    bodies = []\n    for sk_ex in self.construction_history:\n        body = Cad._create_by_extrude(sk_ex)\n        if body is not None:\n            bodies.append(body)\n\n    if len(bodies) == 0:\n        return None\n    elif len(bodies) == 1:\n        return bodies[0]\n    else:\n        # fuse all bodies\n        result = bodies[0]\n        for body in bodies[1:]:\n            if (\n                sk_ex.extrude.operation == \"NewBodyFeatureOperation\"\n                or sk_ex.extrude.operation == \"JoinFeatureOperation\"\n            ):\n                result = BRepAlgoAPI_Fuse(result, body).Shape()\n            elif sk_ex.extrude.operation == \"CutFeatureOperation\":\n                result = BRepAlgoAPI_Cut(result, body).Shape()\n            elif sk_ex.extrude.operation == \"IntersectFeatureOperation\":\n                result = BRepAlgoAPI_Common(result, body).Shape()\n        return result"
            },
            "to_step": {
              "name": "to_step",
              "path": "rapidcadpy.cad.Cad.to_step",
              "signature": "(self, filename)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "filename",
                  "annotation": "pathlib.Path | str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_step(self, filename: pathlib.Path | str):\n    assert str(filename).endswith(\".step\") or str(filename).endswith(\".stp\")\n    shape = self.to_occ()\n    step_writer = STEPControl_Writer()\n    step_writer.Transfer(shape, STEPControl_AsIs)\n    success = step_writer.Write(str(filename)) == IFSelect_RetDone\n    return success"
            },
            "plot": {
              "name": "plot",
              "path": "rapidcadpy.cad.Cad.plot",
              "signature": "(self, title='Sketch Extrude', bounding_box=False)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "title",
                  "annotation": null,
                  "description": null,
                  "value": "'Sketch Extrude'"
                },
                {
                  "name": "bounding_box",
                  "annotation": null,
                  "description": null,
                  "value": "False"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def plot(self, title=\"Sketch Extrude\", bounding_box=False):\n    fig = go.Figure()\n    for sketch_extrude in self.construction_history:\n        for sketch in sketch_extrude.sketch:\n            for trace in sketch.plot(return_fig=True):\n                if trace is not None:\n                    fig.add_trace(trace)\n    fig.update_layout(\n        title=title,\n        scene=dict(aspectmode=\"cube\"),\n        xaxis=dict(scaleanchor=\"y\", title=\"X Axis\"),\n        yaxis=dict(title=\"Y Axis\"),\n        showlegend=False,\n        autosize=True,\n    )\n    fig.show()"
            },
            "show_3d": {
              "name": "show_3d",
              "path": "rapidcadpy.cad.Cad.show_3d",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def show_3d(self):\n    display, start_display, add_menu, add_function_to_menu = init_display()\n    compounds = self.to_occ()\n    display.DisplayShape(compounds, color=rgb_color(0.9, 0.9, 0.9))\n    start_display()"
            },
            "from_dict": {
              "name": "from_dict",
              "path": "rapidcadpy.cad.Cad.from_dict",
              "signature": "(all_stat)",
              "description": "construct CADSequence from json data",
              "parameters": [
                {
                  "name": "all_stat",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_dict(all_stat):\n    \"\"\"construct CADSequence from json data\"\"\"\n\n    # Loop through all the sequence\n\n    sketch_seq = []\n    extrude_seq = []\n\n    for item in all_stat[\"seq\"]:\n        if item[\"type\"] == \"ExtrudeFeature\":\n            extrude_ops = Extrude.from_dict(\n                all_stat, item[\"entity\"]\n            )  # Passes the whole data and id\n            uid_pairs = extrude_ops.get_profile_uids()\n            if len(uid_pairs) == 0:\n                continue\n            extrude_seq.append(extrude_ops)\n\n            sketch_ops = Sketch.from_dict(all_stat, uid_pairs)\n            sketch_seq.append(sketch_ops)\n\n    # Combine sketch and extrude operations\n    sketch_extrude_list = []\n    for i in range(len(sketch_seq)):\n        sketch_extrude_list.append(\n            SketchExtrude(sketch=sketch_seq[i], extrude=extrude_seq[i])\n        )\n\n    return Cad(construction_sequence=sketch_extrude_list)"
            },
            "numericalize": {
              "name": "numericalize",
              "path": "rapidcadpy.cad.Cad.numericalize",
              "signature": "(self, n=256)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": "256"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def numericalize(self, n=256):\n    for sketch_extrude in self.construction_history:\n        for sketch in sketch_extrude.sketch:\n            sketch.numericalize(n)\n        sketch_extrude.extrude.numericalize(n)"
            },
            "normalize": {
              "name": "normalize",
              "path": "rapidcadpy.cad.Cad.normalize",
              "signature": "(self) -> None",
              "description": "Normalize the CAD sequence to a common scale and center",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def normalize(self) -> None:\n    \"\"\"\n    Normalize the CAD sequence to a common scale and center\n    \"\"\"\n    # find largest bounding box size\n    global_min = np.array([float(\"inf\"), float(\"inf\")])\n    global_max = np.array([-float(\"inf\"), -float(\"inf\")])\n    for sketch_extrude in self.construction_history:\n        sketch_extrude: SketchExtrude\n        bbox_max = sketch_extrude.bbox[1]\n        bbox_min = sketch_extrude.bbox[0]\n        global_max = np.maximum(global_max, bbox_max)\n        global_min = np.minimum(global_min, bbox_min)\n\n    # scale into unit cube\n    global_width = global_max[0] - global_min[0]\n    global_height = global_max[1] - global_min[1]\n    scale = 1 / max(global_width, global_height)\n\n    # global_center = (global_max + global_min) / 2\n    first_origin = self.construction_history[0].sketch[0].sketch_plane.origin\n    for sketch_extrude in self.construction_history:\n        sketch_extrude.extrude.transform(scale=scale)\n        for sketch in sketch_extrude.sketch:\n            # first center\n            sketch.sketch_plane.origin -= first_origin\n            # then scale down into unit square\n            sketch.normalize(translation=np.zeros(2), scale=scale)"
            },
            "apply_data_cleaning": {
              "name": "apply_data_cleaning",
              "path": "rapidcadpy.cad.Cad.apply_data_cleaning",
              "signature": "(self, visualize_steps=True)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "visualize_steps",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def apply_data_cleaning(self, visualize_steps=True):\n    for sketch_extrude in self.construction_history:\n        for sketch in sketch_extrude.sketch:\n            sketch.fix_start_end_points()\n    self.plot(\"After Fixing Start and End Points\") if visualize_steps else None\n    for sketch_extrude in self.construction_history:\n        for sketch in sketch_extrude.sketch:\n            sketch.remove_coincidences()\n    self.plot(\"After Removing Coincidences\") if visualize_steps else None\n    for sketch_extrude in self.construction_history:\n        for sketch in sketch_extrude.sketch:\n            sketch.order_edges()\n    self.plot(\"After Ordering Edges\") if visualize_steps else None\n    return self"
            },
            "to_png": {
              "name": "to_png",
              "path": "rapidcadpy.cad.Cad.to_png",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_png(self):\n    occ_obj = self.to_occ()\n    display, start_display, add_menu, add_function_to_menu = init_display()\n    display.DisplayShape(occ_obj, update=True)\n\n    # Set background color (optional)\n    display.Context.SetBackgroundColor(rgb_color(1.0, 1.0, 1.0))  # White background\n\n    # Fit view and render\n    display.FitAll()\n    display.View.MustBeResized()\n    display.Context.UpdateCurrentViewer()\n\n    # Create an image and dump the view\n    img = Image_AlienPixMap()\n    width, height = 800, 600\n    img.InitTrash(width, height, True)\n    display.View.Dump(img, width, height)\n\n    # Save to file\n    output_path = \"box_render.png\"\n    img.Save(output_path)"
            },
            "render_3d": {
              "name": "render_3d",
              "path": "rapidcadpy.cad.Cad.render_3d",
              "signature": "(self, title=None)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "title",
                  "annotation": "Optional[str]",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def render_3d(self, title: Optional[str] = None):\n    import io\n\n    import cairosvg\n    from matplotlib import pyplot as plt\n    from PIL import Image\n\n    parts = self.to_occ()\n    from scripts.visualization.visualize_output import render_result\n\n    render_result(parts, file_name=\"temp.svg\")\n\n    # Convert the SVG to PNG bytes\n    png_bytes = cairosvg.svg2png(\n        file_obj=open(\"temp.svg\", \"rb\"),  # Open in binary mode\n        dpi=300,\n    )\n\n    # Use BytesIO to convert bytes to a file-like object\n    image_stream = io.BytesIO(png_bytes)\n\n    # Open the image using PIL\n    image = Image.open(image_stream)\n\n    # Convert the image to a NumPy array\n    image_array = np.array(image)\n\n    # Display the image using imshow\n    plt.imshow(image_array)\n    plt.axis(\"off\")  # Turn off the axis\n    if title:\n        plt.title(title)\n    plt.show()  # Show the image\n\n    return png_bytes"
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.cad.Cad.to_json",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self):\n    return {\n        \"seq\": [\n            s.to_json(index=i) for i, s in enumerate(self.construction_history)\n        ],\n    }"
            },
            "from_json": {
              "name": "from_json",
              "path": "rapidcadpy.cad.Cad.from_json",
              "signature": "(json_data)",
              "description": null,
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_json(json_data):\n    seq = []\n    for i, sketch_extrude in enumerate(json_data[\"seq\"]):\n        sketch = Sketch.from_json(sketch_extrude[\"sketch\"])\n        extrude = Extrude.from_json(sketch_extrude[\"extrude\"])\n        seq.append(SketchExtrude(sketch=sketch, extrude=extrude))\n    return Cad(construction_sequence=seq)"
            },
            "to_python": {
              "name": "to_python",
              "path": "rapidcadpy.cad.Cad.to_python",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_python(self):\n    sketch_extrude_code = \"\"\n    for i, sketch_extrude in enumerate(self.construction_history):\n        sketch_extrude_code += \"\\n\" + sketch_extrude.to_python(index=i)\n\n    cs = sketch_extrude_code\n    cs_variables = \", \".join(\n        [f\"sketch_extrude_{i}\" for i in range(len(self.construction_history))]\n    )\n    cs += f\"\\ncad = Cad([{cs_variables}])\\n\"\n    return cs"
            },
            "to_build123d": {
              "name": "to_build123d",
              "path": "rapidcadpy.cad.Cad.to_build123d",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_build123d(self):\n    from build123d import Compound\n\n    parts = []\n    from build123d import extrude\n\n    for i, sketch_extrude in enumerate(self.construction_history):\n        sketch_extrude: SketchExtrude\n        build123d_face = sketch_extrude.sketch[0].to_build123d()\n        parts.append(\n            extrude(\n                to_extrude=build123d_face,\n                amount=sketch_extrude.extrude.extent_one,\n                both=False,\n                dir=sketch_extrude.sketch[0].sketch_plane.z_dir,\n                taper=sketch_extrude.extrude.taper_angle_one,\n            )\n        )\n    return Compound(parts)"
            },
            "to_svg": {
              "name": "to_svg",
              "path": "rapidcadpy.cad.Cad.to_svg",
              "signature": "(self, file_name=None)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "file_name",
                  "annotation": "Optional[str]",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_svg(self, file_name: Optional[str] = None):\n    import cairosvg\n    from scripts.visualization.visualize_output import render_result\n\n    shape = self.to_build123d()\n    render_result(shape, file_name=\"temp.svg\")\n\n    # Convert the SVG to PNG bytes\n    png_bytes = cairosvg.svg2png(\n        file_obj=open(\"temp.svg\", \"rb\"),  # Open in binary mode\n        dpi=300,\n    )\n\n    # Use BytesIO to convert bytes to a file-like object\n    image_stream = io.BytesIO(png_bytes)\n\n    # Open the image using PIL\n    image = Image.open(image_stream)\n\n    # Convert the image to a NumPy array\n    image_array = np.array(image)\n\n    # Display the image using imshow\n    plt.imshow(image_array)\n    plt.axis(\"off\")  # Turn off the axis\n    plt.show()  # Show the image\n\n    return png_bytes"
            },
            "denumericalize": {
              "name": "denumericalize",
              "path": "rapidcadpy.cad.Cad.denumericalize",
              "signature": "(self, n=256)",
              "description": "Reverse the numericalization process by dividing all numericalized values by n.\nThis should be called after numericalize() to restore the original values.\n\nArgs:\n    n: The same normalization factor used in numericalize() (default: 256)",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": "256"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def denumericalize(self, n=256):\n    \"\"\"\n    Reverse the numericalization process by dividing all numericalized values by n.\n    This should be called after numericalize() to restore the original values.\n\n    Args:\n        n: The same normalization factor used in numericalize() (default: 256)\n    \"\"\"\n    for sketch_extrude in self.construction_history:\n        for sketch in sketch_extrude.sketch:\n            if hasattr(sketch, \"denumericalize\"):\n                sketch.denumericalize(n)\n            else:\n                # Fallback in case sketch doesn't have denumericalize method\n                sketch.numericalize(1)  # Reset to unnormalized values\n\n        if hasattr(sketch_extrude.extrude, \"denumericalize\"):\n            sketch_extrude.extrude.denumericalize(n)\n        else:\n            # Fallback in case extrude doesn't have denumericalize method\n            sketch_extrude.extrude.numericalize(1)  # Reset to unnormalized values"
            },
            "round": {
              "name": "round",
              "path": "rapidcadpy.cad.Cad.round",
              "signature": "(self, decimals=6)",
              "description": "Round all float values in the CAD object and its children to the specified number of decimal places.\n\nArgs:\n    decimals: Number of decimal places to round to (default: 6)",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "decimals",
                  "annotation": "int",
                  "description": null,
                  "value": "6"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def round(self, decimals: int = 6):\n    \"\"\"\n    Round all float values in the CAD object and its children to the specified number of decimal places.\n\n    Args:\n        decimals: Number of decimal places to round to (default: 6)\n    \"\"\"\n    for sketch_extrude in self.construction_history:\n        # Round sketch extrude parameters\n        if hasattr(sketch_extrude.extrude, \"extent_one\"):\n            sketch_extrude.extrude.extent_one = round(\n                sketch_extrude.extrude.extent_one, decimals\n            )\n        if hasattr(sketch_extrude.extrude, \"extent_two\"):\n            sketch_extrude.extrude.extent_two = round(\n                sketch_extrude.extrude.extent_two, decimals\n            )\n        if hasattr(sketch_extrude.extrude, \"direction\"):\n            sketch_extrude.extrude.direction = round(\n                sketch_extrude.extrude.direction, decimals\n            )\n\n        for sketch in sketch_extrude.sketch:\n            # Round sketch plane parameters\n            if hasattr(sketch.sketch_plane, \"origin\"):\n                sketch.sketch_plane.origin.round(decimals)\n            if hasattr(sketch.sketch_plane, \"x_dir\"):\n                sketch.sketch_plane.x_dir.round(decimals)\n            if hasattr(sketch.sketch_plane, \"y_dir\"):\n                sketch.sketch_plane.y_dir.round(decimals)\n            if hasattr(sketch.sketch_plane, \"z_dir\"):\n                sketch.sketch_plane.z_dir.round(decimals)\n\n            # Round wires and curves\n            if hasattr(sketch, \"outer_wire\") and sketch.outer_wire is not None:\n                self._round_wire(sketch.outer_wire, decimals)\n\n            if hasattr(sketch, \"inner_wires\") and sketch.inner_wires is not None:\n                for wire in sketch.inner_wires:\n                    self._round_wire(wire, decimals)\n\n    # Round bounding box if it exists\n    if self.bbox is not None:\n        self.bbox = np.round_(self.bbox, decimals)"
            },
            "_round_wire": {
              "name": "_round_wire",
              "path": "rapidcadpy.cad.Cad._round_wire",
              "signature": "(self, wire, decimals)",
              "description": "Helper method to round all points in a wire's edges.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "wire",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "decimals",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _round_wire(self, wire, decimals):\n    \"\"\"Helper method to round all points in a wire's edges.\"\"\"\n    for edge in wire.edges:\n        if hasattr(edge, \"start_point\"):\n            edge.start_point.round(decimals)\n        if hasattr(edge, \"end_point\"):\n            edge.end_point.round(decimals)\n\n        if hasattr(edge, \"mid_point\"):\n            edge.mid_point.round(decimals)\n\n        if hasattr(edge, \"center\"):\n            edge.center.round(decimals)\n\n        if hasattr(edge, \"radius\"):\n            edge.radius = round(edge.radius, decimals)"
            },
            "add_machining_feature_json": {
              "name": "add_machining_feature_json",
              "path": "rapidcadpy.cad.Cad.add_machining_feature_json",
              "signature": "(self, mf_json)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "mf_json",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def add_machining_feature_json(self, mf_json):\n    for index, mf in enumerate(mf_json):\n        cad_operations = mf[\"CAD Operations\"]\n        parameters = mf[\"Dimensions\"]\n        feature_name = mf[\"Feature\"]\n        if feature_name.contains(\"Parallel Keyway\"):\n            for cad_operation in cad_operations:\n                if cad_operation.startswith(\"Extrusion\"):\n                    extrude_index = int(cad_operation[len(\"Extrusion\") :])"
            }
          },
          "source": "class Cad:\n    def __init__(\n        self, construction_sequence: List[Feature], bounding_box: Optional[Any] = None\n    ):\n        self.construction_history = construction_sequence\n        self.bbox = bounding_box\n\n    def __str__(self):\n        construction_hist_str = \"\\n\".join(\n            [\n                str(sketch_extrude)\n                for i, sketch_extrude in enumerate(self.construction_history)\n            ]\n        )\n        return construction_hist_str\n\n    @staticmethod\n    def create_edge_3d(curve, sketch_plane: Plane):\n        \"\"\"create a 3D edge\"\"\"\n        from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeEdge\n        from OCC.Core.GC import GC_MakeArcOfCircle\n        from OCC.Core.gp import gp_Ax2, gp_Circ, gp_Dir\n\n        if isinstance(curve, Line):\n            if np.allclose(curve.start_point, curve.end_point):\n                return -1\n\n            # translate to global coordinates\n            start_point = (\n                curve.start_point.x * sketch_plane.x_dir\n                + curve.start_point.y * sketch_plane.y_dir\n            ) + sketch_plane.origin\n            end_point = (\n                curve.end_point.x * sketch_plane.x_dir\n                + curve.end_point.y * sketch_plane.y_dir\n            ) + sketch_plane.origin\n\n            start_point = gp_Pnt(*start_point)\n            end_point = gp_Pnt(*end_point)\n\n            topo_edge = BRepBuilderAPI_MakeEdge(start_point, end_point)\n        elif isinstance(curve, Circle):\n            center = (\n                curve.center.x * sketch_plane.x_dir\n                + curve.center.y * sketch_plane.y_dir\n                + sketch_plane.origin\n            )\n            center = gp_Pnt(*center)\n            axis = gp_Dir(*[float(v) for v in sketch_plane.z_dir])\n            gp_circle = gp_Circ(gp_Ax2(center, axis), abs(float(curve.radius)))\n            topo_edge = BRepBuilderAPI_MakeEdge(gp_circle)\n        elif isinstance(curve, Arc):\n            start_point = (\n                curve.start_point.x * sketch_plane.x_dir\n                + curve.start_point.y * sketch_plane.y_dir\n            ) + sketch_plane.origin\n            end_point = (\n                curve.end_point.x * sketch_plane.x_dir\n                + curve.end_point.y * sketch_plane.y_dir\n            ) + sketch_plane.origin\n            mid_point = (\n                curve.mid_point.x * sketch_plane.x_dir\n                + curve.mid_point.y * sketch_plane.y_dir\n            ) + sketch_plane.origin\n\n            start_point = gp_Pnt(*start_point)\n            mid_point = gp_Pnt(*mid_point)\n            end_point = gp_Pnt(*end_point)\n            arc = GC_MakeArcOfCircle(start_point, mid_point, end_point).Value()\n\n            topo_edge = BRepBuilderAPI_MakeEdge(arc)\n        else:\n            raise NotImplementedError(type(curve))\n        return topo_edge.Edge()\n\n    @staticmethod\n    def _create_profile_face(outer_wire, inner_wires: List[TopoDS_Wire] = None):\n        \"\"\"create a face from a sketch profile and the sketch plane\"\"\"\n        from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeFace\n\n        topo_face = BRepBuilderAPI_MakeFace(outer_wire)\n        if inner_wires:\n            for inner_wire in inner_wires:\n                topo_face.Add(inner_wire.Reversed())\n        return topo_face.Face()\n\n    @staticmethod\n    def _create_loop_3d(outer_wire: Wire, sketch_plane: Plane) -> TopoDS_Wire:\n        \"\"\"create a 3D sketch loop\"\"\"\n        from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeWire\n        from OCC.Core.ShapeFix import ShapeFix_Wire\n\n        topo_wire = BRepBuilderAPI_MakeWire()\n        for edge in outer_wire.edges:\n            topo_edge = Cad.create_edge_3d(edge, sketch_plane)\n            if topo_edge == -1:  # omitted\n                continue\n            topo_wire.Add(topo_edge)\n        wire = topo_wire.Wire()\n\n        fixer = ShapeFix_Wire()\n        fixer.Load(wire)\n        fixer.FixReorder()  # Reorder edges\n        fixer.FixConnected()  # Ensure continuity\n        fixer.FixClosed()  # Ensure closure\n        fixer.Perform()\n\n        return fixer.Wire()\n\n    @staticmethod\n    def _create_by_extrude(sk_ex: SketchExtrude):\n        from OCC.Core.BRepAlgoAPI import BRepAlgoAPI_Fuse\n        from OCC.Core.BRepPrimAPI import BRepPrimAPI_MakePrism\n        from OCC.Core.gp import gp_Vec\n\n        \"\"\"create a solid body from Extrude instance.\"\"\"\n        bodies = []\n        for sketch in sk_ex.sketch:\n            outer_wire = copy(sketch.outer_wire)\n            sketch_plane = copy(sketch.sketch_plane)\n            sketch_plane.origin = sketch.sketch_plane.origin\n            try:\n                outer_wire = Cad._create_loop_3d(outer_wire, sketch_plane)\n                inner_wires: List[TopoDS_Wire] = []\n                for inner_wire in sketch.inner_wires:\n                    inner_wires.append(Cad._create_loop_3d(inner_wire, sketch_plane))\n                face = Cad._create_profile_face(outer_wire, inner_wires)\n\n                normal = gp_Dir(\n                    *[float(v) * sk_ex.extrude.direction for v in sketch_plane.z_dir]\n                )\n\n                ext_vec = gp_Vec(normal).Multiplied(float(sk_ex.extrude.extent_one))\n\n                body = BRepPrimAPI_MakePrism(face, ext_vec).Shape()\n                bodies.append(body)\n            except RuntimeError:\n                continue\n\n        # fuse bodies into one\n        if len(bodies) > 1:\n            body = bodies[0]\n            for b in bodies[1:]:\n                body = BRepAlgoAPI_Fuse(body, b).Shape()\n        elif len(bodies) == 1:\n            body = bodies[0]\n        else:\n            return None\n\n        return body\n\n    def to_occ(self):\n        from OCC.Core.BRepAlgoAPI import (\n            BRepAlgoAPI_Common,\n            BRepAlgoAPI_Cut,\n            BRepAlgoAPI_Fuse,\n        )\n\n        bodies = []\n        for sk_ex in self.construction_history:\n            body = Cad._create_by_extrude(sk_ex)\n            if body is not None:\n                bodies.append(body)\n\n        if len(bodies) == 0:\n            return None\n        elif len(bodies) == 1:\n            return bodies[0]\n        else:\n            # fuse all bodies\n            result = bodies[0]\n            for body in bodies[1:]:\n                if (\n                    sk_ex.extrude.operation == \"NewBodyFeatureOperation\"\n                    or sk_ex.extrude.operation == \"JoinFeatureOperation\"\n                ):\n                    result = BRepAlgoAPI_Fuse(result, body).Shape()\n                elif sk_ex.extrude.operation == \"CutFeatureOperation\":\n                    result = BRepAlgoAPI_Cut(result, body).Shape()\n                elif sk_ex.extrude.operation == \"IntersectFeatureOperation\":\n                    result = BRepAlgoAPI_Common(result, body).Shape()\n            return result\n\n    def to_step(self, filename: pathlib.Path | str):\n        assert str(filename).endswith(\".step\") or str(filename).endswith(\".stp\")\n        shape = self.to_occ()\n        step_writer = STEPControl_Writer()\n        step_writer.Transfer(shape, STEPControl_AsIs)\n        success = step_writer.Write(str(filename)) == IFSelect_RetDone\n        return success\n\n    def plot(self, title=\"Sketch Extrude\", bounding_box=False):\n        fig = go.Figure()\n        for sketch_extrude in self.construction_history:\n            for sketch in sketch_extrude.sketch:\n                for trace in sketch.plot(return_fig=True):\n                    if trace is not None:\n                        fig.add_trace(trace)\n        fig.update_layout(\n            title=title,\n            scene=dict(aspectmode=\"cube\"),\n            xaxis=dict(scaleanchor=\"y\", title=\"X Axis\"),\n            yaxis=dict(title=\"Y Axis\"),\n            showlegend=False,\n            autosize=True,\n        )\n        fig.show()\n\n    def show_3d(self):\n        display, start_display, add_menu, add_function_to_menu = init_display()\n        compounds = self.to_occ()\n        display.DisplayShape(compounds, color=rgb_color(0.9, 0.9, 0.9))\n        start_display()\n\n    @staticmethod\n    def from_dict(all_stat):\n        \"\"\"construct CADSequence from json data\"\"\"\n\n        # Loop through all the sequence\n\n        sketch_seq = []\n        extrude_seq = []\n\n        for item in all_stat[\"seq\"]:\n            if item[\"type\"] == \"ExtrudeFeature\":\n                extrude_ops = Extrude.from_dict(\n                    all_stat, item[\"entity\"]\n                )  # Passes the whole data and id\n                uid_pairs = extrude_ops.get_profile_uids()\n                if len(uid_pairs) == 0:\n                    continue\n                extrude_seq.append(extrude_ops)\n\n                sketch_ops = Sketch.from_dict(all_stat, uid_pairs)\n                sketch_seq.append(sketch_ops)\n\n        # Combine sketch and extrude operations\n        sketch_extrude_list = []\n        for i in range(len(sketch_seq)):\n            sketch_extrude_list.append(\n                SketchExtrude(sketch=sketch_seq[i], extrude=extrude_seq[i])\n            )\n\n        return Cad(construction_sequence=sketch_extrude_list)\n\n    def numericalize(self, n=256):\n        for sketch_extrude in self.construction_history:\n            for sketch in sketch_extrude.sketch:\n                sketch.numericalize(n)\n            sketch_extrude.extrude.numericalize(n)\n\n    def normalize(self) -> None:\n        \"\"\"\n        Normalize the CAD sequence to a common scale and center\n        \"\"\"\n        # find largest bounding box size\n        global_min = np.array([float(\"inf\"), float(\"inf\")])\n        global_max = np.array([-float(\"inf\"), -float(\"inf\")])\n        for sketch_extrude in self.construction_history:\n            sketch_extrude: SketchExtrude\n            bbox_max = sketch_extrude.bbox[1]\n            bbox_min = sketch_extrude.bbox[0]\n            global_max = np.maximum(global_max, bbox_max)\n            global_min = np.minimum(global_min, bbox_min)\n\n        # scale into unit cube\n        global_width = global_max[0] - global_min[0]\n        global_height = global_max[1] - global_min[1]\n        scale = 1 / max(global_width, global_height)\n\n        # global_center = (global_max + global_min) / 2\n        first_origin = self.construction_history[0].sketch[0].sketch_plane.origin\n        for sketch_extrude in self.construction_history:\n            sketch_extrude.extrude.transform(scale=scale)\n            for sketch in sketch_extrude.sketch:\n                # first center\n                sketch.sketch_plane.origin -= first_origin\n                # then scale down into unit square\n                sketch.normalize(translation=np.zeros(2), scale=scale)\n                # finally move to 0.5, 0.5\n                # sketch.normalize(translation=np.array([0.5, 0.5]), scale=1)\n\n    def apply_data_cleaning(self, visualize_steps=True):\n        for sketch_extrude in self.construction_history:\n            for sketch in sketch_extrude.sketch:\n                sketch.fix_start_end_points()\n        self.plot(\"After Fixing Start and End Points\") if visualize_steps else None\n        for sketch_extrude in self.construction_history:\n            for sketch in sketch_extrude.sketch:\n                sketch.remove_coincidences()\n        self.plot(\"After Removing Coincidences\") if visualize_steps else None\n        for sketch_extrude in self.construction_history:\n            for sketch in sketch_extrude.sketch:\n                sketch.order_edges()\n        self.plot(\"After Ordering Edges\") if visualize_steps else None\n        return self\n\n    # def to_graph_format(self, with_constraints=True) -> List[HeteroData]:\n    #     graph_data = []\n    #     for sketch_extrude in self.construction_history:\n    #         sketches = [\n    #             sketch.to_graph(with_constraints=with_constraints)\n    #             for sketch in sketch_extrude.sketch\n    #         ]\n    #         graph_data.extend(sketches)\n    #     return graph_data\n\n    # @classmethod\n    # def from_graph_format(\n    #     cls, graph_data: List[Tuple[List[HeteroData], torch.Tensor]]\n    # ) -> \"Cad\":\n    #     construction_history = []\n    #     for sketches_graph, extrude_tensor in graph_data:\n    #         sketch = [Sketch.from_graph(g) for g in sketches_graph][0]\n    #         extrude = Extrude.from_tensor(extrude_tensor)\n    #         construction_history.append(SketchExtrude(sketch=sketches, extrude=extrude))\n    #     return cls(construction_history=construction_history)\n\n    def to_png(self):\n        occ_obj = self.to_occ()\n        display, start_display, add_menu, add_function_to_menu = init_display()\n        display.DisplayShape(occ_obj, update=True)\n\n        # Set background color (optional)\n        display.Context.SetBackgroundColor(rgb_color(1.0, 1.0, 1.0))  # White background\n\n        # Fit view and render\n        display.FitAll()\n        display.View.MustBeResized()\n        display.Context.UpdateCurrentViewer()\n\n        # Create an image and dump the view\n        img = Image_AlienPixMap()\n        width, height = 800, 600\n        img.InitTrash(width, height, True)\n        display.View.Dump(img, width, height)\n\n        # Save to file\n        output_path = \"box_render.png\"\n        img.Save(output_path)\n\n    def render_3d(self, title: Optional[str] = None):\n        import io\n\n        import cairosvg\n        from matplotlib import pyplot as plt\n        from PIL import Image\n\n        parts = self.to_occ()\n        from scripts.visualization.visualize_output import render_result\n\n        render_result(parts, file_name=\"temp.svg\")\n\n        # Convert the SVG to PNG bytes\n        png_bytes = cairosvg.svg2png(\n            file_obj=open(\"temp.svg\", \"rb\"),  # Open in binary mode\n            dpi=300,\n        )\n\n        # Use BytesIO to convert bytes to a file-like object\n        image_stream = io.BytesIO(png_bytes)\n\n        # Open the image using PIL\n        image = Image.open(image_stream)\n\n        # Convert the image to a NumPy array\n        image_array = np.array(image)\n\n        # Display the image using imshow\n        plt.imshow(image_array)\n        plt.axis(\"off\")  # Turn off the axis\n        if title:\n            plt.title(title)\n        plt.show()  # Show the image\n\n        return png_bytes\n\n    def to_json(self):\n        return {\n            \"seq\": [\n                s.to_json(index=i) for i, s in enumerate(self.construction_history)\n            ],\n        }\n\n    @staticmethod\n    def from_json(json_data):\n        seq = []\n        for i, sketch_extrude in enumerate(json_data[\"seq\"]):\n            sketch = Sketch.from_json(sketch_extrude[\"sketch\"])\n            extrude = Extrude.from_json(sketch_extrude[\"extrude\"])\n            seq.append(SketchExtrude(sketch=sketch, extrude=extrude))\n        return Cad(construction_sequence=seq)\n\n    def to_python(self):\n        sketch_extrude_code = \"\"\n        for i, sketch_extrude in enumerate(self.construction_history):\n            sketch_extrude_code += \"\\n\" + sketch_extrude.to_python(index=i)\n\n        cs = sketch_extrude_code\n        cs_variables = \", \".join(\n            [f\"sketch_extrude_{i}\" for i in range(len(self.construction_history))]\n        )\n        cs += f\"\\ncad = Cad([{cs_variables}])\\n\"\n        return cs\n\n    def to_build123d(self):\n        from build123d import Compound\n\n        parts = []\n        from build123d import extrude\n\n        for i, sketch_extrude in enumerate(self.construction_history):\n            sketch_extrude: SketchExtrude\n            build123d_face = sketch_extrude.sketch[0].to_build123d()\n            parts.append(\n                extrude(\n                    to_extrude=build123d_face,\n                    amount=sketch_extrude.extrude.extent_one,\n                    both=False,\n                    dir=sketch_extrude.sketch[0].sketch_plane.z_dir,\n                    taper=sketch_extrude.extrude.taper_angle_one,\n                )\n            )\n        return Compound(parts)\n\n    def to_svg(self, file_name: Optional[str] = None):\n        import cairosvg\n        from scripts.visualization.visualize_output import render_result\n\n        shape = self.to_build123d()\n        render_result(shape, file_name=\"temp.svg\")\n\n        # Convert the SVG to PNG bytes\n        png_bytes = cairosvg.svg2png(\n            file_obj=open(\"temp.svg\", \"rb\"),  # Open in binary mode\n            dpi=300,\n        )\n\n        # Use BytesIO to convert bytes to a file-like object\n        image_stream = io.BytesIO(png_bytes)\n\n        # Open the image using PIL\n        image = Image.open(image_stream)\n\n        # Convert the image to a NumPy array\n        image_array = np.array(image)\n\n        # Display the image using imshow\n        plt.imshow(image_array)\n        plt.axis(\"off\")  # Turn off the axis\n        plt.show()  # Show the image\n\n        return png_bytes\n\n    def denumericalize(self, n=256):\n        \"\"\"\n        Reverse the numericalization process by dividing all numericalized values by n.\n        This should be called after numericalize() to restore the original values.\n\n        Args:\n            n: The same normalization factor used in numericalize() (default: 256)\n        \"\"\"\n        for sketch_extrude in self.construction_history:\n            for sketch in sketch_extrude.sketch:\n                if hasattr(sketch, \"denumericalize\"):\n                    sketch.denumericalize(n)\n                else:\n                    # Fallback in case sketch doesn't have denumericalize method\n                    sketch.numericalize(1)  # Reset to unnormalized values\n\n            if hasattr(sketch_extrude.extrude, \"denumericalize\"):\n                sketch_extrude.extrude.denumericalize(n)\n            else:\n                # Fallback in case extrude doesn't have denumericalize method\n                sketch_extrude.extrude.numericalize(1)  # Reset to unnormalized values\n\n    def round(self, decimals: int = 6):\n        \"\"\"\n        Round all float values in the CAD object and its children to the specified number of decimal places.\n\n        Args:\n            decimals: Number of decimal places to round to (default: 6)\n        \"\"\"\n        for sketch_extrude in self.construction_history:\n            # Round sketch extrude parameters\n            if hasattr(sketch_extrude.extrude, \"extent_one\"):\n                sketch_extrude.extrude.extent_one = round(\n                    sketch_extrude.extrude.extent_one, decimals\n                )\n            if hasattr(sketch_extrude.extrude, \"extent_two\"):\n                sketch_extrude.extrude.extent_two = round(\n                    sketch_extrude.extrude.extent_two, decimals\n                )\n            if hasattr(sketch_extrude.extrude, \"direction\"):\n                sketch_extrude.extrude.direction = round(\n                    sketch_extrude.extrude.direction, decimals\n                )\n\n            for sketch in sketch_extrude.sketch:\n                # Round sketch plane parameters\n                if hasattr(sketch.sketch_plane, \"origin\"):\n                    sketch.sketch_plane.origin.round(decimals)\n                if hasattr(sketch.sketch_plane, \"x_dir\"):\n                    sketch.sketch_plane.x_dir.round(decimals)\n                if hasattr(sketch.sketch_plane, \"y_dir\"):\n                    sketch.sketch_plane.y_dir.round(decimals)\n                if hasattr(sketch.sketch_plane, \"z_dir\"):\n                    sketch.sketch_plane.z_dir.round(decimals)\n\n                # Round wires and curves\n                if hasattr(sketch, \"outer_wire\") and sketch.outer_wire is not None:\n                    self._round_wire(sketch.outer_wire, decimals)\n\n                if hasattr(sketch, \"inner_wires\") and sketch.inner_wires is not None:\n                    for wire in sketch.inner_wires:\n                        self._round_wire(wire, decimals)\n\n        # Round bounding box if it exists\n        if self.bbox is not None:\n            self.bbox = np.round_(self.bbox, decimals)\n\n    def _round_wire(self, wire, decimals):\n        \"\"\"Helper method to round all points in a wire's edges.\"\"\"\n        for edge in wire.edges:\n            if hasattr(edge, \"start_point\"):\n                edge.start_point.round(decimals)\n            if hasattr(edge, \"end_point\"):\n                edge.end_point.round(decimals)\n\n            if hasattr(edge, \"mid_point\"):\n                edge.mid_point.round(decimals)\n\n            if hasattr(edge, \"center\"):\n                edge.center.round(decimals)\n\n            if hasattr(edge, \"radius\"):\n                edge.radius = round(edge.radius, decimals)\n\n    def add_machining_feature_json(self, mf_json):\n        for index, mf in enumerate(mf_json):\n            cad_operations = mf[\"CAD Operations\"]\n            parameters = mf[\"Dimensions\"]\n            feature_name = mf[\"Feature\"]\n            if feature_name.contains(\"Parallel Keyway\"):\n                for cad_operation in cad_operations:\n                    if cad_operation.startswith(\"Extrusion\"):\n                        extrude_index = int(cad_operation[len(\"Extrusion\") :])",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "sketch": {
      "name": "sketch",
      "path": "rapidcadpy.sketch",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/sketch.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "log",
          "annotation": null,
          "description": null,
          "value": "logging.getLogger(__name__)"
        }
      ],
      "modules": {},
      "classes": {
        "Sketch": {
          "name": "Sketch",
          "path": "rapidcadpy.sketch.Sketch",
          "description": "This class encapsulates a sketch instance.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "outer_wire",
              "annotation": "Wire",
              "description": null,
              "value": null
            },
            {
              "name": "inner_wires",
              "annotation": "Optional[List[Wire]]",
              "description": null,
              "value": "list()"
            },
            {
              "name": "constraints",
              "annotation": "Optional[List[Constraint]]",
              "description": null,
              "value": "list()"
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "uuid.uuid4()"
            },
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": "'Sketch'"
            }
          ],
          "attributes": [
            {
              "name": "outer_wire",
              "annotation": "Wire",
              "description": null,
              "value": null
            },
            {
              "name": "inner_wires",
              "annotation": "Optional[List[Wire]]",
              "description": null,
              "value": "field(default_factory=list)"
            },
            {
              "name": "constraints",
              "annotation": "Optional[List[Constraint]]",
              "description": null,
              "value": "field(default_factory=list)"
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "field(default=(uuid.uuid4()))"
            },
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": "'Sketch'"
            },
            {
              "name": "start_point",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "end_point",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "bbox",
              "annotation": null,
              "description": [
                {
                  "kind": "text",
                  "value": "compute bounding box (min/max points) of the sketch"
                }
              ],
              "value": null
            },
            {
              "name": "bbox_size",
              "annotation": null,
              "description": [
                {
                  "kind": "text",
                  "value": "compute bounding box size (max of height and width)"
                }
              ],
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.sketch.Sketch.__str__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self):\n    return \"\\n\\t\".join([str(edge) for edge in self.outer_wire.edges])"
            },
            "__post_init__": {
              "name": "__post_init__",
              "path": "rapidcadpy.sketch.Sketch.__post_init__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __post_init__(self):\n    if self.id is None:\n        self.id = uuid.uuid4()"
            },
            "get_face_by_id": {
              "name": "get_face_by_id",
              "path": "rapidcadpy.sketch.Sketch.get_face_by_id",
              "signature": "(self, face_id)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "face_id",
                  "annotation": "Union[str, uuid.UUID]",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def get_face_by_id(self, face_id: Union[str, uuid.UUID]):\n    if isinstance(face_id, str):\n        face_id = uuid.UUID(face_id)\n    for face in self.faces:\n        if face.id == face_id:\n            return face\n    return None"
            },
            "plot": {
              "name": "plot",
              "path": "rapidcadpy.sketch.Sketch.plot",
              "signature": "(self, title=None, return_fig=False)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "title",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "return_fig",
                  "annotation": null,
                  "description": null,
                  "value": "False"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def plot(self, title=None, return_fig=False):\n    if return_fig:\n        return visualize_lines(\n            self.outer_wire.edges,\n            inner_edges=self.get_inner_edges(),\n            return_fig=True,\n            title=self.name,\n            plane=self.sketch_plane,\n        )\n    visualize_lines(\n        self.outer_wire.edges, inner_edges=self.get_inner_edges(), title=title\n    )"
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.sketch.Sketch.to_json",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self):\n    self.merge_coincident_vertices()\n    vertices = self.name_vertices_sequentially(variable_definitons=False)\n    return {\n        \"vertices\": {str(v.name): v.to_json() for v in vertices},\n        \"outer_edges\": [\n            e.to_json(dereferenced=True) for e in self.outer_wire.edges\n        ],\n        \"inner_edges\": [\n            [e.to_json(dereferenced=True) for e in w.edges]\n            for w in self.inner_wires or []\n        ],\n        \"constraints\": [c.to_json() for c in self.constraints or [] if c],\n    }"
            },
            "from_json": {
              "name": "from_json",
              "path": "rapidcadpy.sketch.Sketch.from_json",
              "signature": "(data)",
              "description": null,
              "parameters": [
                {
                  "name": "data",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_json(data):\n    outer_wire_edges = []\n    edge_dict = {}\n    for edge_data in data[\"outer_edges\"]:\n        if edge_data[\"type\"] == \"Line\":\n            edge = Line.from_json(edge_data)\n        elif edge_data[\"type\"] == \"Circle\":\n            edge = Circle.from_json(edge_data)\n        elif edge_data[\"type\"] == \"Arc\":\n            edge = Arc.from_json(edge_data)\n        outer_wire_edges.append(edge)\n\n    inner_wires = []\n    for inner_edge in data[\"inner_edges\"]:\n        inner_wire_edges = []\n        for edge_data in inner_edge:\n            if edge_data[\"type\"] == \"Line\":\n                edge = Line.from_json(edge_data)\n            elif edge_data[\"type\"] == \"Circle\":\n                edge = Circle.from_json(edge_data)\n            elif edge_data[\"type\"] == \"Arc\":\n                edge = Arc.from_json(edge_data)\n            inner_wire_edges.append(edge)\n        inner_wires.append(Wire(inner_wire_edges))\n\n    return Sketch(\n        outer_wire=Wire(edges=outer_wire_edges),\n        inner_wires=inner_wires,\n        sketch_plane=Plane.from_json(data[\"sketch_plane\"]),\n    )"
            },
            "from_dict": {
              "name": "from_dict",
              "path": "rapidcadpy.sketch.Sketch.from_dict",
              "signature": "(all_stat, profile_uid_list)",
              "description": null,
              "parameters": [
                {
                  "name": "all_stat",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "profile_uid_list",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_dict(all_stat, profile_uid_list):\n    facedata = []\n    plane = Plane.from_dict(\n        all_stat[\"entities\"][profile_uid_list[0][0]][\"transform\"]\n    )\n\n    for i in range(len(profile_uid_list)):\n        sketch_entity = all_stat[\"entities\"][profile_uid_list[i][0]]\n        facedata.append(\n            FaceSequence.from_dict(sketch_entity, profile_uid_list[i][1])\n        )\n\n    return Sketch(facedata=facedata, sketch_plane=plane, reorder=True)"
            },
            "_order_edges": {
              "name": "_order_edges",
              "path": "rapidcadpy.sketch.Sketch._order_edges",
              "signature": "(self, edges)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "edges",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _order_edges(self, edges):\n    if any(isinstance(edge, Circle) for edge in edges):\n        return edges\n    log.debug(f\"### Ordering Edges {len(edges)}\")\n    num_edges_before = len(edges)\n\n    # Create mappings from vertices to edges\n    start_to_edge: Dict[Vertex, List[Union[Line, Arc]]] = defaultdict(list)\n    end_to_edge: Dict[Vertex, List[Union[Line, Arc]]] = defaultdict(list)\n\n    for edge in edges:\n        start_to_edge[edge.start_point].append(edge)\n        end_to_edge[edge.end_point].append(edge)\n\n    # Choose starting edge\n    start_edge = edges[0]\n\n    # remove the start edge from the mappings\n    start_to_edge[start_edge.start_point].remove(start_edge)\n    end_to_edge[start_edge.end_point].remove(start_edge)\n\n    # Build the ordered list of xedges\n    ordered_edges = []\n    current_edge = start_edge\n\n    while len(start_to_edge) + len(end_to_edge) > 0:\n        ordered_edges.append(current_edge)\n        log.debug(\"\\t\\tCurrent Edge: %s\", current_edge)\n        log.debug(\"\\t\\tRemaining Start To Edge: %s\", start_to_edge)\n        log.debug(\"\\t\\tRemaining End To Edge: %s\", end_to_edge)\n\n        if current_edge.end_point in start_to_edge:\n            log.debug(\"\\t\\t1 End Point in Start to Edge\")\n            current_edge = start_to_edge[current_edge.end_point].pop(0)\n            end_to_edge[current_edge.end_point].remove(current_edge)\n        elif current_edge.start_point in end_to_edge:\n            log.debug(\"\\t\\t2 Start Point in End to Edge\")\n            current_edge = end_to_edge[current_edge.start_point].pop(0)\n            start_to_edge[current_edge.start_point].remove(current_edge)\n        elif current_edge.end_point in end_to_edge:\n            log.debug(\"\\t\\t3 Flipping Edge\")\n            # Add flipped edge\n            current_edge = end_to_edge[current_edge.end_point].pop(0)\n            start_to_edge[current_edge.start_point].remove(current_edge)\n            # Reverse flip to delete the old edge\n            current_edge.flip()\n        elif current_edge.start_point in start_to_edge:\n            log.debug(\"\\t\\t4 Flipping Edge\")\n            # Add flipped edge\n            current_edge = start_to_edge[current_edge.start_point].pop(0)\n            end_to_edge[current_edge.end_point].remove(current_edge)\n            current_edge.flip()\n            log.debug(len(end_to_edge) + len(start_to_edge))\n        else:\n            log.debug(\"\\t\\t4 No Connected Edges\")\n            break\n\n        # remove empty lists from dict\n        start_to_edge = {k: v for k, v in start_to_edge.items() if v}\n        end_to_edge = {k: v for k, v in end_to_edge.items() if v}\n\n    # Add the last edge\n    ordered_edges.append(current_edge)\n\n    if len(ordered_edges) != num_edges_before:\n        log.error(\n            f\"Number of edges before {num_edges_before} is not equal to number of ordered edges {len(ordered_edges)}\"\n        )\n\n    return ordered_edges"
            },
            "order_edges": {
              "name": "order_edges",
              "path": "rapidcadpy.sketch.Sketch.order_edges",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def order_edges(self):\n    self._order_edges(self.outer_wire.edges)\n    for wire in self.inner_wires:\n        wire.edges = self._order_edges(wire.edges)"
            },
            "get_inner_edges": {
              "name": "get_inner_edges",
              "path": "rapidcadpy.sketch.Sketch.get_inner_edges",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def get_inner_edges(self):\n    if len(self.inner_wires) == 0:\n        return []\n    return [edge for wire in self.inner_wires for edge in wire.edges]"
            },
            "_point_on_line": {
              "name": "_point_on_line",
              "path": "rapidcadpy.sketch.Sketch._point_on_line",
              "signature": "(point, line, tolerance=1e-05) -> bool",
              "description": null,
              "parameters": [
                {
                  "name": "point",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "line",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "tolerance",
                  "annotation": "float",
                  "description": null,
                  "value": "1e-05"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bool",
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef _point_on_line(point, line, tolerance: float = 1e-5) -> bool:\n    # check if point is somewhere on the line\n    x = point.x\n    y = point.y\n    x1 = line.start_point.x\n    y1 = line.start_point.y\n    x2 = line.end_point.x\n    y2 = line.end_point.y\n\n    cross_product = (y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)\n\n    # The point is not collinear with the line segment\n    if abs(cross_product) > tolerance:\n        return False\n\n    # Check if the point is within the bounding box of the line segment\n    return (\n        min(x1, x2) - tolerance <= x <= max(x1, x2) + tolerance\n        and min(y1, y2) - tolerance <= y <= max(y1, y2) + tolerance\n    )"
            },
            "_point_on_circle": {
              "name": "_point_on_circle",
              "path": "rapidcadpy.sketch.Sketch._point_on_circle",
              "signature": "(point, circle, tolerance=1e-05) -> bool",
              "description": null,
              "parameters": [
                {
                  "name": "point",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "circle",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "tolerance",
                  "annotation": "float",
                  "description": null,
                  "value": "1e-05"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bool",
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef _point_on_circle(point, circle, tolerance: float = 1e-5) -> bool:\n    # check if point is somewhere on the line\n    x = point.x\n    y = point.y\n    x1 = circle.center.x\n    y1 = circle.center.y\n    r = circle.radius\n\n    return abs((x - x1) ** 2 + (y - y1) ** 2 - r**2) < tolerance"
            },
            "fix_start_end_points": {
              "name": "fix_start_end_points",
              "path": "rapidcadpy.sketch.Sketch.fix_start_end_points",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def fix_start_end_points(self):\n    for edge in self.outer_wire.edges:\n        if isinstance(edge, Circle):\n            continue\n        lines_removed_edge = [\n            e for e in self.outer_wire.edges if e != edge and isinstance(e, Line)\n        ]\n        circles_removed_edge = [\n            e for e in self.outer_wire.edges if e != edge and isinstance(e, Circle)\n        ]\n        # Check if point1 is the point2 of another edge\n        all_other_points = [e.start_point for e in lines_removed_edge] + [\n            e.end_point for e in lines_removed_edge\n        ]\n        start_point_found = edge.start_point in all_other_points\n        end_point_found = edge.end_point in all_other_points\n\n        if not start_point_found:\n            log.debug(\"\\tEdge with disconnected start point: %s\", edge)\n            for edge2 in lines_removed_edge:\n                if self._point_on_line(point=edge2.end_point, line=edge) and any(\n                    edge2.end_point != edge.end_point\n                ):\n                    log.debug(f\"\\t6 Fixed edge {edge} -> \")\n                    edge.start_point = Vertex(\n                        x=edge2.end_point.x, y=edge2.end_point.y\n                    )\n                    log.debug(f\"\\t\\t{edge}\")\n                    break\n                if self._point_on_line(edge2.start_point, edge) and any(\n                    edge2.start_point != edge.end_point\n                ):\n                    log.debug(f\"\\t6 Fixed edge {edge} -> \")\n                    edge.start_point = Vertex(\n                        x=edge2.start_point.x, y=edge2.start_point.y\n                    )\n                    log.debug(f\"\\t\\t{edge}\")\n                    break\n            for edge2 in circles_removed_edge:\n                if self._point_on_circle(edge.start_point, edge2):\n                    log.debug(f\"\\t6.1 Start point on circle {edge2}\")\n                    break\n        if not end_point_found:\n            log.debug(\"\\tEdge with disconnected end point: %s\", edge)\n            for edge2 in lines_removed_edge:\n                if self._point_on_line(edge2.end_point, edge) and any(\n                    edge2.end_point != edge.start_point\n                ):\n                    log.debug(\"\\t7 Found connected edge: %s\", edge2)\n                    edge.end_point = Vertex(\n                        x=edge2.end_point.x, y=edge2.end_point.y\n                    )\n                    break\n                if self._point_on_line(edge2.start_point, edge) and any(\n                    edge2.start_point != edge.start_point\n                ):\n                    log.debug(\"\\t8 Found connected edge: %s\", edge2)\n                    edge.end_point = Vertex(\n                        x=edge2.start_point.x, y=edge2.start_point.y\n                    )\n            for edge2 in circles_removed_edge:\n                if self._point_on_circle(edge.end_point, edge2):\n                    log.debug(f\"\\t8.1 End point on circle {edge2}\")\n                    break"
            },
            "remove_coincidences": {
              "name": "remove_coincidences",
              "path": "rapidcadpy.sketch.Sketch.remove_coincidences",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def remove_coincidences(self):\n    # Remove coincident lines\n    edges_to_remove = set()\n    tolerance = 1e-5\n    for edge in self.outer_wire.edges:\n        if isinstance(edge, Line):\n            edges_removed = [e for e in self.outer_wire.edges if e != edge]\n            for edge2 in edges_removed:\n                if isinstance(edge2, Line):\n                    cross_product = np.cross(\n                        np.array(edge.end_point) - np.array(edge.start_point),\n                        np.array(edge2.end_point) - np.array(edge2.start_point),\n                    )\n                    # check if collinear\n                    if abs(cross_product) < tolerance:\n                        # check if edge is within the bounding box of edge2\n                        min_point = (\n                            np.minimum(edge2.start_point, edge2.end_point)\n                            - tolerance\n                        )\n                        max_point = (\n                            np.maximum(edge2.start_point, edge2.end_point)\n                            + tolerance\n                        )\n\n                        is_within_bbox = np.all(\n                            (min_point <= edge.start_point)\n                            & (edge.start_point <= max_point)\n                        )\n                        is_within_bbox = is_within_bbox and np.all(\n                            (min_point <= edge.end_point)\n                            & (edge.end_point <= max_point)\n                        )\n\n                        if is_within_bbox:\n                            edges_to_remove.add(edge)\n\n    self.outer_wire.edges = [\n        e for e in self.outer_wire.edges if e not in edges_to_remove\n    ]"
            },
            "merge_coincident_vertices": {
              "name": "merge_coincident_vertices",
              "path": "rapidcadpy.sketch.Sketch.merge_coincident_vertices",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def merge_coincident_vertices(self):\n    # Merge coincident vertices\n    for edge in self.outer_wire.edges:\n        if isinstance(edge, Line) or isinstance(edge, Arc):\n            for edge2 in self.outer_wire.edges:\n                if edge2 != edge and edge.start_point == edge2.start_point:\n                    edge.start_point = edge2.start_point\n                if edge2 != edge and edge.end_point == edge2.end_point:\n                    edge.end_point = edge2.end_point\n                if edge2 != edge and edge.start_point == edge2.end_point:\n                    edge.start_point = edge2.end_point\n                if edge2 != edge and edge.end_point == edge2.start_point:\n                    edge.end_point = edge2.start_point\n                if isinstance(edge, Arc) and isinstance(edge2, Arc):\n                    if edge.center == edge2.center:\n                        edge.center = edge2.center"
            },
            "name_vertices_sequentially": {
              "name": "name_vertices_sequentially",
              "path": "rapidcadpy.sketch.Sketch.name_vertices_sequentially",
              "signature": "(self, variable_definitons=True)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "variable_definitons",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def name_vertices_sequentially(self, variable_definitons=True):\n    vertex_index = 0\n    vertex_variable_definitions = []\n    parsed_vertices: Set[Vertex] = set()\n    not_detect_duplicates = False\n    for edge in self.outer_wire.edges + self.get_inner_edges():\n        if isinstance(edge, Line):\n            if edge.start_point not in parsed_vertices or not_detect_duplicates:\n                edge.start_point.name = f\"vertex_{vertex_index}\"\n                vertex_variable_definitions.append(\n                    f\"vertex_{vertex_index} = Vertex(x={edge.start_point.x}, y={edge.start_point.y})\"\n                )\n\n                parsed_vertices.add(edge.start_point)\n                vertex_index += 1\n            if edge.end_point not in parsed_vertices or not_detect_duplicates:\n                edge.end_point.name = f\"vertex_{vertex_index}\"\n                vertex_variable_definitions.append(\n                    f\"vertex_{vertex_index} = Vertex(x={edge.end_point.x}, y={edge.end_point.y})\"\n                )\n                parsed_vertices.add(edge.end_point)\n                vertex_index += 1\n        elif isinstance(edge, Circle):\n            if edge.center not in parsed_vertices or not_detect_duplicates:\n                edge.center.name = f\"vertex_{vertex_index}\"\n                vertex_variable_definitions.append(\n                    f\"vertex_{vertex_index} = Vertex(x={edge.center.x}, y={edge.center.y})\"\n                )\n                parsed_vertices.add(edge.center)\n                vertex_index += 1\n        elif isinstance(edge, Arc):\n            if edge.start_point not in parsed_vertices or not_detect_duplicates:\n                edge.start_point.name = f\"vertex_{vertex_index}\"\n                vertex_variable_definitions.append(\n                    f\"vertex_{vertex_index} = Vertex(x={edge.start_point.x}, y={edge.start_point.y})\"\n                )\n                parsed_vertices.add(edge.start_point)\n                vertex_index += 1\n            if edge.end_point not in parsed_vertices or not_detect_duplicates:\n                edge.end_point.name = f\"vertex_{vertex_index}\"\n                vertex_variable_definitions.append(\n                    f\"vertex_{vertex_index} = Vertex(x={edge.end_point.x}, y={edge.end_point.y})\"\n                )\n                parsed_vertices.add(edge.end_point)\n                vertex_index += 1\n            if edge.center not in parsed_vertices or not_detect_duplicates:\n                edge.center.name = f\"vertex_{vertex_index}\"\n                vertex_variable_definitions.append(\n                    f\"vertex_{vertex_index} = Vertex(x={edge.center.x}, y={edge.center.y})\"\n                )\n                parsed_vertices.add(edge.center)\n                vertex_index += 1\n\n    if variable_definitons:\n        return vertex_variable_definitions\n    return parsed_vertices"
            },
            "to_python": {
              "name": "to_python",
              "path": "rapidcadpy.sketch.Sketch.to_python",
              "signature": "(self, index=0)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "index",
                  "annotation": "Optional[int]",
                  "description": null,
                  "value": "0"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_python(self, index: Optional[int] = 0):\n    # self.merge_coincident_vertices()\n    # vertices = self.name_vertices_sequentially(variable_definitons=True)\n\n    edges = []\n    line_counter = 0\n    circle_counter = 0\n    arc_counter = 0\n\n    outer_wire_variable_names = []\n    for i, edge in enumerate(self.outer_wire.edges):\n        if isinstance(edge, Line):\n            var_name = f\"line_{line_counter}\"\n            edges.append(\n                f\"{var_name} = Line(start_point={edge.start_point.to_python()}, end_point={edge.end_point.to_python()})\"\n            )\n            outer_wire_variable_names.append(var_name)\n            line_counter += 1\n        elif isinstance(edge, Circle):\n            var_name = f\"circle_{circle_counter}\"\n            edges.append(\n                f\"{var_name} = Circle(center={edge.center.to_python()}, radius={edge.radius})\"\n            )\n            outer_wire_variable_names.append(var_name)\n            circle_counter += 1\n        elif isinstance(edge, Arc):\n            var_name = f\"arc_{arc_counter}\"\n            edges.append(f\"{var_name} = {edge.to_python()}\")\n            outer_wire_variable_names.append(var_name)\n            arc_counter += 1\n\n    outer_wire = (\n        f\"outer_wire_{index} = Wire([{', '.join(outer_wire_variable_names)}])\"\n    )\n    variables = [\"\\n\".join(edges) + \"\\n\" + outer_wire + \"\\n\"]\n\n    inner_wires_var_names = []\n    if len(self.inner_wires) > 0:\n        # Generate code for all inner wires\n        for i, inner_wire in enumerate(self.inner_wires):\n            inner_wire_edges = []\n            inner_wire_var_names = []\n            for edge in inner_wire.edges:\n                if isinstance(edge, Line):\n                    var_name = f\"line_{line_counter}\"\n                    inner_wire_var = f\"{var_name} = Line(start_point={edge.start_point.to_python()}, end_point={edge.end_point.to_python()})\"\n                    line_counter += 1\n                elif isinstance(edge, Circle):\n                    var_name = f\"circle_{circle_counter}\"\n                    inner_wire_var = f\"{var_name} = Circle(center={edge.center.to_python()}, radius={edge.radius})\"\n                    circle_counter += 1\n                elif isinstance(edge, Arc):\n                    var_name = f\"arc_{arc_counter}\"\n                    inner_wire_var = f\"{var_name} = {edge.to_python()}\"\n                    arc_counter += 1\n                else:\n                    raise ValueError(f\"Unknown edge type: {type(edge)}\")\n                inner_wire_var_names.append(var_name)\n                inner_wire_edges.append(inner_wire_var)\n\n            variables += [\"\\n\".join(inner_wire_edges)]\n            inner_wire_var_name = f\"inner_wire_{index}_{i}\"\n            variables.append(\n                f\"{inner_wire_var_name} = Wire([{', '.join(inner_wire_var_names)}])\"\n            )\n            inner_wires_var_names.append(inner_wire_var_name)\n\n        # Create sketch with all inner wires\n        inner_wires_list = \"[\" + \", \".join(inner_wires_var_names) + \"]\"\n        sketch = f\"sketch_{index} = Sketch(outer_wire = outer_wire_{index}, inner_wires = {inner_wires_list}, sketch_plane = {self.sketch_plane.to_python()})\\n\"\n    else:\n        sketch = f\"sketch_{index} = Sketch(outer_wire = outer_wire_{index}, sketch_plane = {self.sketch_plane.to_python()})\\n\"\n\n    return \"\\n\".join(variables) + \"\\n\" + sketch"
            },
            "normalize": {
              "name": "normalize",
              "path": "rapidcadpy.sketch.Sketch.normalize",
              "signature": "(self, scale, translation)",
              "description": "Normalize into unit cube and centered at origin",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "scale",
                  "annotation": "Optional[float]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "translation",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def normalize(self, scale: Optional[float], translation):\n    \"\"\"\n    Normalize into unit cube and centered at origin\n    \"\"\"\n    if not scale:\n        scale = 1 / self.bbox_size\n    for edge in self.outer_wire.edges + self.get_inner_edges():\n        edge.transform(translate=translation, scale=scale)\n\n    self.sketch_plane.origin = (\n        self.sketch_plane.origin + np.array((*translation, 0))\n    ) * scale"
            },
            "numericalize": {
              "name": "numericalize",
              "path": "rapidcadpy.sketch.Sketch.numericalize",
              "signature": "(self, n=256)",
              "description": "quantize curve parameters into integers",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": "256"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def numericalize(self, n=256):\n    \"\"\"quantize curve parameters into integers\"\"\"\n    self.sketch_plane.numericalize(n)\n    for edge in self.outer_wire.edges + self.get_inner_edges():\n        edge.numericalize(n)"
            },
            "denumericalize": {
              "name": "denumericalize",
              "path": "rapidcadpy.sketch.Sketch.denumericalize",
              "signature": "(self, n=256)",
              "description": "quantize curve parameters into integers",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n",
                  "annotation": null,
                  "description": null,
                  "value": "256"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def denumericalize(self, n=256):\n    \"\"\"quantize curve parameters into integers\"\"\"\n    self.sketch_plane.denumericalize(n)\n    for edge in self.outer_wire.edges + self.get_inner_edges():\n        edge.denumericalize(n)"
            },
            "get_edge_type_index": {
              "name": "get_edge_type_index",
              "path": "rapidcadpy.sketch.Sketch.get_edge_type_index",
              "signature": "(self, edge_type)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "edge_type",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def get_edge_type_index(self, edge_type):\n    edge_type_map = {\n        \"Coincidence\": 0,\n        \"StartToEndCoincidence\": 1,\n        \"EndToStartCoincidence\": 2,\n        \"Horizontal\": 3,\n        \"Vertical\": 4,\n        \"Perpendicular\": 5,\n        \"Parallel\": 6,\n    }\n    return edge_type_map.get(edge_type, -1)"
            },
            "create_constraint_graph": {
              "name": "create_constraint_graph",
              "path": "rapidcadpy.sketch.Sketch.create_constraint_graph",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def create_constraint_graph(self):\n    import dgl\n\n    # Define dictionaries to store node and edge mappings\n    node_map = {}  # Maps node names to unique IDs\n    node_types = {}  # Maps node IDs to type (line=258, arc=259)\n    # Define the edges here\n    # Syntax:\n    # { (source_type, edge_type, destination_type)  : (src_node_id Tensor , dest_node_id Tensor ) }\n    edges = {\n        (\"primitive\", \"endtostartcoincidence\", \"primitive\"): ([], []),\n        (\"primitive\", \"starttoendcoincidence\", \"primitive\"): ([], []),\n        (\"primitive\", \"parallel\", \"primitive\"): ([], []),\n        (\"primitive\", \"perpendicular\", \"primitive\"): ([], []),\n        (\"primitive\", \"horizontal\", \"primitive\"): ([], []),\n        (\"primitive\", \"vertical\", \"primitive\"): ([], []),\n    }\n    edge_types = []\n\n    # Assign unique node IDs and classify nodes\n    node_counter = 0\n\n    def get_node_id(name, node_type):\n        nonlocal node_counter\n        if name not in node_map:\n            node_map[name] = node_counter\n            node_types[node_counter] = (\n                258 if node_type == \"line\" else 259\n            )  # Line = 258, Arc = 259\n            node_counter += 1\n        return node_map[name]\n\n    # Process constraints and create edges\n    for constraint in self.constraints:\n        if isinstance(constraint, StartToEndCoincidenceConstraint):\n            e_id = get_node_id(constraint.end_primitive.id, \"line\")\n            s_id = get_node_id(constraint.start_primitive.id, \"line\")\n            edges[(\"primitive\", \"starttoendcoincidence\", \"primitive\")][0].append(\n                e_id\n            )\n            edges[(\"primitive\", \"starttoendcoincidence\", \"primitive\")][1].append(\n                s_id\n            )\n            edge_types.append(\"EndToStartCoincidence\")\n\n        elif isinstance(constraint, EndToStartCoincidenceConstraint):\n            e_id = get_node_id(constraint.end_primitive.id, \"line\")\n            s_id = get_node_id(constraint.start_primitive.id, \"line\")\n            edges[(\"primitive\", \"endtostartcoincidence\", \"primitive\")][0].append(\n                e_id\n            )\n            edges[(\"primitive\", \"endtostartcoincidence\", \"primitive\")][1].append(\n                s_id\n            )\n            edge_types.append(\"EndToStartCoincidence\")\n\n        elif isinstance(constraint, HorizontalConstraint):\n            p_id = get_node_id(constraint.primitive.name, \"line\")\n            edges[(\"primitive\", \"horizontal\", \"primitive\")][0].append(p_id)\n            edges[(\"primitive\", \"horizontal\", \"primitive\")][1].append(p_id)\n            edge_types.append(\"Horizontal\")\n\n        elif isinstance(constraint, VerticalConstraint):\n            p_id = get_node_id(constraint.primitive.name, \"line\")\n            edges[(\"primitive\", \"vertical\", \"primitive\")][0].append(p_id)\n            edges[(\"primitive\", \"vertical\", \"primitive\")][1].append(p_id)\n            edge_types.append(\"Vertical\")\n\n        elif isinstance(constraint, PerpendicularConstraint):\n            f_id = get_node_id(constraint.first.name, \"line\")\n            s_id = get_node_id(constraint.second.name, \"line\")\n            edges[(\"primitive\", \"perpendicular\", \"primitive\")][0].append(f_id)\n            edges[(\"primitive\", \"perpendicular\", \"primitive\")][1].append(s_id)\n            edge_types.append(\"Perpendicular\")\n\n        elif isinstance(constraint, ParallelConstraint):\n            f_id = get_node_id(constraint.first.name, \"line\")\n            s_id = get_node_id(constraint.second.name, \"line\")\n            edges[(\"primitive\", \"parallel\", \"primitive\")][0].append(f_id)\n            edges[(\"primitive\", \"parallel\", \"primitive\")][1].append(s_id)\n            edge_types.append(\"Parallel\")\n\n    # Create the heterogeneous DGL graph\n    hg = dgl.heterograph(edges)\n\n    # Add node type as a feature (258 for lines, 259 for arcs)\n    node_type_tensor = torch.tensor([node_types[i] for i in range(len(node_map))])\n    hg.ndata[\"type\"] = node_type_tensor\n\n    return hg"
            },
            "to_graph": {
              "name": "to_graph",
              "path": "rapidcadpy.sketch.Sketch.to_graph",
              "signature": "(self, with_constraints=True)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "with_constraints",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_graph(self, with_constraints=True):\n    self.add_coincidence_constraints()\n    from collections import defaultdict\n\n    data = HeteroData()\n\n    node_map = {}  # Maps node names to unique IDs\n    node_types = {}  # Maps node IDs to type (258=line, 259=arc)\n    edge_index_dict = defaultdict(lambda: [[], []])  # Hetero edge index\n\n    node_counter = 0\n    node_attrs = {}\n\n    edge_index_dict = {\n        (\"primitive\", \"starttoendcoincidence\", \"primitive\"): ([], []),\n        (\"primitive\", \"endtostartcoincidence\", \"primitive\"): ([], []),\n        (\"primitive\", \"horizontal\", \"primitive\"): ([], []),\n        (\"primitive\", \"vertical\", \"primitive\"): ([], []),\n        (\"primitive\", \"perpendicular\", \"primitive\"): ([], []),\n        (\"primitive\", \"parallel\", \"primitive\"): ([], []),\n    }\n\n    def get_node_id(name, primitive):\n        nonlocal node_counter\n        if name not in node_map:\n            node_map[name] = node_counter\n            if isinstance(primitive, Line):\n                node_types[node_counter] = 258\n                node_attrs[node_counter] = {\n                    \"type\": node_types[node_counter],\n                    \"start\": primitive.start_point.to_json(),\n                    \"end\": primitive.end_point.to_json(),\n                }\n            if isinstance(primitive, Arc):\n                node_types[node_counter] = 259\n                node_attrs[node_counter] = {\n                    \"type\": node_types[node_counter],\n                    \"start\": primitive.start_point.to_json(),\n                    \"end\": primitive.end_point.to_json(),\n                    \"sweep_angle\": abs(primitive.start_angle - primitive.end_angle),\n                    \"ccw\": primitive.ccw,\n                }\n            if isinstance(primitive, Circle):\n                node_types[node_counter] = 260\n                node_attrs[node_counter] = {\n                    \"type\": node_types[node_counter],\n                    \"center\": primitive.center.to_json(),\n                    \"radius\": primitive.radius,\n                }\n            node_counter += 1\n        return node_map[name]\n\n    for constraint in self.constraints:\n        if isinstance(constraint, StartToEndCoincidenceConstraint):\n            e_id = get_node_id(\n                constraint.end_primitive.name, constraint.end_primitive\n            )\n            s_id = get_node_id(\n                constraint.start_primitive.name, constraint.start_primitive\n            )\n            edge_index_dict[(\"primitive\", \"starttoendcoincidence\", \"primitive\")][\n                0\n            ].append(e_id)\n            edge_index_dict[(\"primitive\", \"starttoendcoincidence\", \"primitive\")][\n                1\n            ].append(s_id)\n        elif isinstance(constraint, EndToStartCoincidenceConstraint):\n            e_id = get_node_id(\n                constraint.end_primitive.name, constraint.end_primitive\n            )\n            s_id = get_node_id(\n                constraint.start_primitive.name, constraint.start_primitive\n            )\n            edge_index_dict[(\"primitive\", \"endtostartcoincidence\", \"primitive\")][\n                0\n            ].append(s_id)\n            edge_index_dict[(\"primitive\", \"endtostartcoincidence\", \"primitive\")][\n                1\n            ].append(e_id)\n        elif isinstance(constraint, HorizontalConstraint):\n            p_id = get_node_id(constraint.primitive.name, constraint.primitive)\n            edge_index_dict[(\"primitive\", \"horizontal\", \"primitive\")][0].append(\n                p_id\n            )\n            edge_index_dict[(\"primitive\", \"horizontal\", \"primitive\")][1].append(\n                p_id\n            )\n        elif isinstance(constraint, VerticalConstraint):\n            p_id = get_node_id(constraint.primitive.name, constraint.primitive)\n            edge_index_dict[(\"primitive\", \"vertical\", \"primitive\")][0].append(p_id)\n            edge_index_dict[(\"primitive\", \"vertical\", \"primitive\")][1].append(p_id)\n\n        elif isinstance(constraint, PerpendicularConstraint):\n            f_id = get_node_id(constraint.first.name, constraint.first)\n            s_id = get_node_id(constraint.second.name, constraint.second)\n            edge_index_dict[(\"primitive\", \"perpendicular\", \"primitive\")][0].append(\n                f_id\n            )\n            edge_index_dict[(\"primitive\", \"perpendicular\", \"primitive\")][1].append(\n                s_id\n            )\n        elif isinstance(constraint, ParallelConstraint):\n            f_id = get_node_id(constraint.first.name, constraint.first)\n            s_id = get_node_id(constraint.second.name, constraint.second)\n            edge_index_dict[(\"primitive\", \"parallel\", \"primitive\")][0].append(f_id)\n            edge_index_dict[(\"primitive\", \"parallel\", \"primitive\")][1].append(s_id)\n\n    # Set node features (e.g., type)\n    num_nodes = len(node_map)\n    data[\"primitive\"].x = torch.tensor(\n        [node_types[i] for i in range(num_nodes)], dtype=torch.long\n    )\n\n    starts, ends = [], []\n    centers, radii, sweep_angles, ccws = [], [], [], []\n\n    for i in range(num_nodes):\n        attr = node_attrs[i]\n\n        # Start\n        start = attr.get(\"start\")\n        if start:\n            starts.append([start[\"x\"], start[\"y\"]])\n        else:\n            starts.append([None, None])\n\n        # End\n        end = attr.get(\"end\")\n        if end:\n            ends.append([end[\"x\"], end[\"y\"]])\n        else:\n            ends.append([None, None])\n\n        # Center\n        center = attr.get(\"center\")\n        if center:\n            centers.append([center[\"x\"], center[\"y\"]])\n        else:\n            centers.append([None, None])\n\n        # Radius\n        radii.append(attr.get(\"radius\"))\n\n        # Sweep angle\n        sweep_angles.append(attr.get(\"sweep_angle\"))\n\n        # CCW\n        ccws.append(attr.get(\"ccw\"))\n\n    # Convert to tensors (replace None with NaN)\n    def to_tensor(arr, dim=2):\n        return torch.tensor(\n            [\n                [float(v) if v is not None else float(\"nan\") for v in row]\n                for row in arr\n            ],\n            dtype=torch.float,\n        )\n\n    data[\"primitive\"].start = to_tensor(starts)\n    data[\"primitive\"].end = to_tensor(ends)\n    data[\"primitive\"].center = to_tensor(centers)\n    data[\"primitive\"].radius = torch.tensor(\n        [float(r) if r is not None else float(\"nan\") for r in radii],\n        dtype=torch.float,\n    )\n    data[\"primitive\"].sweep_angle = torch.tensor(\n        [float(a) if a is not None else float(\"nan\") for a in sweep_angles],\n        dtype=torch.float,\n    )\n    data[\"primitive\"].ccw = torch.tensor(\n        [bool(c) if c is not None else False for c in ccws], dtype=torch.bool\n    )\n\n    # Set edges\n    if with_constraints:\n        for (src_type, rel_type, dst_type), (\n            src_list,\n            dst_list,\n        ) in edge_index_dict.items():\n            edge_index = torch.tensor([src_list, dst_list], dtype=torch.long)\n            data[(src_type, rel_type, dst_type)].edge_index = edge_index\n    else:\n        for (src_type, rel_type, dst_type), (\n            src_list,\n            dst_list,\n        ) in edge_index_dict.items():\n            if (\n                rel_type == \"endtostartcoincidence\"\n                or rel_type == \"endtostartcoincidence\"\n            ):\n                edge_index = torch.tensor([src_list, dst_list], dtype=torch.long)\n                data[(src_type, rel_type, dst_type)].edge_index = edge_index\n    return data"
            },
            "add_coincidence_constraints": {
              "name": "add_coincidence_constraints",
              "path": "rapidcadpy.sketch.Sketch.add_coincidence_constraints",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def add_coincidence_constraints(self):\n    edges = self.outer_wire.edges\n    for i, p1 in enumerate(edges):\n        for j, p2 in enumerate(edges):\n            if i == j:\n                continue\n            if isinstance(p1, Circle) or isinstance(p2, Circle):\n                continue\n            if p1.start_point == p2.end_point and False:\n                self.constraints.append(\n                    StartToEndCoincidenceConstraint(\n                        start_primitive=p1, end_primitive=p2\n                    )\n                )\n            if p1.end_point == p2.start_point:\n                self.constraints.append(\n                    EndToStartCoincidenceConstraint(\n                        start_primitive=p1, end_primitive=p2\n                    )\n                )"
            },
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.sketch.Sketch.__init__",
              "signature": "(self, outer_wire, inner_wires=list(), constraints=list(), id=uuid.uuid4(), name='Sketch') -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "outer_wire",
                  "annotation": "Wire",
                  "description": null,
                  "value": null
                },
                {
                  "name": "inner_wires",
                  "annotation": "Optional[List[Wire]]",
                  "description": null,
                  "value": "list()"
                },
                {
                  "name": "constraints",
                  "annotation": "Optional[List[Constraint]]",
                  "description": null,
                  "value": "list()"
                },
                {
                  "name": "id",
                  "annotation": "Optional[uuid.UUID]",
                  "description": null,
                  "value": "uuid.uuid4()"
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "'Sketch'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass\nclass Sketch:\n    \"\"\"This class encapsulates a sketch instance.\"\"\"\n\n    outer_wire: \"Wire\"\n    inner_wires: Optional[List[\"Wire\"]] = field(default_factory=list)\n    constraints: Optional[List[Constraint]] = field(default_factory=list)\n    id: Optional[uuid.UUID] = field(default=uuid.uuid4())\n    name: str = \"Sketch\"\n\n    def __str__(self):\n        return \"\\n\\t\".join([str(edge) for edge in self.outer_wire.edges])\n\n    def __post_init__(self):\n        if self.id is None:\n            self.id = uuid.uuid4()\n\n    def get_face_by_id(self, face_id: Union[str, uuid.UUID]):\n        if isinstance(face_id, str):\n            face_id = uuid.UUID(face_id)\n        for face in self.faces:\n            if face.id == face_id:\n                return face\n        return None\n\n    def plot(self, title=None, return_fig=False):\n        if return_fig:\n            return visualize_lines(\n                self.outer_wire.edges,\n                inner_edges=self.get_inner_edges(),\n                return_fig=True,\n                title=self.name,\n                plane=self.sketch_plane,\n            )\n        visualize_lines(\n            self.outer_wire.edges, inner_edges=self.get_inner_edges(), title=title\n        )\n\n    def to_json(self):\n        self.merge_coincident_vertices()\n        vertices = self.name_vertices_sequentially(variable_definitons=False)\n        return {\n            \"vertices\": {str(v.name): v.to_json() for v in vertices},\n            \"outer_edges\": [\n                e.to_json(dereferenced=True) for e in self.outer_wire.edges\n            ],\n            \"inner_edges\": [\n                [e.to_json(dereferenced=True) for e in w.edges]\n                for w in self.inner_wires or []\n            ],\n            \"constraints\": [c.to_json() for c in self.constraints or [] if c],\n        }\n\n    @staticmethod\n    def from_json(data):\n        outer_wire_edges = []\n        edge_dict = {}\n        for edge_data in data[\"outer_edges\"]:\n            if edge_data[\"type\"] == \"Line\":\n                edge = Line.from_json(edge_data)\n            elif edge_data[\"type\"] == \"Circle\":\n                edge = Circle.from_json(edge_data)\n            elif edge_data[\"type\"] == \"Arc\":\n                edge = Arc.from_json(edge_data)\n            outer_wire_edges.append(edge)\n\n        inner_wires = []\n        for inner_edge in data[\"inner_edges\"]:\n            inner_wire_edges = []\n            for edge_data in inner_edge:\n                if edge_data[\"type\"] == \"Line\":\n                    edge = Line.from_json(edge_data)\n                elif edge_data[\"type\"] == \"Circle\":\n                    edge = Circle.from_json(edge_data)\n                elif edge_data[\"type\"] == \"Arc\":\n                    edge = Arc.from_json(edge_data)\n                inner_wire_edges.append(edge)\n            inner_wires.append(Wire(inner_wire_edges))\n\n        return Sketch(\n            outer_wire=Wire(edges=outer_wire_edges),\n            inner_wires=inner_wires,\n            sketch_plane=Plane.from_json(data[\"sketch_plane\"]),\n        )\n\n    @staticmethod\n    def from_dict(all_stat, profile_uid_list):\n        facedata = []\n        plane = Plane.from_dict(\n            all_stat[\"entities\"][profile_uid_list[0][0]][\"transform\"]\n        )\n\n        for i in range(len(profile_uid_list)):\n            sketch_entity = all_stat[\"entities\"][profile_uid_list[i][0]]\n            facedata.append(\n                FaceSequence.from_dict(sketch_entity, profile_uid_list[i][1])\n            )\n\n        return Sketch(facedata=facedata, sketch_plane=plane, reorder=True)\n\n    def _order_edges(self, edges):\n        if any(isinstance(edge, Circle) for edge in edges):\n            return edges\n        log.debug(f\"### Ordering Edges {len(edges)}\")\n        num_edges_before = len(edges)\n\n        # Create mappings from vertices to edges\n        start_to_edge: Dict[Vertex, List[Union[Line, Arc]]] = defaultdict(list)\n        end_to_edge: Dict[Vertex, List[Union[Line, Arc]]] = defaultdict(list)\n\n        for edge in edges:\n            start_to_edge[edge.start_point].append(edge)\n            end_to_edge[edge.end_point].append(edge)\n\n        # Choose starting edge\n        start_edge = edges[0]\n\n        # remove the start edge from the mappings\n        start_to_edge[start_edge.start_point].remove(start_edge)\n        end_to_edge[start_edge.end_point].remove(start_edge)\n\n        # Build the ordered list of xedges\n        ordered_edges = []\n        current_edge = start_edge\n\n        while len(start_to_edge) + len(end_to_edge) > 0:\n            ordered_edges.append(current_edge)\n            log.debug(\"\\t\\tCurrent Edge: %s\", current_edge)\n            log.debug(\"\\t\\tRemaining Start To Edge: %s\", start_to_edge)\n            log.debug(\"\\t\\tRemaining End To Edge: %s\", end_to_edge)\n\n            if current_edge.end_point in start_to_edge:\n                log.debug(\"\\t\\t1 End Point in Start to Edge\")\n                current_edge = start_to_edge[current_edge.end_point].pop(0)\n                end_to_edge[current_edge.end_point].remove(current_edge)\n            elif current_edge.start_point in end_to_edge:\n                log.debug(\"\\t\\t2 Start Point in End to Edge\")\n                current_edge = end_to_edge[current_edge.start_point].pop(0)\n                start_to_edge[current_edge.start_point].remove(current_edge)\n            elif current_edge.end_point in end_to_edge:\n                log.debug(\"\\t\\t3 Flipping Edge\")\n                # Add flipped edge\n                current_edge = end_to_edge[current_edge.end_point].pop(0)\n                start_to_edge[current_edge.start_point].remove(current_edge)\n                # Reverse flip to delete the old edge\n                current_edge.flip()\n            elif current_edge.start_point in start_to_edge:\n                log.debug(\"\\t\\t4 Flipping Edge\")\n                # Add flipped edge\n                current_edge = start_to_edge[current_edge.start_point].pop(0)\n                end_to_edge[current_edge.end_point].remove(current_edge)\n                current_edge.flip()\n                log.debug(len(end_to_edge) + len(start_to_edge))\n            else:\n                log.debug(\"\\t\\t4 No Connected Edges\")\n                break\n\n            # remove empty lists from dict\n            start_to_edge = {k: v for k, v in start_to_edge.items() if v}\n            end_to_edge = {k: v for k, v in end_to_edge.items() if v}\n\n        # Add the last edge\n        ordered_edges.append(current_edge)\n\n        if len(ordered_edges) != num_edges_before:\n            log.error(\n                f\"Number of edges before {num_edges_before} is not equal to number of ordered edges {len(ordered_edges)}\"\n            )\n\n        return ordered_edges\n\n    def order_edges(self):\n        self._order_edges(self.outer_wire.edges)\n        for wire in self.inner_wires:\n            wire.edges = self._order_edges(wire.edges)\n\n    def get_inner_edges(self):\n        if len(self.inner_wires) == 0:\n            return []\n        return [edge for wire in self.inner_wires for edge in wire.edges]\n\n    @staticmethod\n    def _point_on_line(point, line, tolerance: float = 1e-5) -> bool:\n        # check if point is somewhere on the line\n        x = point.x\n        y = point.y\n        x1 = line.start_point.x\n        y1 = line.start_point.y\n        x2 = line.end_point.x\n        y2 = line.end_point.y\n\n        cross_product = (y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)\n\n        # The point is not collinear with the line segment\n        if abs(cross_product) > tolerance:\n            return False\n\n        # Check if the point is within the bounding box of the line segment\n        return (\n            min(x1, x2) - tolerance <= x <= max(x1, x2) + tolerance\n            and min(y1, y2) - tolerance <= y <= max(y1, y2) + tolerance\n        )\n\n    @staticmethod\n    def _point_on_circle(point, circle, tolerance: float = 1e-5) -> bool:\n        # check if point is somewhere on the line\n        x = point.x\n        y = point.y\n        x1 = circle.center.x\n        y1 = circle.center.y\n        r = circle.radius\n\n        return abs((x - x1) ** 2 + (y - y1) ** 2 - r**2) < tolerance\n\n    def fix_start_end_points(self):\n        for edge in self.outer_wire.edges:\n            if isinstance(edge, Circle):\n                continue\n            lines_removed_edge = [\n                e for e in self.outer_wire.edges if e != edge and isinstance(e, Line)\n            ]\n            circles_removed_edge = [\n                e for e in self.outer_wire.edges if e != edge and isinstance(e, Circle)\n            ]\n            # Check if point1 is the point2 of another edge\n            all_other_points = [e.start_point for e in lines_removed_edge] + [\n                e.end_point for e in lines_removed_edge\n            ]\n            start_point_found = edge.start_point in all_other_points\n            end_point_found = edge.end_point in all_other_points\n\n            if not start_point_found:\n                log.debug(\"\\tEdge with disconnected start point: %s\", edge)\n                for edge2 in lines_removed_edge:\n                    if self._point_on_line(point=edge2.end_point, line=edge) and any(\n                        edge2.end_point != edge.end_point\n                    ):\n                        log.debug(f\"\\t6 Fixed edge {edge} -> \")\n                        edge.start_point = Vertex(\n                            x=edge2.end_point.x, y=edge2.end_point.y\n                        )\n                        log.debug(f\"\\t\\t{edge}\")\n                        break\n                    if self._point_on_line(edge2.start_point, edge) and any(\n                        edge2.start_point != edge.end_point\n                    ):\n                        log.debug(f\"\\t6 Fixed edge {edge} -> \")\n                        edge.start_point = Vertex(\n                            x=edge2.start_point.x, y=edge2.start_point.y\n                        )\n                        log.debug(f\"\\t\\t{edge}\")\n                        break\n                for edge2 in circles_removed_edge:\n                    if self._point_on_circle(edge.start_point, edge2):\n                        log.debug(f\"\\t6.1 Start point on circle {edge2}\")\n                        break\n            if not end_point_found:\n                log.debug(\"\\tEdge with disconnected end point: %s\", edge)\n                for edge2 in lines_removed_edge:\n                    if self._point_on_line(edge2.end_point, edge) and any(\n                        edge2.end_point != edge.start_point\n                    ):\n                        log.debug(\"\\t7 Found connected edge: %s\", edge2)\n                        edge.end_point = Vertex(\n                            x=edge2.end_point.x, y=edge2.end_point.y\n                        )\n                        break\n                    if self._point_on_line(edge2.start_point, edge) and any(\n                        edge2.start_point != edge.start_point\n                    ):\n                        log.debug(\"\\t8 Found connected edge: %s\", edge2)\n                        edge.end_point = Vertex(\n                            x=edge2.start_point.x, y=edge2.start_point.y\n                        )\n                for edge2 in circles_removed_edge:\n                    if self._point_on_circle(edge.end_point, edge2):\n                        log.debug(f\"\\t8.1 End point on circle {edge2}\")\n                        break\n\n    def remove_coincidences(self):\n        # Remove coincident lines\n        edges_to_remove = set()\n        tolerance = 1e-5\n        for edge in self.outer_wire.edges:\n            if isinstance(edge, Line):\n                edges_removed = [e for e in self.outer_wire.edges if e != edge]\n                for edge2 in edges_removed:\n                    if isinstance(edge2, Line):\n                        cross_product = np.cross(\n                            np.array(edge.end_point) - np.array(edge.start_point),\n                            np.array(edge2.end_point) - np.array(edge2.start_point),\n                        )\n                        # check if collinear\n                        if abs(cross_product) < tolerance:\n                            # check if edge is within the bounding box of edge2\n                            min_point = (\n                                np.minimum(edge2.start_point, edge2.end_point)\n                                - tolerance\n                            )\n                            max_point = (\n                                np.maximum(edge2.start_point, edge2.end_point)\n                                + tolerance\n                            )\n\n                            is_within_bbox = np.all(\n                                (min_point <= edge.start_point)\n                                & (edge.start_point <= max_point)\n                            )\n                            is_within_bbox = is_within_bbox and np.all(\n                                (min_point <= edge.end_point)\n                                & (edge.end_point <= max_point)\n                            )\n\n                            if is_within_bbox:\n                                edges_to_remove.add(edge)\n\n        self.outer_wire.edges = [\n            e for e in self.outer_wire.edges if e not in edges_to_remove\n        ]\n\n    def merge_coincident_vertices(self):\n        # Merge coincident vertices\n        for edge in self.outer_wire.edges:\n            if isinstance(edge, Line) or isinstance(edge, Arc):\n                for edge2 in self.outer_wire.edges:\n                    if edge2 != edge and edge.start_point == edge2.start_point:\n                        edge.start_point = edge2.start_point\n                    if edge2 != edge and edge.end_point == edge2.end_point:\n                        edge.end_point = edge2.end_point\n                    if edge2 != edge and edge.start_point == edge2.end_point:\n                        edge.start_point = edge2.end_point\n                    if edge2 != edge and edge.end_point == edge2.start_point:\n                        edge.end_point = edge2.start_point\n                    if isinstance(edge, Arc) and isinstance(edge2, Arc):\n                        if edge.center == edge2.center:\n                            edge.center = edge2.center\n\n    def name_vertices_sequentially(self, variable_definitons=True):\n        vertex_index = 0\n        vertex_variable_definitions = []\n        parsed_vertices: Set[Vertex] = set()\n        not_detect_duplicates = False\n        for edge in self.outer_wire.edges + self.get_inner_edges():\n            if isinstance(edge, Line):\n                if edge.start_point not in parsed_vertices or not_detect_duplicates:\n                    edge.start_point.name = f\"vertex_{vertex_index}\"\n                    vertex_variable_definitions.append(\n                        f\"vertex_{vertex_index} = Vertex(x={edge.start_point.x}, y={edge.start_point.y})\"\n                    )\n\n                    parsed_vertices.add(edge.start_point)\n                    vertex_index += 1\n                if edge.end_point not in parsed_vertices or not_detect_duplicates:\n                    edge.end_point.name = f\"vertex_{vertex_index}\"\n                    vertex_variable_definitions.append(\n                        f\"vertex_{vertex_index} = Vertex(x={edge.end_point.x}, y={edge.end_point.y})\"\n                    )\n                    parsed_vertices.add(edge.end_point)\n                    vertex_index += 1\n            elif isinstance(edge, Circle):\n                if edge.center not in parsed_vertices or not_detect_duplicates:\n                    edge.center.name = f\"vertex_{vertex_index}\"\n                    vertex_variable_definitions.append(\n                        f\"vertex_{vertex_index} = Vertex(x={edge.center.x}, y={edge.center.y})\"\n                    )\n                    parsed_vertices.add(edge.center)\n                    vertex_index += 1\n            elif isinstance(edge, Arc):\n                if edge.start_point not in parsed_vertices or not_detect_duplicates:\n                    edge.start_point.name = f\"vertex_{vertex_index}\"\n                    vertex_variable_definitions.append(\n                        f\"vertex_{vertex_index} = Vertex(x={edge.start_point.x}, y={edge.start_point.y})\"\n                    )\n                    parsed_vertices.add(edge.start_point)\n                    vertex_index += 1\n                if edge.end_point not in parsed_vertices or not_detect_duplicates:\n                    edge.end_point.name = f\"vertex_{vertex_index}\"\n                    vertex_variable_definitions.append(\n                        f\"vertex_{vertex_index} = Vertex(x={edge.end_point.x}, y={edge.end_point.y})\"\n                    )\n                    parsed_vertices.add(edge.end_point)\n                    vertex_index += 1\n                if edge.center not in parsed_vertices or not_detect_duplicates:\n                    edge.center.name = f\"vertex_{vertex_index}\"\n                    vertex_variable_definitions.append(\n                        f\"vertex_{vertex_index} = Vertex(x={edge.center.x}, y={edge.center.y})\"\n                    )\n                    parsed_vertices.add(edge.center)\n                    vertex_index += 1\n\n        if variable_definitons:\n            return vertex_variable_definitions\n        return parsed_vertices\n\n    def to_python(self, index: Optional[int] = 0):\n        # self.merge_coincident_vertices()\n        # vertices = self.name_vertices_sequentially(variable_definitons=True)\n\n        edges = []\n        line_counter = 0\n        circle_counter = 0\n        arc_counter = 0\n\n        outer_wire_variable_names = []\n        for i, edge in enumerate(self.outer_wire.edges):\n            if isinstance(edge, Line):\n                var_name = f\"line_{line_counter}\"\n                edges.append(\n                    f\"{var_name} = Line(start_point={edge.start_point.to_python()}, end_point={edge.end_point.to_python()})\"\n                )\n                outer_wire_variable_names.append(var_name)\n                line_counter += 1\n            elif isinstance(edge, Circle):\n                var_name = f\"circle_{circle_counter}\"\n                edges.append(\n                    f\"{var_name} = Circle(center={edge.center.to_python()}, radius={edge.radius})\"\n                )\n                outer_wire_variable_names.append(var_name)\n                circle_counter += 1\n            elif isinstance(edge, Arc):\n                var_name = f\"arc_{arc_counter}\"\n                edges.append(f\"{var_name} = {edge.to_python()}\")\n                outer_wire_variable_names.append(var_name)\n                arc_counter += 1\n\n        outer_wire = (\n            f\"outer_wire_{index} = Wire([{', '.join(outer_wire_variable_names)}])\"\n        )\n        variables = [\"\\n\".join(edges) + \"\\n\" + outer_wire + \"\\n\"]\n\n        inner_wires_var_names = []\n        if len(self.inner_wires) > 0:\n            # Generate code for all inner wires\n            for i, inner_wire in enumerate(self.inner_wires):\n                inner_wire_edges = []\n                inner_wire_var_names = []\n                for edge in inner_wire.edges:\n                    if isinstance(edge, Line):\n                        var_name = f\"line_{line_counter}\"\n                        inner_wire_var = f\"{var_name} = Line(start_point={edge.start_point.to_python()}, end_point={edge.end_point.to_python()})\"\n                        line_counter += 1\n                    elif isinstance(edge, Circle):\n                        var_name = f\"circle_{circle_counter}\"\n                        inner_wire_var = f\"{var_name} = Circle(center={edge.center.to_python()}, radius={edge.radius})\"\n                        circle_counter += 1\n                    elif isinstance(edge, Arc):\n                        var_name = f\"arc_{arc_counter}\"\n                        inner_wire_var = f\"{var_name} = {edge.to_python()}\"\n                        arc_counter += 1\n                    else:\n                        raise ValueError(f\"Unknown edge type: {type(edge)}\")\n                    inner_wire_var_names.append(var_name)\n                    inner_wire_edges.append(inner_wire_var)\n\n                variables += [\"\\n\".join(inner_wire_edges)]\n                inner_wire_var_name = f\"inner_wire_{index}_{i}\"\n                variables.append(\n                    f\"{inner_wire_var_name} = Wire([{', '.join(inner_wire_var_names)}])\"\n                )\n                inner_wires_var_names.append(inner_wire_var_name)\n\n            # Create sketch with all inner wires\n            inner_wires_list = \"[\" + \", \".join(inner_wires_var_names) + \"]\"\n            sketch = f\"sketch_{index} = Sketch(outer_wire = outer_wire_{index}, inner_wires = {inner_wires_list}, sketch_plane = {self.sketch_plane.to_python()})\\n\"\n        else:\n            sketch = f\"sketch_{index} = Sketch(outer_wire = outer_wire_{index}, sketch_plane = {self.sketch_plane.to_python()})\\n\"\n\n        return \"\\n\".join(variables) + \"\\n\" + sketch\n\n    @property\n    def start_point(self):\n        return self.outer_wire.edges[0].start_point\n\n    @property\n    def end_point(self):\n        return self.outer_wire.edges[-1].end_point\n\n    @property\n    def bbox(self):\n        \"\"\"compute bounding box (min/max points) of the sketch\"\"\"\n        all_points = np.concatenate(\n            [edge.bbox for edge in self.outer_wire.edges], axis=0\n        )\n        return np.stack(\n            [np.min(all_points, axis=0), np.max(all_points, axis=0)], axis=0\n        )\n\n    @property\n    def bbox_size(self):\n        \"\"\"compute bounding box size (max of height and width)\"\"\"\n        bbox_min, bbox_max = self.bbox[0], self.bbox[1]\n        bbox_size = np.max(\n            np.abs(\n                np.concatenate(\n                    [bbox_max - self.start_point, bbox_min - self.start_point]\n                )\n            )\n        )\n        return bbox_size\n\n    def normalize(self, scale: Optional[float], translation):\n        \"\"\"\n        Normalize into unit cube and centered at origin\n        \"\"\"\n        if not scale:\n            scale = 1 / self.bbox_size\n        for edge in self.outer_wire.edges + self.get_inner_edges():\n            edge.transform(translate=translation, scale=scale)\n\n        self.sketch_plane.origin = (\n            self.sketch_plane.origin + np.array((*translation, 0))\n        ) * scale\n\n    def numericalize(self, n=256):\n        \"\"\"quantize curve parameters into integers\"\"\"\n        self.sketch_plane.numericalize(n)\n        for edge in self.outer_wire.edges + self.get_inner_edges():\n            edge.numericalize(n)\n\n    def denumericalize(self, n=256):\n        \"\"\"quantize curve parameters into integers\"\"\"\n        self.sketch_plane.denumericalize(n)\n        for edge in self.outer_wire.edges + self.get_inner_edges():\n            edge.denumericalize(n)\n\n    def get_edge_type_index(self, edge_type):\n        edge_type_map = {\n            \"Coincidence\": 0,\n            \"StartToEndCoincidence\": 1,\n            \"EndToStartCoincidence\": 2,\n            \"Horizontal\": 3,\n            \"Vertical\": 4,\n            \"Perpendicular\": 5,\n            \"Parallel\": 6,\n        }\n        return edge_type_map.get(edge_type, -1)\n\n    def create_constraint_graph(self):\n        import dgl\n\n        # Define dictionaries to store node and edge mappings\n        node_map = {}  # Maps node names to unique IDs\n        node_types = {}  # Maps node IDs to type (line=258, arc=259)\n        # Define the edges here\n        # Syntax:\n        # { (source_type, edge_type, destination_type)  : (src_node_id Tensor , dest_node_id Tensor ) }\n        edges = {\n            (\"primitive\", \"endtostartcoincidence\", \"primitive\"): ([], []),\n            (\"primitive\", \"starttoendcoincidence\", \"primitive\"): ([], []),\n            (\"primitive\", \"parallel\", \"primitive\"): ([], []),\n            (\"primitive\", \"perpendicular\", \"primitive\"): ([], []),\n            (\"primitive\", \"horizontal\", \"primitive\"): ([], []),\n            (\"primitive\", \"vertical\", \"primitive\"): ([], []),\n        }\n        edge_types = []\n\n        # Assign unique node IDs and classify nodes\n        node_counter = 0\n\n        def get_node_id(name, node_type):\n            nonlocal node_counter\n            if name not in node_map:\n                node_map[name] = node_counter\n                node_types[node_counter] = (\n                    258 if node_type == \"line\" else 259\n                )  # Line = 258, Arc = 259\n                node_counter += 1\n            return node_map[name]\n\n        # Process constraints and create edges\n        for constraint in self.constraints:\n            if isinstance(constraint, StartToEndCoincidenceConstraint):\n                e_id = get_node_id(constraint.end_primitive.id, \"line\")\n                s_id = get_node_id(constraint.start_primitive.id, \"line\")\n                edges[(\"primitive\", \"starttoendcoincidence\", \"primitive\")][0].append(\n                    e_id\n                )\n                edges[(\"primitive\", \"starttoendcoincidence\", \"primitive\")][1].append(\n                    s_id\n                )\n                edge_types.append(\"EndToStartCoincidence\")\n\n            elif isinstance(constraint, EndToStartCoincidenceConstraint):\n                e_id = get_node_id(constraint.end_primitive.id, \"line\")\n                s_id = get_node_id(constraint.start_primitive.id, \"line\")\n                edges[(\"primitive\", \"endtostartcoincidence\", \"primitive\")][0].append(\n                    e_id\n                )\n                edges[(\"primitive\", \"endtostartcoincidence\", \"primitive\")][1].append(\n                    s_id\n                )\n                edge_types.append(\"EndToStartCoincidence\")\n\n            elif isinstance(constraint, HorizontalConstraint):\n                p_id = get_node_id(constraint.primitive.name, \"line\")\n                edges[(\"primitive\", \"horizontal\", \"primitive\")][0].append(p_id)\n                edges[(\"primitive\", \"horizontal\", \"primitive\")][1].append(p_id)\n                edge_types.append(\"Horizontal\")\n\n            elif isinstance(constraint, VerticalConstraint):\n                p_id = get_node_id(constraint.primitive.name, \"line\")\n                edges[(\"primitive\", \"vertical\", \"primitive\")][0].append(p_id)\n                edges[(\"primitive\", \"vertical\", \"primitive\")][1].append(p_id)\n                edge_types.append(\"Vertical\")\n\n            elif isinstance(constraint, PerpendicularConstraint):\n                f_id = get_node_id(constraint.first.name, \"line\")\n                s_id = get_node_id(constraint.second.name, \"line\")\n                edges[(\"primitive\", \"perpendicular\", \"primitive\")][0].append(f_id)\n                edges[(\"primitive\", \"perpendicular\", \"primitive\")][1].append(s_id)\n                edge_types.append(\"Perpendicular\")\n\n            elif isinstance(constraint, ParallelConstraint):\n                f_id = get_node_id(constraint.first.name, \"line\")\n                s_id = get_node_id(constraint.second.name, \"line\")\n                edges[(\"primitive\", \"parallel\", \"primitive\")][0].append(f_id)\n                edges[(\"primitive\", \"parallel\", \"primitive\")][1].append(s_id)\n                edge_types.append(\"Parallel\")\n\n        # Create the heterogeneous DGL graph\n        hg = dgl.heterograph(edges)\n\n        # Add node type as a feature (258 for lines, 259 for arcs)\n        node_type_tensor = torch.tensor([node_types[i] for i in range(len(node_map))])\n        hg.ndata[\"type\"] = node_type_tensor\n\n        return hg\n\n    def to_graph(self, with_constraints=True):\n        self.add_coincidence_constraints()\n        from collections import defaultdict\n\n        data = HeteroData()\n\n        node_map = {}  # Maps node names to unique IDs\n        node_types = {}  # Maps node IDs to type (258=line, 259=arc)\n        edge_index_dict = defaultdict(lambda: [[], []])  # Hetero edge index\n\n        node_counter = 0\n        node_attrs = {}\n\n        edge_index_dict = {\n            (\"primitive\", \"starttoendcoincidence\", \"primitive\"): ([], []),\n            (\"primitive\", \"endtostartcoincidence\", \"primitive\"): ([], []),\n            (\"primitive\", \"horizontal\", \"primitive\"): ([], []),\n            (\"primitive\", \"vertical\", \"primitive\"): ([], []),\n            (\"primitive\", \"perpendicular\", \"primitive\"): ([], []),\n            (\"primitive\", \"parallel\", \"primitive\"): ([], []),\n        }\n\n        def get_node_id(name, primitive):\n            nonlocal node_counter\n            if name not in node_map:\n                node_map[name] = node_counter\n                if isinstance(primitive, Line):\n                    node_types[node_counter] = 258\n                    node_attrs[node_counter] = {\n                        \"type\": node_types[node_counter],\n                        \"start\": primitive.start_point.to_json(),\n                        \"end\": primitive.end_point.to_json(),\n                    }\n                if isinstance(primitive, Arc):\n                    node_types[node_counter] = 259\n                    node_attrs[node_counter] = {\n                        \"type\": node_types[node_counter],\n                        \"start\": primitive.start_point.to_json(),\n                        \"end\": primitive.end_point.to_json(),\n                        \"sweep_angle\": abs(primitive.start_angle - primitive.end_angle),\n                        \"ccw\": primitive.ccw,\n                    }\n                if isinstance(primitive, Circle):\n                    node_types[node_counter] = 260\n                    node_attrs[node_counter] = {\n                        \"type\": node_types[node_counter],\n                        \"center\": primitive.center.to_json(),\n                        \"radius\": primitive.radius,\n                    }\n                node_counter += 1\n            return node_map[name]\n\n        for constraint in self.constraints:\n            if isinstance(constraint, StartToEndCoincidenceConstraint):\n                e_id = get_node_id(\n                    constraint.end_primitive.name, constraint.end_primitive\n                )\n                s_id = get_node_id(\n                    constraint.start_primitive.name, constraint.start_primitive\n                )\n                edge_index_dict[(\"primitive\", \"starttoendcoincidence\", \"primitive\")][\n                    0\n                ].append(e_id)\n                edge_index_dict[(\"primitive\", \"starttoendcoincidence\", \"primitive\")][\n                    1\n                ].append(s_id)\n            elif isinstance(constraint, EndToStartCoincidenceConstraint):\n                e_id = get_node_id(\n                    constraint.end_primitive.name, constraint.end_primitive\n                )\n                s_id = get_node_id(\n                    constraint.start_primitive.name, constraint.start_primitive\n                )\n                edge_index_dict[(\"primitive\", \"endtostartcoincidence\", \"primitive\")][\n                    0\n                ].append(s_id)\n                edge_index_dict[(\"primitive\", \"endtostartcoincidence\", \"primitive\")][\n                    1\n                ].append(e_id)\n            elif isinstance(constraint, HorizontalConstraint):\n                p_id = get_node_id(constraint.primitive.name, constraint.primitive)\n                edge_index_dict[(\"primitive\", \"horizontal\", \"primitive\")][0].append(\n                    p_id\n                )\n                edge_index_dict[(\"primitive\", \"horizontal\", \"primitive\")][1].append(\n                    p_id\n                )\n            elif isinstance(constraint, VerticalConstraint):\n                p_id = get_node_id(constraint.primitive.name, constraint.primitive)\n                edge_index_dict[(\"primitive\", \"vertical\", \"primitive\")][0].append(p_id)\n                edge_index_dict[(\"primitive\", \"vertical\", \"primitive\")][1].append(p_id)\n\n            elif isinstance(constraint, PerpendicularConstraint):\n                f_id = get_node_id(constraint.first.name, constraint.first)\n                s_id = get_node_id(constraint.second.name, constraint.second)\n                edge_index_dict[(\"primitive\", \"perpendicular\", \"primitive\")][0].append(\n                    f_id\n                )\n                edge_index_dict[(\"primitive\", \"perpendicular\", \"primitive\")][1].append(\n                    s_id\n                )\n            elif isinstance(constraint, ParallelConstraint):\n                f_id = get_node_id(constraint.first.name, constraint.first)\n                s_id = get_node_id(constraint.second.name, constraint.second)\n                edge_index_dict[(\"primitive\", \"parallel\", \"primitive\")][0].append(f_id)\n                edge_index_dict[(\"primitive\", \"parallel\", \"primitive\")][1].append(s_id)\n\n        # Set node features (e.g., type)\n        num_nodes = len(node_map)\n        data[\"primitive\"].x = torch.tensor(\n            [node_types[i] for i in range(num_nodes)], dtype=torch.long\n        )\n\n        starts, ends = [], []\n        centers, radii, sweep_angles, ccws = [], [], [], []\n\n        for i in range(num_nodes):\n            attr = node_attrs[i]\n\n            # Start\n            start = attr.get(\"start\")\n            if start:\n                starts.append([start[\"x\"], start[\"y\"]])\n            else:\n                starts.append([None, None])\n\n            # End\n            end = attr.get(\"end\")\n            if end:\n                ends.append([end[\"x\"], end[\"y\"]])\n            else:\n                ends.append([None, None])\n\n            # Center\n            center = attr.get(\"center\")\n            if center:\n                centers.append([center[\"x\"], center[\"y\"]])\n            else:\n                centers.append([None, None])\n\n            # Radius\n            radii.append(attr.get(\"radius\"))\n\n            # Sweep angle\n            sweep_angles.append(attr.get(\"sweep_angle\"))\n\n            # CCW\n            ccws.append(attr.get(\"ccw\"))\n\n        # Convert to tensors (replace None with NaN)\n        def to_tensor(arr, dim=2):\n            return torch.tensor(\n                [\n                    [float(v) if v is not None else float(\"nan\") for v in row]\n                    for row in arr\n                ],\n                dtype=torch.float,\n            )\n\n        data[\"primitive\"].start = to_tensor(starts)\n        data[\"primitive\"].end = to_tensor(ends)\n        data[\"primitive\"].center = to_tensor(centers)\n        data[\"primitive\"].radius = torch.tensor(\n            [float(r) if r is not None else float(\"nan\") for r in radii],\n            dtype=torch.float,\n        )\n        data[\"primitive\"].sweep_angle = torch.tensor(\n            [float(a) if a is not None else float(\"nan\") for a in sweep_angles],\n            dtype=torch.float,\n        )\n        data[\"primitive\"].ccw = torch.tensor(\n            [bool(c) if c is not None else False for c in ccws], dtype=torch.bool\n        )\n\n        # Set edges\n        if with_constraints:\n            for (src_type, rel_type, dst_type), (\n                src_list,\n                dst_list,\n            ) in edge_index_dict.items():\n                edge_index = torch.tensor([src_list, dst_list], dtype=torch.long)\n                data[(src_type, rel_type, dst_type)].edge_index = edge_index\n        else:\n            for (src_type, rel_type, dst_type), (\n                src_list,\n                dst_list,\n            ) in edge_index_dict.items():\n                if (\n                    rel_type == \"endtostartcoincidence\"\n                    or rel_type == \"endtostartcoincidence\"\n                ):\n                    edge_index = torch.tensor([src_list, dst_list], dtype=torch.long)\n                    data[(src_type, rel_type, dst_type)].edge_index = edge_index\n        return data\n\n    def add_coincidence_constraints(self):\n        edges = self.outer_wire.edges\n        for i, p1 in enumerate(edges):\n            for j, p2 in enumerate(edges):\n                if i == j:\n                    continue\n                if isinstance(p1, Circle) or isinstance(p2, Circle):\n                    continue\n                if p1.start_point == p2.end_point and False:\n                    self.constraints.append(\n                        StartToEndCoincidenceConstraint(\n                            start_primitive=p1, end_primitive=p2\n                        )\n                    )\n                if p1.end_point == p2.start_point:\n                    self.constraints.append(\n                        EndToStartCoincidenceConstraint(\n                            start_primitive=p1, end_primitive=p2\n                        )\n                    )",
          "inherited_members": {}
        }
      },
      "functions": {
        "__eq__": {
          "name": "__eq__",
          "path": "rapidcadpy.sketch.__eq__",
          "signature": "(self, other)",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "other",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def __eq__(self, other):\n    return len(self.outer_wire.edges) == len(other.outer_wire.edges)"
        }
      }
    },
    "plane": {
      "name": "plane",
      "path": "rapidcadpy.plane",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/plane.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "Plane": {
          "name": "Plane",
          "path": "rapidcadpy.plane.Plane",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "origin",
              "annotation": "VectorLike",
              "description": null,
              "value": "(0.0, 0.0, 0.0)"
            },
            {
              "name": "x_dir",
              "annotation": "VectorLike",
              "description": null,
              "value": "(1.0, 0.0, 0.0)"
            },
            {
              "name": "y_dir",
              "annotation": "VectorLike",
              "description": null,
              "value": "(0.0, 1.0, 0.0)"
            },
            {
              "name": "z_dir",
              "annotation": "VectorLike",
              "description": null,
              "value": "(0.0, 0.0, 1.0)"
            }
          ],
          "attributes": [
            {
              "name": "origin",
              "annotation": null,
              "description": null,
              "value": "origin"
            },
            {
              "name": "x_dir",
              "annotation": null,
              "description": null,
              "value": "Vector(*x_dir)"
            },
            {
              "name": "y_dir",
              "annotation": null,
              "description": null,
              "value": "Vector(*y_dir)"
            },
            {
              "name": "z_dir",
              "annotation": null,
              "description": null,
              "value": "Vector(*z_dir)"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.plane.Plane.__init__",
              "signature": "(self, origin=(0.0, 0.0, 0.0), x_dir=(1.0, 0.0, 0.0), y_dir=(0.0, 1.0, 0.0), z_dir=(0.0, 0.0, 1.0))",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "origin",
                  "annotation": "VectorLike",
                  "description": null,
                  "value": "(0.0, 0.0, 0.0)"
                },
                {
                  "name": "x_dir",
                  "annotation": "VectorLike",
                  "description": null,
                  "value": "(1.0, 0.0, 0.0)"
                },
                {
                  "name": "y_dir",
                  "annotation": "VectorLike",
                  "description": null,
                  "value": "(0.0, 1.0, 0.0)"
                },
                {
                  "name": "z_dir",
                  "annotation": "VectorLike",
                  "description": null,
                  "value": "(0.0, 0.0, 1.0)"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(\n    self,\n    origin: VectorLike = (0.0, 0.0, 0.0),\n    x_dir: VectorLike = (1.0, 0.0, 0.0),\n    y_dir: VectorLike = (0.0, 1.0, 0.0),\n    z_dir: VectorLike = (0.0, 0.0, 1.0),\n):\n    if isinstance(origin, Vector):\n        self.origin = origin\n    else:\n        self.origin = Vector(*origin)\n    self.x_dir = Vector(*x_dir)\n    self.y_dir = Vector(*y_dir)\n    self.z_dir = Vector(*z_dir)"
            },
            "from_dict": {
              "name": "from_dict",
              "path": "rapidcadpy.plane.Plane.from_dict",
              "signature": "(transform_dict) -> Plane",
              "description": null,
              "parameters": [
                {
                  "name": "transform_dict",
                  "annotation": "Dict[str, Any]",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "rapidcadpy.plane.Plane",
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_dict(transform_dict: Dict[str, Any]) -> \"Plane\":\n    origin = Vector(\n        transform_dict[\"origin\"][\"x\"],\n        transform_dict[\"origin\"][\"y\"],\n        transform_dict[\"origin\"][\"z\"],\n    )\n\n    x_axis = Vector(\n        transform_dict[\"x_axis\"][\"x\"],\n        transform_dict[\"x_axis\"][\"y\"],\n        transform_dict[\"x_axis\"][\"z\"],\n    )\n\n    y_axis = Vector(\n        transform_dict[\"y_axis\"][\"x\"],\n        transform_dict[\"y_axis\"][\"y\"],\n        transform_dict[\"y_axis\"][\"z\"],\n    )\n\n    z_axis = Vector(\n        transform_dict[\"z_axis\"][\"x\"],\n        transform_dict[\"z_axis\"][\"y\"],\n        transform_dict[\"z_axis\"][\"z\"],\n    )\n\n    return Plane(origin, x_axis, y_axis, z_axis)"
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.plane.Plane.to_json",
              "signature": "(self) -> Dict[str, Any]",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Dict[str, typing.Any]",
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self) -> Dict[str, Any]:\n    return {\n        \"origin\": self.origin.to_json(),\n        \"x_dir\": {\n            \"x\": float(self.x_dir.x),\n            \"y\": float(self.x_dir.y),\n            \"z\": float(self.x_dir.z),\n        },\n        \"y_dir\": {\n            \"x\": float(self.y_dir.x),\n            \"y\": float(self.y_dir.y),\n            \"z\": float(self.y_dir.z),\n        },\n        \"z_dir\": {\n            \"x\": float(self.z_dir.x),\n            \"y\": float(self.z_dir.y),\n            \"z\": float(self.z_dir.z),\n        },\n    }"
            },
            "from_json": {
              "name": "from_json",
              "path": "rapidcadpy.plane.Plane.from_json",
              "signature": "(json_data) -> Plane",
              "description": null,
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "Dict[str, Any]",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "rapidcadpy.plane.Plane",
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef from_json(json_data: Dict[str, Any]) -> \"Plane\":\n    origin = Vector.from_json(json_data[\"origin\"])\n    x_dir = Vector.from_json(json_data[\"x_dir\"])\n    y_dir = Vector.from_json(json_data[\"y_dir\"])\n    z_dir = Vector.from_json(json_data[\"z_dir\"])\n    return Plane(origin, x_dir, y_dir, z_dir)"
            },
            "to_python": {
              "name": "to_python",
              "path": "rapidcadpy.plane.Plane.to_python",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_python(self):\n    return f\"Plane(origin={self.origin.to_python()}, x_dir={self.x_dir.to_python()}, y_dir={self.y_dir.to_python()}, z_dir={self.z_dir.to_python()})\""
            },
            "round": {
              "name": "round",
              "path": "rapidcadpy.plane.Plane.round",
              "signature": "(self, decimals=6)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "decimals",
                  "annotation": null,
                  "description": null,
                  "value": "6"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def round(self, decimals=6):\n    self.origin = Vector(\n        round(self.origin.x, decimals),\n        round(self.origin.y, decimals),\n        round(self.origin.z, decimals),\n    )\n    self.x_dir = Vector(\n        round(self.x_dir.x, decimals),\n        round(self.x_dir.y, decimals),\n        round(self.x_dir.z, decimals),\n    )\n    self.y_dir = Vector(\n        round(self.y_dir.x, decimals),\n        round(self.y_dir.y, decimals),\n        round(self.y_dir.z, decimals),\n    )\n    self.z_dir = Vector(\n        round(self.z_dir.x, decimals),\n        round(self.z_dir.y, decimals),\n        round(self.z_dir.z, decimals),\n    )"
            }
          },
          "source": "class Plane:\n    def __init__(\n        self,\n        origin: VectorLike = (0.0, 0.0, 0.0),\n        x_dir: VectorLike = (1.0, 0.0, 0.0),\n        y_dir: VectorLike = (0.0, 1.0, 0.0),\n        z_dir: VectorLike = (0.0, 0.0, 1.0),\n    ):\n        if isinstance(origin, Vector):\n            self.origin = origin\n        else:\n            self.origin = Vector(*origin)\n        self.x_dir = Vector(*x_dir)\n        self.y_dir = Vector(*y_dir)\n        self.z_dir = Vector(*z_dir)\n\n    @staticmethod\n    def from_dict(transform_dict: Dict[str, Any]) -> \"Plane\":\n        origin = Vector(\n            transform_dict[\"origin\"][\"x\"],\n            transform_dict[\"origin\"][\"y\"],\n            transform_dict[\"origin\"][\"z\"],\n        )\n\n        x_axis = Vector(\n            transform_dict[\"x_axis\"][\"x\"],\n            transform_dict[\"x_axis\"][\"y\"],\n            transform_dict[\"x_axis\"][\"z\"],\n        )\n\n        y_axis = Vector(\n            transform_dict[\"y_axis\"][\"x\"],\n            transform_dict[\"y_axis\"][\"y\"],\n            transform_dict[\"y_axis\"][\"z\"],\n        )\n\n        z_axis = Vector(\n            transform_dict[\"z_axis\"][\"x\"],\n            transform_dict[\"z_axis\"][\"y\"],\n            transform_dict[\"z_axis\"][\"z\"],\n        )\n\n        return Plane(origin, x_axis, y_axis, z_axis)\n\n    def to_json(self) -> Dict[str, Any]:\n        return {\n            \"origin\": self.origin.to_json(),\n            \"x_dir\": {\n                \"x\": float(self.x_dir.x),\n                \"y\": float(self.x_dir.y),\n                \"z\": float(self.x_dir.z),\n            },\n            \"y_dir\": {\n                \"x\": float(self.y_dir.x),\n                \"y\": float(self.y_dir.y),\n                \"z\": float(self.y_dir.z),\n            },\n            \"z_dir\": {\n                \"x\": float(self.z_dir.x),\n                \"y\": float(self.z_dir.y),\n                \"z\": float(self.z_dir.z),\n            },\n        }\n\n    @staticmethod\n    def from_json(json_data: Dict[str, Any]) -> \"Plane\":\n        origin = Vector.from_json(json_data[\"origin\"])\n        x_dir = Vector.from_json(json_data[\"x_dir\"])\n        y_dir = Vector.from_json(json_data[\"y_dir\"])\n        z_dir = Vector.from_json(json_data[\"z_dir\"])\n        return Plane(origin, x_dir, y_dir, z_dir)\n\n    def to_python(self):\n        return f\"Plane(origin={self.origin.to_python()}, x_dir={self.x_dir.to_python()}, y_dir={self.y_dir.to_python()}, z_dir={self.z_dir.to_python()})\"\n\n    def round(self, decimals=6):\n        self.origin = Vector(\n            round(self.origin.x, decimals),\n            round(self.origin.y, decimals),\n            round(self.origin.z, decimals),\n        )\n        self.x_dir = Vector(\n            round(self.x_dir.x, decimals),\n            round(self.x_dir.y, decimals),\n            round(self.x_dir.z, decimals),\n        )\n        self.y_dir = Vector(\n            round(self.y_dir.x, decimals),\n            round(self.y_dir.y, decimals),\n            round(self.y_dir.z, decimals),\n        )\n        self.z_dir = Vector(\n            round(self.z_dir.x, decimals),\n            round(self.z_dir.y, decimals),\n            round(self.z_dir.z, decimals),\n        )",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "workplane": {
      "name": "workplane",
      "path": "rapidcadpy.workplane",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/workplane.py",
      "description": "Workplane module - Provides a CadQuery-like fluent API for CAD operations.",
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "Workplane": {
          "name": "Workplane",
          "path": "rapidcadpy.workplane.Workplane",
          "description": "A fluent API workplane that provides CadQuery-like syntax for CAD operations.\n\nThis class maintains a working plane and allows chaining operations to build\ncomplex 3D models using a simple, intuitive syntax.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "plane",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "plane",
              "annotation": null,
              "description": null,
              "value": "plane"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.workplane.Workplane.__init__",
              "signature": "(self, plane)",
              "description": "Initialize a workplane with a given plane.\n\nArgs:\n    plane: The plane to work on",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "plane",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, plane):\n    \"\"\"\n    Initialize a workplane with a given plane.\n\n    Args:\n        plane: The plane to work on\n    \"\"\"\n    self.plane = plane\n    # Import here to avoid circular imports\n    from .cad_types import Vertex\n\n    self._current_position = Vertex(0, 0)\n    self._pending_shapes = []\n    self._current_sketch = None"
            },
            "moveTo": {
              "name": "moveTo",
              "path": "rapidcadpy.workplane.Workplane.moveTo",
              "signature": "(self, x, y) -> Workplane",
              "description": "Move the current position to the specified coordinates.\n\nArgs:\n    x: X coordinate\n    y: Y coordinate\n\nReturns:\n    Self for method chaining",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "x",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "y",
                  "annotation": "float",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "rapidcadpy.workplane.Workplane",
                "description": null
              },
              "docstring": [],
              "source": "def moveTo(self, x: float, y: float) -> \"Workplane\":\n    \"\"\"\n    Move the current position to the specified coordinates.\n\n    Args:\n        x: X coordinate\n        y: Y coordinate\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    from .cad_types import Vertex\n\n    self._current_position = Vertex(x, y)\n    return self"
            },
            "circle": {
              "name": "circle",
              "path": "rapidcadpy.workplane.Workplane.circle",
              "signature": "(self, radius) -> Workplane",
              "description": "Create a circle at the current position.\n\nArgs:\n    radius: Circle radius\n\nReturns:\n    Self for method chaining",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "radius",
                  "annotation": "float",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "rapidcadpy.workplane.Workplane",
                "description": null
              },
              "docstring": [],
              "source": "def circle(self, radius: float) -> \"Workplane\":\n    \"\"\"\n    Create a circle at the current position.\n\n    Args:\n        radius: Circle radius\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    from .primitive import Circle\n\n    circle = Circle(center=self._current_position, radius=radius)\n    self._pending_shapes.append(circle)\n    return self"
            },
            "line": {
              "name": "line",
              "path": "rapidcadpy.workplane.Workplane.line",
              "signature": "(self, x, y) -> Workplane",
              "description": "Create a line from current position to the specified coordinates.\n\nArgs:\n    x: End X coordinate\n    y: End Y coordinate\n\nReturns:\n    Self for method chaining",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "x",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "y",
                  "annotation": "float",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "rapidcadpy.workplane.Workplane",
                "description": null
              },
              "docstring": [],
              "source": "def line(self, x: float, y: float) -> \"Workplane\":\n    \"\"\"\n    Create a line from current position to the specified coordinates.\n\n    Args:\n        x: End X coordinate\n        y: End Y coordinate\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    from .cad_types import Vertex\n    from .primitive import Line\n\n    end_point = Vertex(x, y)\n    line = Line(start_point=self._current_position, end_point=end_point)\n    self._pending_shapes.append(line)\n    self._current_position = end_point\n    return self"
            },
            "lineTo": {
              "name": "lineTo",
              "path": "rapidcadpy.workplane.Workplane.lineTo",
              "signature": "(self, x, y) -> Workplane",
              "description": "Alias for line() method.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "x",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "y",
                  "annotation": "float",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "rapidcadpy.workplane.Workplane",
                "description": null
              },
              "docstring": [],
              "source": "def lineTo(self, x: float, y: float) -> \"Workplane\":\n    \"\"\"\n    Alias for line() method.\n    \"\"\"\n    return self.line(x, y)"
            },
            "rect": {
              "name": "rect",
              "path": "rapidcadpy.workplane.Workplane.rect",
              "signature": "(self, width, height, centered=True) -> Workplane",
              "description": "Create a rectangle.\n\nArgs:\n    width: Rectangle width\n    height: Rectangle height\n    centered: If True, center at current position; if False, start at current position\n\nReturns:\n    Self for method chaining",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "width",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "height",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "centered",
                  "annotation": "bool",
                  "description": null,
                  "value": "True"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "rapidcadpy.workplane.Workplane",
                "description": null
              },
              "docstring": [],
              "source": "def rect(self, width: float, height: float, centered: bool = True) -> \"Workplane\":\n    \"\"\"\n    Create a rectangle.\n\n    Args:\n        width: Rectangle width\n        height: Rectangle height\n        centered: If True, center at current position; if False, start at current position\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    from .cad_types import Vertex\n    from .primitive import Line\n\n    if centered:\n        x_offset = width / 2\n        y_offset = height / 2\n        start_x = self._current_position.x - x_offset\n        start_y = self._current_position.y - y_offset\n    else:\n        start_x = self._current_position.x\n        start_y = self._current_position.y\n\n    # Create rectangle as four lines\n    p1 = Vertex(start_x, start_y)\n    p2 = Vertex(start_x + width, start_y)\n    p3 = Vertex(start_x + width, start_y + height)\n    p4 = Vertex(start_x, start_y + height)\n\n    self._pending_shapes.extend(\n        [\n            Line(start_point=p1, end_point=p2),\n            Line(start_point=p2, end_point=p3),\n            Line(start_point=p3, end_point=p4),\n            Line(start_point=p4, end_point=p1),\n        ]\n    )\n\n    return self"
            },
            "add": {
              "name": "add",
              "path": "rapidcadpy.workplane.Workplane.add",
              "signature": "(self, other) -> SketchBuilder",
              "description": "Combine this workplane with another and return a SketchBuilder.\n\nArgs:\n    other: Another workplane to combine with\n\nReturns:\n    SketchBuilder for further operations",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "other",
                  "annotation": "Workplane",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "rapidcadpy.workplane.SketchBuilder",
                "description": null
              },
              "docstring": [],
              "source": "def add(self, other: \"Workplane\") -> \"SketchBuilder\":\n    \"\"\"\n    Combine this workplane with another and return a SketchBuilder.\n\n    Args:\n        other: Another workplane to combine with\n\n    Returns:\n        SketchBuilder for further operations\n    \"\"\"\n    # Combine pending shapes from both workplanes\n    all_shapes = self._pending_shapes + other._pending_shapes\n    return SketchBuilder(self.plane, all_shapes)"
            },
            "extrude": {
              "name": "extrude",
              "path": "rapidcadpy.workplane.Workplane.extrude",
              "signature": "(self, distance, operation='NewBodyFeatureOperation')",
              "description": "Extrude the pending shapes and return a CAD object.\n\nArgs:\n    distance: Extrusion distance\n    operation: Extrusion operation type\n\nReturns:\n    CAD object with the extruded feature",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "distance",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "operation",
                  "annotation": "str",
                  "description": null,
                  "value": "'NewBodyFeatureOperation'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def extrude(self, distance: float, operation: str = \"NewBodyFeatureOperation\"):\n    \"\"\"\n    Extrude the pending shapes and return a CAD object.\n\n    Args:\n        distance: Extrusion distance\n        operation: Extrusion operation type\n\n    Returns:\n        CAD object with the extruded feature\n    \"\"\"\n    # Create a sketch builder and extrude\n    builder = SketchBuilder(self.plane, self._pending_shapes)\n    return builder.extrude(distance, operation)"
            }
          },
          "source": "class Workplane:\n    \"\"\"\n    A fluent API workplane that provides CadQuery-like syntax for CAD operations.\n\n    This class maintains a working plane and allows chaining operations to build\n    complex 3D models using a simple, intuitive syntax.\n    \"\"\"\n\n    def __init__(self, plane):\n        \"\"\"\n        Initialize a workplane with a given plane.\n\n        Args:\n            plane: The plane to work on\n        \"\"\"\n        self.plane = plane\n        # Import here to avoid circular imports\n        from .cad_types import Vertex\n\n        self._current_position = Vertex(0, 0)\n        self._pending_shapes = []\n        self._current_sketch = None\n\n    def moveTo(self, x: float, y: float) -> \"Workplane\":\n        \"\"\"\n        Move the current position to the specified coordinates.\n\n        Args:\n            x: X coordinate\n            y: Y coordinate\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        from .cad_types import Vertex\n\n        self._current_position = Vertex(x, y)\n        return self\n\n    def circle(self, radius: float) -> \"Workplane\":\n        \"\"\"\n        Create a circle at the current position.\n\n        Args:\n            radius: Circle radius\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        from .primitive import Circle\n\n        circle = Circle(center=self._current_position, radius=radius)\n        self._pending_shapes.append(circle)\n        return self\n\n    def line(self, x: float, y: float) -> \"Workplane\":\n        \"\"\"\n        Create a line from current position to the specified coordinates.\n\n        Args:\n            x: End X coordinate\n            y: End Y coordinate\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        from .cad_types import Vertex\n        from .primitive import Line\n\n        end_point = Vertex(x, y)\n        line = Line(start_point=self._current_position, end_point=end_point)\n        self._pending_shapes.append(line)\n        self._current_position = end_point\n        return self\n\n    def lineTo(self, x: float, y: float) -> \"Workplane\":\n        \"\"\"\n        Alias for line() method.\n        \"\"\"\n        return self.line(x, y)\n\n    def rect(self, width: float, height: float, centered: bool = True) -> \"Workplane\":\n        \"\"\"\n        Create a rectangle.\n\n        Args:\n            width: Rectangle width\n            height: Rectangle height\n            centered: If True, center at current position; if False, start at current position\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        from .cad_types import Vertex\n        from .primitive import Line\n\n        if centered:\n            x_offset = width / 2\n            y_offset = height / 2\n            start_x = self._current_position.x - x_offset\n            start_y = self._current_position.y - y_offset\n        else:\n            start_x = self._current_position.x\n            start_y = self._current_position.y\n\n        # Create rectangle as four lines\n        p1 = Vertex(start_x, start_y)\n        p2 = Vertex(start_x + width, start_y)\n        p3 = Vertex(start_x + width, start_y + height)\n        p4 = Vertex(start_x, start_y + height)\n\n        self._pending_shapes.extend(\n            [\n                Line(start_point=p1, end_point=p2),\n                Line(start_point=p2, end_point=p3),\n                Line(start_point=p3, end_point=p4),\n                Line(start_point=p4, end_point=p1),\n            ]\n        )\n\n        return self\n\n    def add(self, other: \"Workplane\") -> \"SketchBuilder\":\n        \"\"\"\n        Combine this workplane with another and return a SketchBuilder.\n\n        Args:\n            other: Another workplane to combine with\n\n        Returns:\n            SketchBuilder for further operations\n        \"\"\"\n        # Combine pending shapes from both workplanes\n        all_shapes = self._pending_shapes + other._pending_shapes\n        return SketchBuilder(self.plane, all_shapes)\n\n    def extrude(self, distance: float, operation: str = \"NewBodyFeatureOperation\"):\n        \"\"\"\n        Extrude the pending shapes and return a CAD object.\n\n        Args:\n            distance: Extrusion distance\n            operation: Extrusion operation type\n\n        Returns:\n            CAD object with the extruded feature\n        \"\"\"\n        # Create a sketch builder and extrude\n        builder = SketchBuilder(self.plane, self._pending_shapes)\n        return builder.extrude(distance, operation)",
          "inherited_members": {}
        },
        "SketchBuilder": {
          "name": "SketchBuilder",
          "path": "rapidcadpy.workplane.SketchBuilder",
          "description": "Builder class that converts pending shapes into sketches and manages extrusion.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "plane",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "shapes",
              "annotation": "List",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "plane",
              "annotation": null,
              "description": null,
              "value": "plane"
            },
            {
              "name": "shapes",
              "annotation": null,
              "description": null,
              "value": "shapes"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.workplane.SketchBuilder.__init__",
              "signature": "(self, plane, shapes)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "plane",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "shapes",
                  "annotation": "List",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, plane, shapes: List):\n    self.plane = plane\n    self.shapes = shapes"
            },
            "extrude": {
              "name": "extrude",
              "path": "rapidcadpy.workplane.SketchBuilder.extrude",
              "signature": "(self, distance, operation='NewBodyFeatureOperation')",
              "description": "Extrude the shapes to create a 3D solid.\n\nArgs:\n    distance: Extrusion distance\n    operation: Extrusion operation type\n\nReturns:\n    CAD object with the extruded feature",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "distance",
                  "annotation": "float",
                  "description": null,
                  "value": null
                },
                {
                  "name": "operation",
                  "annotation": "str",
                  "description": null,
                  "value": "'NewBodyFeatureOperation'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def extrude(self, distance: float, operation: str = \"NewBodyFeatureOperation\"):\n    \"\"\"\n    Extrude the shapes to create a 3D solid.\n\n    Args:\n        distance: Extrusion distance\n        operation: Extrusion operation type\n\n    Returns:\n        CAD object with the extruded feature\n    \"\"\"\n    from .cad import Cad\n    from .extrude import Extrude\n    from .sketch import Sketch\n    from .sketch_extrude import SketchExtrude\n    from .wire import Wire\n\n    # Create a wire from the shapes\n    wire = Wire(edges=self.shapes)\n\n    # Create a sketch with the wire\n    sketch = Sketch(outer_wire=wire, inner_wires=[])\n\n    # Set the sketch_plane attribute directly on the sketch object\n    sketch.sketch_plane = self.plane\n\n    # Create extrude definition\n    extrude = Extrude(\n        extent_one=distance,\n        extent_two=0,\n        direction=1,\n        operation=operation,\n        taper_angle_one=0,\n        taper_angle_two=0,\n    )\n\n    # Create sketch extrude feature\n    sketch_extrude = SketchExtrude(\n        sketch=[sketch], extrude=extrude, sketch_plane=self.plane\n    )\n\n    # Return as CAD object\n    return Cad(construction_sequence=[sketch_extrude])"
            }
          },
          "source": "class SketchBuilder:\n    \"\"\"\n    Builder class that converts pending shapes into sketches and manages extrusion.\n    \"\"\"\n\n    def __init__(self, plane, shapes: List):\n        self.plane = plane\n        self.shapes = shapes\n\n    def extrude(self, distance: float, operation: str = \"NewBodyFeatureOperation\"):\n        \"\"\"\n        Extrude the shapes to create a 3D solid.\n\n        Args:\n            distance: Extrusion distance\n            operation: Extrusion operation type\n\n        Returns:\n            CAD object with the extruded feature\n        \"\"\"\n        from .cad import Cad\n        from .extrude import Extrude\n        from .sketch import Sketch\n        from .sketch_extrude import SketchExtrude\n        from .wire import Wire\n\n        # Create a wire from the shapes\n        wire = Wire(edges=self.shapes)\n\n        # Create a sketch with the wire\n        sketch = Sketch(outer_wire=wire, inner_wires=[])\n\n        # Set the sketch_plane attribute directly on the sketch object\n        sketch.sketch_plane = self.plane\n\n        # Create extrude definition\n        extrude = Extrude(\n            extent_one=distance,\n            extent_two=0,\n            direction=1,\n            operation=operation,\n            taper_angle_one=0,\n            taper_angle_two=0,\n        )\n\n        # Create sketch extrude feature\n        sketch_extrude = SketchExtrude(\n            sketch=[sketch], extrude=extrude, sketch_plane=self.plane\n        )\n\n        # Return as CAD object\n        return Cad(construction_sequence=[sketch_extrude])",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "backend_manager": {
      "name": "backend_manager",
      "path": "rapidcadpy.backend_manager",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/backend_manager.py",
      "description": "Backend system for rapidcadpy - allows switching between different CAD backends.\n\nThis module provides a unified interface for different CAD backends (Inventor, OCC, etc.)\nand allows users to easily switch between them for the fluent API.",
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "CADBackend": {
          "name": "CADBackend",
          "path": "rapidcadpy.backend_manager.CADBackend",
          "description": "Abstract base class for CAD backends.\n\nThis defines the interface that all CAD backends must implement\nto work with the fluent API.",
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {
            "export_cad": {
              "name": "export_cad",
              "path": "rapidcadpy.backend_manager.CADBackend.export_cad",
              "signature": "(self, cad, filename=None, **kwargs) -> Any",
              "description": "Export a CAD object to the backend format.\n\nArgs:\n    cad: The CAD object to export\n    filename: Optional filename to save to\n    **kwargs: Additional backend-specific options\n\nReturns:\n    Backend-specific result (e.g., Inventor document, OCC shape, etc.)",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "cad",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "filename",
                  "annotation": "Optional[str]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Any",
                "description": null
              },
              "docstring": [],
              "source": "@abstractmethod\ndef export_cad(self, cad, filename: Optional[str] = None, **kwargs) -> Any:\n    \"\"\"\n    Export a CAD object to the backend format.\n\n    Args:\n        cad: The CAD object to export\n        filename: Optional filename to save to\n        **kwargs: Additional backend-specific options\n\n    Returns:\n        Backend-specific result (e.g., Inventor document, OCC shape, etc.)\n    \"\"\"\n    pass"
            },
            "is_available": {
              "name": "is_available",
              "path": "rapidcadpy.backend_manager.CADBackend.is_available",
              "signature": "(self) -> bool",
              "description": "Check if this backend is available and can be used.\n\nReturns:\n    True if backend is available, False otherwise",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bool",
                "description": null
              },
              "docstring": [],
              "source": "@abstractmethod\ndef is_available(self) -> bool:\n    \"\"\"\n    Check if this backend is available and can be used.\n\n    Returns:\n        True if backend is available, False otherwise\n    \"\"\"\n    pass"
            },
            "get_name": {
              "name": "get_name",
              "path": "rapidcadpy.backend_manager.CADBackend.get_name",
              "signature": "(self) -> str",
              "description": "Get the name of this backend.\n\nReturns:\n    Human-readable name of the backend",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "@abstractmethod\ndef get_name(self) -> str:\n    \"\"\"\n    Get the name of this backend.\n\n    Returns:\n        Human-readable name of the backend\n    \"\"\"\n    pass"
            }
          },
          "source": "class CADBackend(ABC):\n    \"\"\"\n    Abstract base class for CAD backends.\n\n    This defines the interface that all CAD backends must implement\n    to work with the fluent API.\n    \"\"\"\n\n    @abstractmethod\n    def export_cad(self, cad, filename: Optional[str] = None, **kwargs) -> Any:\n        \"\"\"\n        Export a CAD object to the backend format.\n\n        Args:\n            cad: The CAD object to export\n            filename: Optional filename to save to\n            **kwargs: Additional backend-specific options\n\n        Returns:\n            Backend-specific result (e.g., Inventor document, OCC shape, etc.)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_available(self) -> bool:\n        \"\"\"\n        Check if this backend is available and can be used.\n\n        Returns:\n            True if backend is available, False otherwise\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_name(self) -> str:\n        \"\"\"\n        Get the name of this backend.\n\n        Returns:\n            Human-readable name of the backend\n        \"\"\"\n        pass",
          "inherited_members": {}
        },
        "InventorBackend": {
          "name": "InventorBackend",
          "path": "rapidcadpy.backend_manager.InventorBackend",
          "description": "Inventor backend using the existing InventorIntegration.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.backend_manager.InventorBackend.__init__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self):\n    self._integration = None\n    self._initialize_integration()"
            },
            "_initialize_integration": {
              "name": "_initialize_integration",
              "path": "rapidcadpy.backend_manager.InventorBackend._initialize_integration",
              "signature": "(self)",
              "description": "Initialize the Inventor integration if available.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _initialize_integration(self):\n    \"\"\"Initialize the Inventor integration if available.\"\"\"\n    try:\n        from .integrations.inventor_integration import InventorIntegration\n\n        self._integration = InventorIntegration()\n    except Exception as e:\n        print(f\"Warning: Could not initialize Inventor backend: {e}\")\n        self._integration = None"
            },
            "export_cad": {
              "name": "export_cad",
              "path": "rapidcadpy.backend_manager.InventorBackend.export_cad",
              "signature": "(self, cad, filename=None, **kwargs) -> Any",
              "description": "Export CAD to Inventor format with enhanced saving options.\n\nArgs:\n    cad: CAD object to export\n    filename: Optional filename to save (.ipt file)\n    **kwargs: Additional options:\n        - close_on_save (bool): Close document after saving (default: False)\n        - save_as_copy (bool): Save as copy without changing current document (default: False)\n        - overwrite (bool): Overwrite existing file if it exists (default: True)\n        - visible (bool): Make Inventor application visible (default: current state)\n\nReturns:\n    Inventor part document object",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "cad",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "filename",
                  "annotation": "Optional[str]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Any",
                "description": null
              },
              "docstring": [],
              "source": "def export_cad(self, cad, filename: Optional[str] = None, **kwargs) -> Any:\n    \"\"\"\n    Export CAD to Inventor format with enhanced saving options.\n\n    Args:\n        cad: CAD object to export\n        filename: Optional filename to save (.ipt file)\n        **kwargs: Additional options:\n            - close_on_save (bool): Close document after saving (default: False)\n            - save_as_copy (bool): Save as copy without changing current document (default: False)\n            - overwrite (bool): Overwrite existing file if it exists (default: True)\n            - visible (bool): Make Inventor application visible (default: current state)\n\n    Returns:\n        Inventor part document object\n    \"\"\"\n    if not self.is_available():\n        raise RuntimeError(\"Inventor backend is not available\")\n\n    close_on_save = kwargs.get(\"close_on_save\", False)\n    save_as_copy = kwargs.get(\"save_as_copy\", False)\n    overwrite = kwargs.get(\"overwrite\", True)\n    visible = kwargs.get(\"visible\", None)\n\n    # Set Inventor visibility if specified\n    if visible is not None:\n        self._integration.inventor_app.Visible = visible\n\n    # Export to Inventor\n    result = self._integration.to_inventor(cad, filename, close_on_save)\n\n    # Enhanced saving logic\n    if filename:\n        # Ensure .ipt extension\n        if not filename.lower().endswith(\".ipt\"):\n            filename = filename + \".ipt\"\n\n        import os\n\n        if os.path.exists(filename) and not overwrite:\n            raise FileExistsError(\n                f\"File {filename} already exists and overwrite=False\"\n            )\n\n        try:\n            if save_as_copy:\n                # Save as copy without changing the current document\n                self._integration.part_doc.SaveAs(\n                    filename, True\n                )  # True = SaveCopyAs\n                print(f\"\u2713 Saved copy to: {filename}\")\n            else:\n                # Regular save\n                self._integration.part_doc.SaveAs(filename, False)\n                print(f\"\u2713 Saved Inventor file: {filename}\")\n\n            if close_on_save:\n                self._integration.part_doc.Close()\n                print(\"\u2713 Closed Inventor document\")\n\n        except Exception as e:\n            print(f\"Warning: Could not save file {filename}: {e}\")\n\n    return result"
            },
            "save_ipt": {
              "name": "save_ipt",
              "path": "rapidcadpy.backend_manager.InventorBackend.save_ipt",
              "signature": "(self, cad, filename, **kwargs) -> bool",
              "description": "Convenience method specifically for saving .ipt files.\n\nArgs:\n    cad: CAD object to export\n    filename: Filename for the .ipt file (extension added automatically)\n    **kwargs: Same options as export_cad\n\nReturns:\n    True if save was successful, False otherwise",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "cad",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "filename",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bool",
                "description": null
              },
              "docstring": [],
              "source": "def save_ipt(self, cad, filename: str, **kwargs) -> bool:\n    \"\"\"\n    Convenience method specifically for saving .ipt files.\n\n    Args:\n        cad: CAD object to export\n        filename: Filename for the .ipt file (extension added automatically)\n        **kwargs: Same options as export_cad\n\n    Returns:\n        True if save was successful, False otherwise\n    \"\"\"\n    try:\n        self.export_cad(cad, filename, **kwargs)\n        return True\n    except Exception as e:\n        print(f\"Failed to save .ipt file: {e}\")\n        return False"
            },
            "is_available": {
              "name": "is_available",
              "path": "rapidcadpy.backend_manager.InventorBackend.is_available",
              "signature": "(self) -> bool",
              "description": "Check if Inventor backend is available.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bool",
                "description": null
              },
              "docstring": [],
              "source": "def is_available(self) -> bool:\n    \"\"\"Check if Inventor backend is available.\"\"\"\n    return self._integration is not None"
            },
            "get_name": {
              "name": "get_name",
              "path": "rapidcadpy.backend_manager.InventorBackend.get_name",
              "signature": "(self) -> str",
              "description": "Get backend name.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def get_name(self) -> str:\n    \"\"\"Get backend name.\"\"\"\n    return \"Inventor\""
            },
            "get_integration": {
              "name": "get_integration",
              "path": "rapidcadpy.backend_manager.InventorBackend.get_integration",
              "signature": "(self)",
              "description": "Get the underlying InventorIntegration instance.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def get_integration(self):\n    \"\"\"Get the underlying InventorIntegration instance.\"\"\"\n    return self._integration"
            }
          },
          "source": "class InventorBackend(CADBackend):\n    \"\"\"\n    Inventor backend using the existing InventorIntegration.\n    \"\"\"\n\n    def __init__(self):\n        self._integration = None\n        self._initialize_integration()\n\n    def _initialize_integration(self):\n        \"\"\"Initialize the Inventor integration if available.\"\"\"\n        try:\n            from .integrations.inventor_integration import InventorIntegration\n\n            self._integration = InventorIntegration()\n        except Exception as e:\n            print(f\"Warning: Could not initialize Inventor backend: {e}\")\n            self._integration = None\n\n    def export_cad(self, cad, filename: Optional[str] = None, **kwargs) -> Any:\n        \"\"\"\n        Export CAD to Inventor format with enhanced saving options.\n\n        Args:\n            cad: CAD object to export\n            filename: Optional filename to save (.ipt file)\n            **kwargs: Additional options:\n                - close_on_save (bool): Close document after saving (default: False)\n                - save_as_copy (bool): Save as copy without changing current document (default: False)\n                - overwrite (bool): Overwrite existing file if it exists (default: True)\n                - visible (bool): Make Inventor application visible (default: current state)\n\n        Returns:\n            Inventor part document object\n        \"\"\"\n        if not self.is_available():\n            raise RuntimeError(\"Inventor backend is not available\")\n\n        close_on_save = kwargs.get(\"close_on_save\", False)\n        save_as_copy = kwargs.get(\"save_as_copy\", False)\n        overwrite = kwargs.get(\"overwrite\", True)\n        visible = kwargs.get(\"visible\", None)\n\n        # Set Inventor visibility if specified\n        if visible is not None:\n            self._integration.inventor_app.Visible = visible\n\n        # Export to Inventor\n        result = self._integration.to_inventor(cad, filename, close_on_save)\n\n        # Enhanced saving logic\n        if filename:\n            # Ensure .ipt extension\n            if not filename.lower().endswith(\".ipt\"):\n                filename = filename + \".ipt\"\n\n            import os\n\n            if os.path.exists(filename) and not overwrite:\n                raise FileExistsError(\n                    f\"File {filename} already exists and overwrite=False\"\n                )\n\n            try:\n                if save_as_copy:\n                    # Save as copy without changing the current document\n                    self._integration.part_doc.SaveAs(\n                        filename, True\n                    )  # True = SaveCopyAs\n                    print(f\"\u2713 Saved copy to: {filename}\")\n                else:\n                    # Regular save\n                    self._integration.part_doc.SaveAs(filename, False)\n                    print(f\"\u2713 Saved Inventor file: {filename}\")\n\n                if close_on_save:\n                    self._integration.part_doc.Close()\n                    print(\"\u2713 Closed Inventor document\")\n\n            except Exception as e:\n                print(f\"Warning: Could not save file {filename}: {e}\")\n\n        return result\n\n    def save_ipt(self, cad, filename: str, **kwargs) -> bool:\n        \"\"\"\n        Convenience method specifically for saving .ipt files.\n\n        Args:\n            cad: CAD object to export\n            filename: Filename for the .ipt file (extension added automatically)\n            **kwargs: Same options as export_cad\n\n        Returns:\n            True if save was successful, False otherwise\n        \"\"\"\n        try:\n            self.export_cad(cad, filename, **kwargs)\n            return True\n        except Exception as e:\n            print(f\"Failed to save .ipt file: {e}\")\n            return False\n\n    def is_available(self) -> bool:\n        \"\"\"Check if Inventor backend is available.\"\"\"\n        return self._integration is not None\n\n    def get_name(self) -> str:\n        \"\"\"Get backend name.\"\"\"\n        return \"Inventor\"\n\n    def get_integration(self):\n        \"\"\"Get the underlying InventorIntegration instance.\"\"\"\n        return self._integration",
          "inherited_members": {}
        },
        "OCCBackend": {
          "name": "OCCBackend",
          "path": "rapidcadpy.backend_manager.OCCBackend",
          "description": "OpenCASCADE (OCC) backend using the existing OccIntegration.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.backend_manager.OCCBackend.__init__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self):\n    self._integration = None\n    self._initialize_integration()"
            },
            "_initialize_integration": {
              "name": "_initialize_integration",
              "path": "rapidcadpy.backend_manager.OCCBackend._initialize_integration",
              "signature": "(self)",
              "description": "Initialize the OCC integration if available.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _initialize_integration(self):\n    \"\"\"Initialize the OCC integration if available.\"\"\"\n    try:\n        from .integrations.occ_integration import OccIntegration\n\n        self._integration = OccIntegration()\n    except Exception as e:\n        print(f\"Warning: Could not initialize OCC backend: {e}\")\n        self._integration = None"
            },
            "export_cad": {
              "name": "export_cad",
              "path": "rapidcadpy.backend_manager.OCCBackend.export_cad",
              "signature": "(self, cad, filename=None, **kwargs) -> Any",
              "description": "Export CAD to OCC format (STEP, BREP, etc.).",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "cad",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "filename",
                  "annotation": "Optional[str]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Any",
                "description": null
              },
              "docstring": [],
              "source": "def export_cad(self, cad, filename: Optional[str] = None, **kwargs) -> Any:\n    \"\"\"Export CAD to OCC format (STEP, BREP, etc.).\"\"\"\n    if not self.is_available():\n        raise RuntimeError(\"OCC backend is not available\")\n\n    if filename:\n        if filename.endswith(\".step\") or filename.endswith(\".stp\"):\n            return cad.to_step(filename)\n        elif filename.endswith(\".brep\"):\n            return cad.to_brep(filename)\n        elif filename.endswith(\".stl\"):\n            return cad.to_stl(filename)\n        else:\n            # Default to STEP\n            return cad.to_step(filename)\n    else:\n        # Return the OCC shape object\n        return cad.to_occ()"
            },
            "is_available": {
              "name": "is_available",
              "path": "rapidcadpy.backend_manager.OCCBackend.is_available",
              "signature": "(self) -> bool",
              "description": "Check if OCC backend is available.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bool",
                "description": null
              },
              "docstring": [],
              "source": "def is_available(self) -> bool:\n    \"\"\"Check if OCC backend is available.\"\"\"\n    if self._integration is None:\n        return False\n    try:\n        # Check if the CAD object has OCC methods\n        from .cad import Cad\n\n        return hasattr(Cad, \"to_occ\") and hasattr(Cad, \"to_step\")\n    except:\n        return False"
            },
            "get_name": {
              "name": "get_name",
              "path": "rapidcadpy.backend_manager.OCCBackend.get_name",
              "signature": "(self) -> str",
              "description": "Get backend name.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def get_name(self) -> str:\n    \"\"\"Get backend name.\"\"\"\n    return \"OpenCASCADE\""
            }
          },
          "source": "class OCCBackend(CADBackend):\n    \"\"\"\n    OpenCASCADE (OCC) backend using the existing OccIntegration.\n    \"\"\"\n\n    def __init__(self):\n        self._integration = None\n        self._initialize_integration()\n\n    def _initialize_integration(self):\n        \"\"\"Initialize the OCC integration if available.\"\"\"\n        try:\n            from .integrations.occ_integration import OccIntegration\n\n            self._integration = OccIntegration()\n        except Exception as e:\n            print(f\"Warning: Could not initialize OCC backend: {e}\")\n            self._integration = None\n\n    def export_cad(self, cad, filename: Optional[str] = None, **kwargs) -> Any:\n        \"\"\"Export CAD to OCC format (STEP, BREP, etc.).\"\"\"\n        if not self.is_available():\n            raise RuntimeError(\"OCC backend is not available\")\n\n        if filename:\n            if filename.endswith(\".step\") or filename.endswith(\".stp\"):\n                return cad.to_step(filename)\n            elif filename.endswith(\".brep\"):\n                return cad.to_brep(filename)\n            elif filename.endswith(\".stl\"):\n                return cad.to_stl(filename)\n            else:\n                # Default to STEP\n                return cad.to_step(filename)\n        else:\n            # Return the OCC shape object\n            return cad.to_occ()\n\n    def is_available(self) -> bool:\n        \"\"\"Check if OCC backend is available.\"\"\"\n        if self._integration is None:\n            return False\n        try:\n            # Check if the CAD object has OCC methods\n            from .cad import Cad\n\n            return hasattr(Cad, \"to_occ\") and hasattr(Cad, \"to_step\")\n        except:\n            return False\n\n    def get_name(self) -> str:\n        \"\"\"Get backend name.\"\"\"\n        return \"OpenCASCADE\"",
          "inherited_members": {}
        },
        "BackendManager": {
          "name": "BackendManager",
          "path": "rapidcadpy.backend_manager.BackendManager",
          "description": "Manager for CAD backends - handles registration and selection.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.backend_manager.BackendManager.__init__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self):\n    self._backends: Dict[str, Type[CADBackend]] = {}\n    self._default_backend: Optional[str] = None\n    self._current_backend: Optional[CADBackend] = None\n\n    # Register built-in backends\n    self.register_backend(\"inventor\", InventorBackend)\n    self.register_backend(\"occ\", OCCBackend)\n    self.register_backend(\"opencascade\", OCCBackend)  # Alias\n\n    # Set default backend\n    self._auto_select_default()"
            },
            "register_backend": {
              "name": "register_backend",
              "path": "rapidcadpy.backend_manager.BackendManager.register_backend",
              "signature": "(self, name, backend_class)",
              "description": "Register a new backend.\n\nArgs:\n    name: Name to register the backend under\n    backend_class: Backend class to register",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "backend_class",
                  "annotation": "Type[CADBackend]",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def register_backend(self, name: str, backend_class: Type[CADBackend]):\n    \"\"\"\n    Register a new backend.\n\n    Args:\n        name: Name to register the backend under\n        backend_class: Backend class to register\n    \"\"\"\n    self._backends[name.lower()] = backend_class"
            },
            "get_available_backends": {
              "name": "get_available_backends",
              "path": "rapidcadpy.backend_manager.BackendManager.get_available_backends",
              "signature": "(self) -> Dict[str, bool]",
              "description": "Get all registered backends and their availability.\n\nReturns:\n    Dictionary mapping backend names to availability status",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Dict[str, bool]",
                "description": null
              },
              "docstring": [],
              "source": "def get_available_backends(self) -> Dict[str, bool]:\n    \"\"\"\n    Get all registered backends and their availability.\n\n    Returns:\n        Dictionary mapping backend names to availability status\n    \"\"\"\n    result = {}\n    for name, backend_class in self._backends.items():\n        try:\n            backend = backend_class()\n            result[name] = backend.is_available()\n        except:\n            result[name] = False\n    return result"
            },
            "set_backend": {
              "name": "set_backend",
              "path": "rapidcadpy.backend_manager.BackendManager.set_backend",
              "signature": "(self, name) -> bool",
              "description": "Set the current backend.\n\nArgs:\n    name: Name of the backend to use\n\nReturns:\n    True if backend was successfully set, False otherwise",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bool",
                "description": null
              },
              "docstring": [],
              "source": "def set_backend(self, name: str) -> bool:\n    \"\"\"\n    Set the current backend.\n\n    Args:\n        name: Name of the backend to use\n\n    Returns:\n        True if backend was successfully set, False otherwise\n    \"\"\"\n    name = name.lower()\n    if name not in self._backends:\n        print(f\"Backend '{name}' is not registered\")\n        return False\n\n    try:\n        backend_class = self._backends[name]\n        backend = backend_class()\n\n        if not backend.is_available():\n            print(f\"Backend '{name}' is not available\")\n            return False\n\n        self._current_backend = backend\n        print(f\"Set backend to: {backend.get_name()}\")\n        return True\n\n    except Exception as e:\n        print(f\"Failed to initialize backend '{name}': {e}\")\n        return False"
            },
            "get_current_backend": {
              "name": "get_current_backend",
              "path": "rapidcadpy.backend_manager.BackendManager.get_current_backend",
              "signature": "(self) -> Optional[CADBackend]",
              "description": "Get the currently selected backend.\n\nReturns:\n    Current backend instance, or None if no backend is set",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Optional[rapidcadpy.backend_manager.CADBackend]",
                "description": null
              },
              "docstring": [],
              "source": "def get_current_backend(self) -> Optional[CADBackend]:\n    \"\"\"\n    Get the currently selected backend.\n\n    Returns:\n        Current backend instance, or None if no backend is set\n    \"\"\"\n    return self._current_backend"
            },
            "get_backend_name": {
              "name": "get_backend_name",
              "path": "rapidcadpy.backend_manager.BackendManager.get_backend_name",
              "signature": "(self) -> Optional[str]",
              "description": "Get the name of the current backend.\n\nReturns:\n    Name of current backend, or None if no backend is set",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Optional[str]",
                "description": null
              },
              "docstring": [],
              "source": "def get_backend_name(self) -> Optional[str]:\n    \"\"\"\n    Get the name of the current backend.\n\n    Returns:\n        Name of current backend, or None if no backend is set\n    \"\"\"\n    if self._current_backend:\n        return self._current_backend.get_name()\n    return None"
            },
            "_auto_select_default": {
              "name": "_auto_select_default",
              "path": "rapidcadpy.backend_manager.BackendManager._auto_select_default",
              "signature": "(self)",
              "description": "Automatically select the best available backend.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _auto_select_default(self):\n    \"\"\"Automatically select the best available backend.\"\"\"\n    # Priority order: Inventor (if available), then OCC\n    priority_order = [\"inventor\", \"occ\"]\n\n    for backend_name in priority_order:\n        if self.set_backend(backend_name):\n            self._default_backend = backend_name\n            break\n\n    if not self._current_backend:\n        print(\"Warning: No CAD backend is available\")"
            },
            "export_cad": {
              "name": "export_cad",
              "path": "rapidcadpy.backend_manager.BackendManager.export_cad",
              "signature": "(self, cad, filename=None, **kwargs) -> Any",
              "description": "Export CAD using the current backend.\n\nArgs:\n    cad: CAD object to export\n    filename: Optional filename\n    **kwargs: Backend-specific options\n\nReturns:\n    Backend-specific result",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "cad",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "filename",
                  "annotation": "Optional[str]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Any",
                "description": null
              },
              "docstring": [],
              "source": "def export_cad(self, cad, filename: Optional[str] = None, **kwargs) -> Any:\n    \"\"\"\n    Export CAD using the current backend.\n\n    Args:\n        cad: CAD object to export\n        filename: Optional filename\n        **kwargs: Backend-specific options\n\n    Returns:\n        Backend-specific result\n    \"\"\"\n    if not self._current_backend:\n        raise RuntimeError(\"No backend is currently set\")\n\n    return self._current_backend.export_cad(cad, filename, **kwargs)"
            }
          },
          "source": "class BackendManager:\n    \"\"\"\n    Manager for CAD backends - handles registration and selection.\n    \"\"\"\n\n    def __init__(self):\n        self._backends: Dict[str, Type[CADBackend]] = {}\n        self._default_backend: Optional[str] = None\n        self._current_backend: Optional[CADBackend] = None\n\n        # Register built-in backends\n        self.register_backend(\"inventor\", InventorBackend)\n        self.register_backend(\"occ\", OCCBackend)\n        self.register_backend(\"opencascade\", OCCBackend)  # Alias\n\n        # Set default backend\n        self._auto_select_default()\n\n    def register_backend(self, name: str, backend_class: Type[CADBackend]):\n        \"\"\"\n        Register a new backend.\n\n        Args:\n            name: Name to register the backend under\n            backend_class: Backend class to register\n        \"\"\"\n        self._backends[name.lower()] = backend_class\n\n    def get_available_backends(self) -> Dict[str, bool]:\n        \"\"\"\n        Get all registered backends and their availability.\n\n        Returns:\n            Dictionary mapping backend names to availability status\n        \"\"\"\n        result = {}\n        for name, backend_class in self._backends.items():\n            try:\n                backend = backend_class()\n                result[name] = backend.is_available()\n            except:\n                result[name] = False\n        return result\n\n    def set_backend(self, name: str) -> bool:\n        \"\"\"\n        Set the current backend.\n\n        Args:\n            name: Name of the backend to use\n\n        Returns:\n            True if backend was successfully set, False otherwise\n        \"\"\"\n        name = name.lower()\n        if name not in self._backends:\n            print(f\"Backend '{name}' is not registered\")\n            return False\n\n        try:\n            backend_class = self._backends[name]\n            backend = backend_class()\n\n            if not backend.is_available():\n                print(f\"Backend '{name}' is not available\")\n                return False\n\n            self._current_backend = backend\n            print(f\"Set backend to: {backend.get_name()}\")\n            return True\n\n        except Exception as e:\n            print(f\"Failed to initialize backend '{name}': {e}\")\n            return False\n\n    def get_current_backend(self) -> Optional[CADBackend]:\n        \"\"\"\n        Get the currently selected backend.\n\n        Returns:\n            Current backend instance, or None if no backend is set\n        \"\"\"\n        return self._current_backend\n\n    def get_backend_name(self) -> Optional[str]:\n        \"\"\"\n        Get the name of the current backend.\n\n        Returns:\n            Name of current backend, or None if no backend is set\n        \"\"\"\n        if self._current_backend:\n            return self._current_backend.get_name()\n        return None\n\n    def _auto_select_default(self):\n        \"\"\"Automatically select the best available backend.\"\"\"\n        # Priority order: Inventor (if available), then OCC\n        priority_order = [\"inventor\", \"occ\"]\n\n        for backend_name in priority_order:\n            if self.set_backend(backend_name):\n                self._default_backend = backend_name\n                break\n\n        if not self._current_backend:\n            print(\"Warning: No CAD backend is available\")\n\n    def export_cad(self, cad, filename: Optional[str] = None, **kwargs) -> Any:\n        \"\"\"\n        Export CAD using the current backend.\n\n        Args:\n            cad: CAD object to export\n            filename: Optional filename\n            **kwargs: Backend-specific options\n\n        Returns:\n            Backend-specific result\n        \"\"\"\n        if not self._current_backend:\n            raise RuntimeError(\"No backend is currently set\")\n\n        return self._current_backend.export_cad(cad, filename, **kwargs)",
          "inherited_members": {}
        },
        "BackendProperty": {
          "name": "BackendProperty",
          "path": "rapidcadpy.backend_manager.BackendProperty",
          "description": "Property-style interface for setting/getting the current backend.",
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__get__": {
              "name": "__get__",
              "path": "rapidcadpy.backend_manager.BackendProperty.__get__",
              "signature": "(self, obj, objtype=None)",
              "description": "Get the current backend name.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "obj",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "objtype",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __get__(self, obj, objtype=None):\n    \"\"\"Get the current backend name.\"\"\"\n    backend_name = _backend_manager.get_backend_name()\n    return backend_name.lower() if backend_name else None"
            },
            "__set__": {
              "name": "__set__",
              "path": "rapidcadpy.backend_manager.BackendProperty.__set__",
              "signature": "(self, obj, value)",
              "description": "Set the current backend.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "obj",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "value",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __set__(self, obj, value):\n    \"\"\"Set the current backend.\"\"\"\n    if isinstance(value, str):\n        success = _backend_manager.set_backend(value)\n        if not success:\n            available = list(_backend_manager.get_available_backends().keys())\n            raise ValueError(\n                f\"Backend '{value}' is not available. Available backends: {available}\"\n            )\n    else:\n        raise TypeError(\"Backend must be a string\")"
            }
          },
          "source": "class BackendProperty:\n    \"\"\"Property-style interface for setting/getting the current backend.\"\"\"\n\n    def __get__(self, obj, objtype=None):\n        \"\"\"Get the current backend name.\"\"\"\n        backend_name = _backend_manager.get_backend_name()\n        return backend_name.lower() if backend_name else None\n\n    def __set__(self, obj, value):\n        \"\"\"Set the current backend.\"\"\"\n        if isinstance(value, str):\n            success = _backend_manager.set_backend(value)\n            if not success:\n                available = list(_backend_manager.get_available_backends().keys())\n                raise ValueError(\n                    f\"Backend '{value}' is not available. Available backends: {available}\"\n                )\n        else:\n            raise TypeError(\"Backend must be a string\")",
          "inherited_members": {}
        }
      },
      "functions": {
        "set_backend": {
          "name": "set_backend",
          "path": "rapidcadpy.backend_manager.set_backend",
          "signature": "(name) -> bool",
          "description": "Set the global CAD backend.\n\nArgs:\n    name: Name of the backend ('inventor', 'occ', 'opencascade')\n\nReturns:\n    True if successful, False otherwise",
          "parameters": [
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": "bool",
            "description": null
          },
          "docstring": [],
          "source": "def set_backend(name: str) -> bool:\n    \"\"\"\n    Set the global CAD backend.\n\n    Args:\n        name: Name of the backend ('inventor', 'occ', 'opencascade')\n\n    Returns:\n        True if successful, False otherwise\n    \"\"\"\n    return _backend_manager.set_backend(name)"
        },
        "get_current_backend": {
          "name": "get_current_backend",
          "path": "rapidcadpy.backend_manager.get_current_backend",
          "signature": "() -> Optional[str]",
          "description": "Get the name of the current global backend.\n\nReturns:\n    Name of current backend or None",
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": "typing.Optional[str]",
            "description": null
          },
          "docstring": [],
          "source": "def get_current_backend() -> Optional[str]:\n    \"\"\"\n    Get the name of the current global backend.\n\n    Returns:\n        Name of current backend or None\n    \"\"\"\n    backend_name = _backend_manager.get_backend_name()\n    return backend_name.lower() if backend_name else None"
        },
        "get_available_backends": {
          "name": "get_available_backends",
          "path": "rapidcadpy.backend_manager.get_available_backends",
          "signature": "() -> Dict[str, bool]",
          "description": "Get all available backends.\n\nReturns:\n    Dictionary mapping backend names to availability",
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": "typing.Dict[str, bool]",
            "description": null
          },
          "docstring": [],
          "source": "def get_available_backends() -> Dict[str, bool]:\n    \"\"\"\n    Get all available backends.\n\n    Returns:\n        Dictionary mapping backend names to availability\n    \"\"\"\n    return _backend_manager.get_available_backends()"
        },
        "export_with_backend": {
          "name": "export_with_backend",
          "path": "rapidcadpy.backend_manager.export_with_backend",
          "signature": "(cad, filename=None, **kwargs) -> Any",
          "description": "Export CAD using the current global backend.\n\nArgs:\n    cad: CAD object to export\n    filename: Optional filename\n    **kwargs: Backend-specific options\n\nReturns:\n    Backend-specific result",
          "parameters": [
            {
              "name": "cad",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "filename",
              "annotation": "Optional[str]",
              "description": null,
              "value": "None"
            },
            {
              "name": "kwargs",
              "annotation": null,
              "description": null,
              "value": "{}"
            }
          ],
          "returns": {
            "name": "",
            "annotation": "typing.Any",
            "description": null
          },
          "docstring": [],
          "source": "def export_with_backend(cad, filename: Optional[str] = None, **kwargs) -> Any:\n    \"\"\"\n    Export CAD using the current global backend.\n\n    Args:\n        cad: CAD object to export\n        filename: Optional filename\n        **kwargs: Backend-specific options\n\n    Returns:\n        Backend-specific result\n    \"\"\"\n    return _backend_manager.export_cad(cad, filename, **kwargs)"
        },
        "_add_backend_methods_to_cad": {
          "name": "_add_backend_methods_to_cad",
          "path": "rapidcadpy.backend_manager._add_backend_methods_to_cad",
          "signature": "()",
          "description": "Add backend methods to the CAD class.",
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def _add_backend_methods_to_cad():\n    \"\"\"Add backend methods to the CAD class.\"\"\"\n    from .cad import Cad\n\n    def to_inventor(\n        self, filename: Optional[str] = None, close_on_save: bool = False, **kwargs\n    ):\n        \"\"\"\n        Export this CAD object to Inventor using the current backend.\n\n        Args:\n            filename: Optional filename to save to\n            close_on_save: Whether to close the document after saving\n            **kwargs: Additional backend-specific options\n        \"\"\"\n        # Temporarily switch to Inventor backend if not current\n        original_backend = get_current_backend()\n\n        try:\n            if original_backend != \"inventor\":\n                if not _backend_manager.set_backend(\"inventor\"):\n                    raise RuntimeError(\"Inventor backend is not available\")\n\n            return _backend_manager.export_cad(\n                self, filename, close_on_save=close_on_save, **kwargs\n            )\n        finally:\n            # Restore original backend if we changed it\n            if original_backend and original_backend != \"inventor\":\n                _backend_manager.set_backend(original_backend)\n\n    def to_backend(self, backend_name: str, filename: Optional[str] = None, **kwargs):\n        \"\"\"\n        Export this CAD object using a specific backend.\n\n        Args:\n            backend_name: Name of the backend to use\n            filename: Optional filename to save to\n            **kwargs: Backend-specific options\n        \"\"\"\n        # Temporarily switch to the requested backend\n        original_backend = get_current_backend()\n\n        try:\n            if not _backend_manager.set_backend(backend_name):\n                raise RuntimeError(f\"Backend '{backend_name}' is not available\")\n\n            return _backend_manager.export_cad(self, filename, **kwargs)\n        finally:\n            # Restore original backend\n            if original_backend:\n                _backend_manager.set_backend(original_backend)\n\n    def export(self, filename: Optional[str] = None, **kwargs):\n        \"\"\"\n        Export this CAD object using the current backend.\n\n        Args:\n            filename: Optional filename to save to\n            **kwargs: Backend-specific options\n        \"\"\"\n        return _backend_manager.export_cad(self, filename, **kwargs)\n\n    # Add methods to CAD class\n    Cad.to_inventor = to_inventor\n    Cad.to_backend = to_backend\n    Cad.export = export"
        }
      }
    },
    "sketch_extrude": {
      "name": "sketch_extrude",
      "path": "rapidcadpy.sketch_extrude",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/sketch_extrude.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "SketchExtrude": {
          "name": "SketchExtrude",
          "path": "rapidcadpy.sketch_extrude.SketchExtrude",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "sketch_plane",
              "annotation": "Plane",
              "description": null,
              "value": "Plane()"
            },
            {
              "name": "id",
              "annotation": "Optional[uuid.UUID]",
              "description": null,
              "value": "uuid.uuid4()"
            },
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": "'Feature'"
            },
            {
              "name": "sketch",
              "annotation": "Optional[List[Sketch]]",
              "description": null,
              "value": "None"
            },
            {
              "name": "extrude",
              "annotation": "Optional[Extrude]",
              "description": null,
              "value": "None"
            }
          ],
          "attributes": [
            {
              "name": "sketch",
              "annotation": "Optional[List[Sketch]]",
              "description": null,
              "value": "field(default=None)"
            },
            {
              "name": "extrude",
              "annotation": "Optional[Extrude]",
              "description": null,
              "value": "field(default=None)"
            },
            {
              "name": "bbox",
              "annotation": "np.ndarray",
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__str__": {
              "name": "__str__",
              "path": "rapidcadpy.sketch_extrude.SketchExtrude.__str__",
              "signature": "(self) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def __str__(self) -> str:\n    ext_str = f\"Extrude: {self.extrude.extent_one}\" if self.extrude else \"\"\n    sketch_str = \"\\n\".join([str(s) for s in self.sketch])\n    return f\"Sketch:\\n{sketch_str}\\n{ext_str}\""
            },
            "to_json": {
              "name": "to_json",
              "path": "rapidcadpy.sketch_extrude.SketchExtrude.to_json",
              "signature": "(self, index=0) -> Dict[str, Any]",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "index",
                  "annotation": "int",
                  "description": null,
                  "value": "0"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Dict[str, typing.Any]",
                "description": null
              },
              "docstring": [],
              "source": "def to_json(self, index: int = 0) -> Dict[str, Any]:\n    return {\n        \"type\": \"SketchExtrude\",\n        \"id\": str(self.id),\n        \"name\": self.name,\n        \"sketch_plane\": self.sketch_plane.to_json(),\n        \"sketch\": [s.to_json() for s in self.sketch] if self.sketch else [],\n        f\"extrude_{index}\": self.extrude.to_json() if self.extrude else None,\n    }"
            },
            "to_python": {
              "name": "to_python",
              "path": "rapidcadpy.sketch_extrude.SketchExtrude.to_python",
              "signature": "(self, index=0) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "index",
                  "annotation": "Optional[int]",
                  "description": null,
                  "value": "0"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def to_python(self, index: Optional[int] = 0) -> str:\n    variables = []\n    declarations = []\n    sketch_variables = []\n    for sketch_index, sketch in enumerate(self.sketch):\n        sketch_variables.append(f\"sketch_{sketch_index}\")\n        declarations.append(f\"{sketch.to_python(sketch_index)}\")\n    if self.extrude:\n        variables.append(f\"extrude_{index}\")\n        declarations.append(f\"extrude_{index} = {self.extrude.to_python(index)}\")\n\n    code = \"\\n\".join(declarations)\n    sketch_variable_list = \", \".join(sketch_variables)\n    sketch_variable_list = \"[\" + sketch_variable_list + \"]\"\n    code += \"\\nsketch_extrude_{} = SketchExtrude(sketch={}, extrude={})\\n\".format(\n        index, sketch_variable_list, variables[0] if variables else \"None\"\n    )\n    return code"
            },
            "__eq__": {
              "name": "__eq__",
              "path": "rapidcadpy.sketch_extrude.SketchExtrude.__eq__",
              "signature": "(self, other)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "other",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __eq__(self, other):\n    return self.sketch == other.sketch and self.extrude == other.extrude"
            },
            "flip_z_axis": {
              "name": "flip_z_axis",
              "path": "rapidcadpy.sketch_extrude.SketchExtrude.flip_z_axis",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def flip_z_axis(self):\n    for sketch in self.sketch:\n        sketch.sketch_plane.z_dir *= -1\n    if self.extrude:\n        self.extrude.extent_one = self.extrude.extent_one"
            },
            "plot": {
              "name": "plot",
              "path": "rapidcadpy.sketch_extrude.SketchExtrude.plot",
              "signature": "(self, title='Sketch Extrude', bounding_box=False)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "title",
                  "annotation": null,
                  "description": null,
                  "value": "'Sketch Extrude'"
                },
                {
                  "name": "bounding_box",
                  "annotation": null,
                  "description": null,
                  "value": "False"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def plot(self, title=\"Sketch Extrude\", bounding_box=False):\n    fig = go.Figure()\n    for sketch in self.sketch:\n        for trace in sketch.plot(return_fig=True):\n            if trace is not None:\n                fig.add_trace(trace)\n    # add the bounding box\n    if bounding_box:\n        bbox_min, bbox_max = self.bbox\n        x = [bbox_min[0], bbox_max[0], bbox_max[0], bbox_min[0], bbox_min[0]]\n        y = [bbox_min[1], bbox_min[1], bbox_max[1], bbox_max[1], bbox_min[1]]\n        fig.add_trace(go.Scatter(x=x, y=y, mode=\"lines\", name=\"Bounding Box\"))\n    fig.update_layout(\n        title=title,\n        scene=dict(aspectmode=\"cube\"),\n        xaxis=dict(scaleanchor=\"y\", title=\"X Axis\"),\n        yaxis=dict(title=\"Y Axis\"),\n        showlegend=False,\n        autosize=True,\n    )\n    fig.show()"
            },
            "__init__": {
              "name": "__init__",
              "path": "rapidcadpy.sketch_extrude.SketchExtrude.__init__",
              "signature": "(self, sketch_plane=Plane(), id=uuid.uuid4(), name='Feature', sketch=None, extrude=None) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "sketch_plane",
                  "annotation": "Plane",
                  "description": null,
                  "value": "Plane()"
                },
                {
                  "name": "id",
                  "annotation": "Optional[uuid.UUID]",
                  "description": null,
                  "value": "uuid.uuid4()"
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "'Feature'"
                },
                {
                  "name": "sketch",
                  "annotation": "Optional[List[Sketch]]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "extrude",
                  "annotation": "Optional[Extrude]",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass\nclass SketchExtrude(Feature):\n    sketch: Optional[List[Sketch]] = field(default=None)\n    extrude: Optional[Extrude] = field(default=None)\n\n    def __str__(self) -> str:\n        ext_str = f\"Extrude: {self.extrude.extent_one}\" if self.extrude else \"\"\n        sketch_str = \"\\n\".join([str(s) for s in self.sketch])\n        return f\"Sketch:\\n{sketch_str}\\n{ext_str}\"\n\n    def to_json(self, index: int = 0) -> Dict[str, Any]:\n        return {\n            \"type\": \"SketchExtrude\",\n            \"id\": str(self.id),\n            \"name\": self.name,\n            \"sketch_plane\": self.sketch_plane.to_json(),\n            \"sketch\": [s.to_json() for s in self.sketch] if self.sketch else [],\n            f\"extrude_{index}\": self.extrude.to_json() if self.extrude else None,\n        }\n\n    def to_python(self, index: Optional[int] = 0) -> str:\n        variables = []\n        declarations = []\n        sketch_variables = []\n        for sketch_index, sketch in enumerate(self.sketch):\n            sketch_variables.append(f\"sketch_{sketch_index}\")\n            declarations.append(f\"{sketch.to_python(sketch_index)}\")\n        if self.extrude:\n            variables.append(f\"extrude_{index}\")\n            declarations.append(f\"extrude_{index} = {self.extrude.to_python(index)}\")\n\n        code = \"\\n\".join(declarations)\n        sketch_variable_list = \", \".join(sketch_variables)\n        sketch_variable_list = \"[\" + sketch_variable_list + \"]\"\n        code += \"\\nsketch_extrude_{} = SketchExtrude(sketch={}, extrude={})\\n\".format(\n            index, sketch_variable_list, variables[0] if variables else \"None\"\n        )\n        return code\n\n    @property\n    def bbox(self) -> np.ndarray:\n        all_points = np.concatenate([sketch.bbox for sketch in self.sketch], axis=0)\n        bbox_min = np.min(all_points, axis=0)\n        bbox_max = np.max(all_points, axis=0)\n        bbox = np.stack([bbox_min, bbox_max], axis=0)\n        return bbox\n\n    def __eq__(self, other):\n        return self.sketch == other.sketch and self.extrude == other.extrude\n\n    def flip_z_axis(self):\n        for sketch in self.sketch:\n            sketch.sketch_plane.z_dir *= -1\n        if self.extrude:\n            self.extrude.extent_one = self.extrude.extent_one\n\n    def plot(self, title=\"Sketch Extrude\", bounding_box=False):\n        fig = go.Figure()\n        for sketch in self.sketch:\n            for trace in sketch.plot(return_fig=True):\n                if trace is not None:\n                    fig.add_trace(trace)\n        # add the bounding box\n        if bounding_box:\n            bbox_min, bbox_max = self.bbox\n            x = [bbox_min[0], bbox_max[0], bbox_max[0], bbox_min[0], bbox_min[0]]\n            y = [bbox_min[1], bbox_min[1], bbox_max[1], bbox_max[1], bbox_min[1]]\n            fig.add_trace(go.Scatter(x=x, y=y, mode=\"lines\", name=\"Bounding Box\"))\n        fig.update_layout(\n            title=title,\n            scene=dict(aspectmode=\"cube\"),\n            xaxis=dict(scaleanchor=\"y\", title=\"X Axis\"),\n            yaxis=dict(title=\"Y Axis\"),\n            showlegend=False,\n            autosize=True,\n        )\n        fig.show()",
          "inherited_members": {
            "rapidcadpy.feature.Feature": [
              {
                "kind": "attribute",
                "path": "rapidcadpy.feature.Feature.sketch_plane"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.feature.Feature.id"
              },
              {
                "kind": "attribute",
                "path": "rapidcadpy.feature.Feature.name"
              },
              {
                "kind": "function",
                "path": "rapidcadpy.feature.Feature.__post_init__"
              }
            ]
          }
        }
      },
      "functions": {}
    },
    "f360gallery_processing": {
      "name": "f360gallery_processing",
      "path": "rapidcadpy.f360gallery_processing",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/f360gallery_processing/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {
        "process_deepcad": {
          "name": "process_deepcad",
          "path": "rapidcadpy.f360gallery_processing.process_deepcad",
          "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/f360gallery_processing/process_deepcad.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "DeepCadJsonParser": {
              "name": "DeepCadJsonParser",
              "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser",
              "description": null,
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "load_json": {
                  "name": "load_json",
                  "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser.load_json",
                  "signature": "(json_file_path)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "json_file_path",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef load_json(json_file_path):\n    with open(json_file_path) as fp:\n        return json.load(fp)"
                },
                "_find_orthogonal_vector": {
                  "name": "_find_orthogonal_vector",
                  "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser._find_orthogonal_vector",
                  "signature": "(normal)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "normal",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef _find_orthogonal_vector(normal):\n    # Ensure the normal vector is a numpy array\n    normal = np.asarray(normal)\n\n    # Check for special cases where normal vector has specific components equal to zero\n    if normal[0] != 0 or normal[1] != 0:\n        # Choose (1, 0, 0) or (0, 1, 0) as a candidate vector if normal[0] and normal[1] are not both zero\n        candidate = np.array([1, 0, 0])\n        if normal[0] == 0:\n            candidate = np.array([0, 1, 0])\n    else:\n        candidate = np.array([0, 1, 0])\n\n    return np.cross(normal, candidate)"
                },
                "parse_vector": {
                  "name": "parse_vector",
                  "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser.parse_vector",
                  "signature": "(vector_dict)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "vector_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef parse_vector(vector_dict):\n    return Vector(vector_dict[\"x\"], vector_dict[\"y\"], vector_dict[\"z\"])"
                },
                "parse_curve": {
                  "name": "parse_curve",
                  "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser.parse_curve",
                  "signature": "(curve_dict, curve_name)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "curve_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "curve_name",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef parse_curve(curve_dict, curve_name):\n    if \"circle\" in curve_dict[\"type\"].lower():\n        center_point = DeepCadJsonParser._parse_point(curve_dict[\"center_point\"])\n        radius = curve_dict[\"radius\"]\n        return Circle(center_point, radius, name=curve_dict[\"curve\"])\n    elif \"line\" in curve_dict[\"type\"].lower():\n        start_point = DeepCadJsonParser._parse_point(curve_dict[\"start_point\"])\n        end_point = DeepCadJsonParser._parse_point(curve_dict[\"end_point\"])\n        return Line(\n            name=\"line_\" + curve_dict[\"curve\"],\n            start_point=start_point,\n            end_point=end_point,\n        )\n    elif \"arc\" in curve_dict[\"type\"].lower():\n        radius = curve_dict[\"radius\"]\n        start_point = DeepCadJsonParser._parse_point(curve_dict[\"start_point\"])\n        end_point = DeepCadJsonParser._parse_point(curve_dict[\"end_point\"])\n        center_point = DeepCadJsonParser._parse_point(curve_dict[\"center_point\"])\n        start_angle = curve_dict[\"start_angle\"]\n        end_angle = curve_dict[\"end_angle\"]\n        reference_vector = DeepCadJsonParser.parse_vector(\n            curve_dict[\"reference_vector\"]\n        )\n\n        ref_vec = reference_vector.normalize()\n        mid_angle = (start_angle + end_angle) / 2\n        # Rotation matrix for the midpoint angle\n        rot_matrix = np.array(\n            [\n                [np.cos(mid_angle), -np.sin(mid_angle)],\n                [np.sin(mid_angle), np.cos(mid_angle)],\n            ]\n        )\n\n        # Rotate the reference vector to get the direction for the midpoint\n        rotated_vec = rot_matrix @ ref_vec.get_2d()\n\n        # Calculate midpoint coordinates\n        mid_x = center_point[0] + rotated_vec[0] * radius\n        mid_y = center_point[1] + rotated_vec[1] * radius\n\n        return Arc(\n            start_point=start_point,\n            mid_point=Vertex(x=mid_x, y=mid_y),\n            end_point=end_point,\n            id=curve_dict[\"curve\"],\n        )"
                },
                "parse_loops": {
                  "name": "parse_loops",
                  "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser.parse_loops",
                  "signature": "(profiles) -> dict",
                  "description": null,
                  "parameters": [
                    {
                      "name": "profiles",
                      "annotation": "dict",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "dict",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef parse_loops(profiles: dict) -> dict:\n    parsed_inner_loops = []\n    parsed_outer_loops = []\n    for loop in profiles[\"loops\"]:\n        curves = []\n        for i, curve in enumerate(loop[\"profile_curves\"]):\n            curves.append(DeepCadJsonParser.parse_curve(curve, curve_name=i))\n        if loop[\"is_outer\"]:\n            parsed_outer_loops.append(Wire(curves))\n        elif not loop[\"is_outer\"]:\n            parsed_inner_loops.append(Wire(curves))\n    if len(parsed_outer_loops) > 1:\n        loops_with_area = [\n            {\"loop\": loop, \"area\": loop.bounding_box_area()}\n            for loop in parsed_outer_loops\n        ]\n        loops_with_area.sort(key=lambda x: x[\"area\"], reverse=True)\n\n        parsed_outer_loop = loops_with_area[0][\"loop\"]\n        parsed_inner_loops = [entry[\"loop\"] for entry in loops_with_area[1:]]\n    else:\n        parsed_outer_loop = parsed_outer_loops[0]\n\n    return {\"outer_wires\": parsed_outer_loop, \"inner_wires\": parsed_inner_loops}"
                },
                "_parse_point": {
                  "name": "_parse_point",
                  "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser._parse_point",
                  "signature": "(point_dict)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "point_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef _parse_point(point_dict):\n    return Vertex(point_dict[\"x\"], point_dict[\"y\"])"
                },
                "parse_face": {
                  "name": "parse_face",
                  "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser.parse_face",
                  "signature": "(profile_id, face_dict, curve_dict)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "profile_id",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "face_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "curve_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef parse_face(profile_id, face_dict, curve_dict):\n    outer_loop = []\n    inner_loop_curve = []\n    num_outer_loop = 0\n    edge_counter = 0\n    arc_counter = 0\n    for loop in face_dict[\"loops\"]:\n        if loop[\"is_outer\"]:\n            num_outer_loop += 1\n            for curve in loop[\"profile_curves\"]:\n                if curve[\"type\"] == \"Line3D\":\n                    outer_loop.append(\n                        DeepCadJsonParser._parse_line(\n                            curve, edge_name=f\"edge_{edge_counter}\"\n                        )\n                    )\n                    edge_counter += 1\n                elif curve[\"type\"] == \"Arc3D\":\n                    outer_loop.append(\n                        DeepCadJsonParser._parse_arc(\n                            curve, edge_name=f\"arc_{arc_counter}\"\n                        )\n                    )\n                    arc_counter += 1\n                elif curve[\"type\"] == \"Circle3D\":\n                    outer_loop.append(DeepCadJsonParser._parse_circle(curve))\n        elif not loop[\"is_outer\"]:\n            current_inner_loop = set()\n            for curve in loop[\"profile_curves\"]:\n                curve_obj = curve_dict[curve[\"curve\"]]\n                current_inner_loop.add(curve_obj)\n            inner_loop_curve.append(Wire(edges=list(current_inner_loop)))\n\n    if num_outer_loop > 1:\n        raise NotImplementedError(\"Multiple outer loops not supported\")\n    if num_outer_loop == 0:\n        raise ValueError(\"No outer loop found\")\n\n    return {\n        \"outer_wire\": Wire(outer_loop),\n        \"inner_wires\": inner_loop_curve,\n    }"
                },
                "parse_transform": {
                  "name": "parse_transform",
                  "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser.parse_transform",
                  "signature": "(plane_dict)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "plane_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef parse_transform(plane_dict):\n    origin = DeepCadJsonParser.parse_vector(plane_dict[\"origin\"])\n    normal = DeepCadJsonParser.parse_vector(plane_dict[\"z_axis\"])\n    y_axis = DeepCadJsonParser.parse_vector(plane_dict[\"y_axis\"])\n    x_axis = DeepCadJsonParser.parse_vector(plane_dict[\"x_axis\"])\n    return Plane(origin, x_dir=x_axis, y_dir=y_axis, z_dir=normal)"
                },
                "process_sequences": {
                  "name": "process_sequences",
                  "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser.process_sequences",
                  "signature": "(ordered_seq_dict, entity_dict) -> List[SketchExtrude]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "ordered_seq_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "entity_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.List[rapidcadpy.sketch_extrude.SketchExtrude]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef process_sequences(ordered_seq_dict, entity_dict) -> List[SketchExtrude]:\n    skex_seq = []\n    profile_dict: Dict[str, Wire] = {}\n\n    for seq_index, seq in ordered_seq_dict.items():\n        entity = entity_dict[seq[\"entity\"]]\n        if entity[\"type\"].lower() == \"sketch\":\n            profile_dict.update(\n                {\n                    profile_id: DeepCadJsonParser.parse_loops(loops)\n                    for i, (profile_id, loops) in enumerate(\n                        entity[\"profiles\"].items()\n                    )\n                }\n            )\n            plane = DeepCadJsonParser.parse_transform(entity[\"transform\"])\n        elif \"extrude\" in entity[\"type\"].lower():\n            extent_one = entity[\"extent_one\"][\"distance\"][\"value\"]\n            taper_angle_one = entity[\"extent_one\"][\"taper_angle\"][\"value\"]\n            extent_two = (\n                entity[\"extent_two\"][\"distance\"][\"value\"]\n                if \"extent_two\" in entity\n                else 0.0\n            )\n            taper_angle_two = (\n                entity[\"extent_two\"][\"taper_angle\"][\"value\"]\n                if \"extent_two\" in entity\n                else 0.0\n            )\n            extent_type = entity[\"extent_type\"]\n            operation = entity[\"operation\"]\n            extruded_sketches: List[Sketch] = []\n            for profile in entity[\"profiles\"]:\n                parsed_profile = profile_dict[profile[\"profile\"]]\n                sketch_entity_obj = Sketch(\n                    id=seq[\"entity\"],\n                    outer_wire=parsed_profile[\"outer_wires\"],\n                    inner_wires=parsed_profile[\"inner_wires\"],\n                    name=profile[\"profile\"],\n                )\n                extruded_sketches.append(sketch_entity_obj)\n\n            if extent_one < 0:\n                extent_one = -extent_one\n                direction = -1\n            else:\n                direction = 1\n\n            extent_obj = Extrude(\n                extent_one=extent_one,\n                direction=direction,\n                extent_two=extent_two,\n                extent_type=extent_type,\n                operation=operation,\n                taper_angle_one=taper_angle_one,\n                taper_angle_two=taper_angle_two,\n                name=entity[\"name\"],\n            )\n            skex_seq.append(\n                SketchExtrude(\n                    sketch=extruded_sketches,\n                    extrude=extent_obj,\n                    sketch_plane=copy.deepcopy(plane),\n                    name=entity[\"name\"],\n                )\n            )\n\n    return skex_seq"
                },
                "build_seq_dict": {
                  "name": "build_seq_dict",
                  "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser.build_seq_dict",
                  "signature": "(json_obj)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "json_obj",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef build_seq_dict(json_obj):\n    seq_dict = {seq[\"index\"]: seq for seq in json_obj[\"sequence\"]}\n    return OrderedDict(sorted(seq_dict.items(), key=lambda item: item[0]))"
                },
                "build_entity_dict": {
                  "name": "build_entity_dict",
                  "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser.build_entity_dict",
                  "signature": "(json_obj)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "json_obj",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef build_entity_dict(json_obj):\n    return {entity_id: entity for entity_id, entity in json_obj[\"entities\"].items()}"
                },
                "process": {
                  "name": "process",
                  "path": "rapidcadpy.f360gallery_processing.process_deepcad.DeepCadJsonParser.process",
                  "signature": "(file) -> Cad",
                  "description": null,
                  "parameters": [
                    {
                      "name": "file",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "rapidcadpy.cad.Cad",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef process(file: str) -> Cad:\n    json_data = DeepCadJsonParser.load_json(json_file_path=file)\n    ordered_seq_dict = DeepCadJsonParser.build_seq_dict(json_data)\n    entity_dict = DeepCadJsonParser.build_entity_dict(json_data)\n    skex_seq: List[SketchExtrude] = DeepCadJsonParser.process_sequences(\n        ordered_seq_dict, entity_dict\n    )\n    cad_seq = Cad(construction_sequence=skex_seq)\n    # cad_seq.normalize()\n    return cad_seq"
                }
              },
              "source": "class DeepCadJsonParser:\n    @staticmethod\n    def load_json(json_file_path):\n        with open(json_file_path) as fp:\n            return json.load(fp)\n\n    @staticmethod\n    def _find_orthogonal_vector(normal):\n        # Ensure the normal vector is a numpy array\n        normal = np.asarray(normal)\n\n        # Check for special cases where normal vector has specific components equal to zero\n        if normal[0] != 0 or normal[1] != 0:\n            # Choose (1, 0, 0) or (0, 1, 0) as a candidate vector if normal[0] and normal[1] are not both zero\n            candidate = np.array([1, 0, 0])\n            if normal[0] == 0:\n                candidate = np.array([0, 1, 0])\n        else:\n            candidate = np.array([0, 1, 0])\n\n        return np.cross(normal, candidate)\n\n    @staticmethod\n    def parse_vector(vector_dict):\n        return Vector(vector_dict[\"x\"], vector_dict[\"y\"], vector_dict[\"z\"])\n\n    @staticmethod\n    def parse_curve(curve_dict, curve_name):\n        if \"circle\" in curve_dict[\"type\"].lower():\n            center_point = DeepCadJsonParser._parse_point(curve_dict[\"center_point\"])\n            radius = curve_dict[\"radius\"]\n            return Circle(center_point, radius, name=curve_dict[\"curve\"])\n        elif \"line\" in curve_dict[\"type\"].lower():\n            start_point = DeepCadJsonParser._parse_point(curve_dict[\"start_point\"])\n            end_point = DeepCadJsonParser._parse_point(curve_dict[\"end_point\"])\n            return Line(\n                name=\"line_\" + curve_dict[\"curve\"],\n                start_point=start_point,\n                end_point=end_point,\n            )\n        elif \"arc\" in curve_dict[\"type\"].lower():\n            radius = curve_dict[\"radius\"]\n            start_point = DeepCadJsonParser._parse_point(curve_dict[\"start_point\"])\n            end_point = DeepCadJsonParser._parse_point(curve_dict[\"end_point\"])\n            center_point = DeepCadJsonParser._parse_point(curve_dict[\"center_point\"])\n            start_angle = curve_dict[\"start_angle\"]\n            end_angle = curve_dict[\"end_angle\"]\n            reference_vector = DeepCadJsonParser.parse_vector(\n                curve_dict[\"reference_vector\"]\n            )\n\n            ref_vec = reference_vector.normalize()\n            mid_angle = (start_angle + end_angle) / 2\n            # Rotation matrix for the midpoint angle\n            rot_matrix = np.array(\n                [\n                    [np.cos(mid_angle), -np.sin(mid_angle)],\n                    [np.sin(mid_angle), np.cos(mid_angle)],\n                ]\n            )\n\n            # Rotate the reference vector to get the direction for the midpoint\n            rotated_vec = rot_matrix @ ref_vec.get_2d()\n\n            # Calculate midpoint coordinates\n            mid_x = center_point[0] + rotated_vec[0] * radius\n            mid_y = center_point[1] + rotated_vec[1] * radius\n\n            return Arc(\n                start_point=start_point,\n                mid_point=Vertex(x=mid_x, y=mid_y),\n                end_point=end_point,\n                id=curve_dict[\"curve\"],\n            )\n\n    @staticmethod\n    def parse_loops(profiles: dict) -> dict:\n        parsed_inner_loops = []\n        parsed_outer_loops = []\n        for loop in profiles[\"loops\"]:\n            curves = []\n            for i, curve in enumerate(loop[\"profile_curves\"]):\n                curves.append(DeepCadJsonParser.parse_curve(curve, curve_name=i))\n            if loop[\"is_outer\"]:\n                parsed_outer_loops.append(Wire(curves))\n            elif not loop[\"is_outer\"]:\n                parsed_inner_loops.append(Wire(curves))\n        if len(parsed_outer_loops) > 1:\n            loops_with_area = [\n                {\"loop\": loop, \"area\": loop.bounding_box_area()}\n                for loop in parsed_outer_loops\n            ]\n            loops_with_area.sort(key=lambda x: x[\"area\"], reverse=True)\n\n            parsed_outer_loop = loops_with_area[0][\"loop\"]\n            parsed_inner_loops = [entry[\"loop\"] for entry in loops_with_area[1:]]\n        else:\n            parsed_outer_loop = parsed_outer_loops[0]\n\n        return {\"outer_wires\": parsed_outer_loop, \"inner_wires\": parsed_inner_loops}\n\n    @staticmethod\n    def _parse_point(point_dict):\n        return Vertex(point_dict[\"x\"], point_dict[\"y\"])\n\n    @staticmethod\n    def parse_face(profile_id, face_dict, curve_dict):\n        outer_loop = []\n        inner_loop_curve = []\n        num_outer_loop = 0\n        edge_counter = 0\n        arc_counter = 0\n        for loop in face_dict[\"loops\"]:\n            if loop[\"is_outer\"]:\n                num_outer_loop += 1\n                for curve in loop[\"profile_curves\"]:\n                    if curve[\"type\"] == \"Line3D\":\n                        outer_loop.append(\n                            DeepCadJsonParser._parse_line(\n                                curve, edge_name=f\"edge_{edge_counter}\"\n                            )\n                        )\n                        edge_counter += 1\n                    elif curve[\"type\"] == \"Arc3D\":\n                        outer_loop.append(\n                            DeepCadJsonParser._parse_arc(\n                                curve, edge_name=f\"arc_{arc_counter}\"\n                            )\n                        )\n                        arc_counter += 1\n                    elif curve[\"type\"] == \"Circle3D\":\n                        outer_loop.append(DeepCadJsonParser._parse_circle(curve))\n            elif not loop[\"is_outer\"]:\n                current_inner_loop = set()\n                for curve in loop[\"profile_curves\"]:\n                    curve_obj = curve_dict[curve[\"curve\"]]\n                    current_inner_loop.add(curve_obj)\n                inner_loop_curve.append(Wire(edges=list(current_inner_loop)))\n\n        if num_outer_loop > 1:\n            raise NotImplementedError(\"Multiple outer loops not supported\")\n        if num_outer_loop == 0:\n            raise ValueError(\"No outer loop found\")\n\n        return {\n            \"outer_wire\": Wire(outer_loop),\n            \"inner_wires\": inner_loop_curve,\n        }\n\n    @staticmethod\n    def parse_transform(plane_dict):\n        origin = DeepCadJsonParser.parse_vector(plane_dict[\"origin\"])\n        normal = DeepCadJsonParser.parse_vector(plane_dict[\"z_axis\"])\n        y_axis = DeepCadJsonParser.parse_vector(plane_dict[\"y_axis\"])\n        x_axis = DeepCadJsonParser.parse_vector(plane_dict[\"x_axis\"])\n        return Plane(origin, x_dir=x_axis, y_dir=y_axis, z_dir=normal)\n\n    @staticmethod\n    def process_sequences(ordered_seq_dict, entity_dict) -> List[SketchExtrude]:\n        skex_seq = []\n        profile_dict: Dict[str, Wire] = {}\n\n        for seq_index, seq in ordered_seq_dict.items():\n            entity = entity_dict[seq[\"entity\"]]\n            if entity[\"type\"].lower() == \"sketch\":\n                profile_dict.update(\n                    {\n                        profile_id: DeepCadJsonParser.parse_loops(loops)\n                        for i, (profile_id, loops) in enumerate(\n                            entity[\"profiles\"].items()\n                        )\n                    }\n                )\n                plane = DeepCadJsonParser.parse_transform(entity[\"transform\"])\n            elif \"extrude\" in entity[\"type\"].lower():\n                extent_one = entity[\"extent_one\"][\"distance\"][\"value\"]\n                taper_angle_one = entity[\"extent_one\"][\"taper_angle\"][\"value\"]\n                extent_two = (\n                    entity[\"extent_two\"][\"distance\"][\"value\"]\n                    if \"extent_two\" in entity\n                    else 0.0\n                )\n                taper_angle_two = (\n                    entity[\"extent_two\"][\"taper_angle\"][\"value\"]\n                    if \"extent_two\" in entity\n                    else 0.0\n                )\n                extent_type = entity[\"extent_type\"]\n                operation = entity[\"operation\"]\n                extruded_sketches: List[Sketch] = []\n                for profile in entity[\"profiles\"]:\n                    parsed_profile = profile_dict[profile[\"profile\"]]\n                    sketch_entity_obj = Sketch(\n                        id=seq[\"entity\"],\n                        outer_wire=parsed_profile[\"outer_wires\"],\n                        inner_wires=parsed_profile[\"inner_wires\"],\n                        name=profile[\"profile\"],\n                    )\n                    extruded_sketches.append(sketch_entity_obj)\n\n                if extent_one < 0:\n                    extent_one = -extent_one\n                    direction = -1\n                else:\n                    direction = 1\n\n                extent_obj = Extrude(\n                    extent_one=extent_one,\n                    direction=direction,\n                    extent_two=extent_two,\n                    extent_type=extent_type,\n                    operation=operation,\n                    taper_angle_one=taper_angle_one,\n                    taper_angle_two=taper_angle_two,\n                    name=entity[\"name\"],\n                )\n                skex_seq.append(\n                    SketchExtrude(\n                        sketch=extruded_sketches,\n                        extrude=extent_obj,\n                        sketch_plane=copy.deepcopy(plane),\n                        name=entity[\"name\"],\n                    )\n                )\n\n        return skex_seq\n\n    @staticmethod\n    def build_seq_dict(json_obj):\n        seq_dict = {seq[\"index\"]: seq for seq in json_obj[\"sequence\"]}\n        return OrderedDict(sorted(seq_dict.items(), key=lambda item: item[0]))\n\n    @staticmethod\n    def build_entity_dict(json_obj):\n        return {entity_id: entity for entity_id, entity in json_obj[\"entities\"].items()}\n\n    @staticmethod\n    def process(file: str) -> Cad:\n        json_data = DeepCadJsonParser.load_json(json_file_path=file)\n        ordered_seq_dict = DeepCadJsonParser.build_seq_dict(json_data)\n        entity_dict = DeepCadJsonParser.build_entity_dict(json_data)\n        skex_seq: List[SketchExtrude] = DeepCadJsonParser.process_sequences(\n            ordered_seq_dict, entity_dict\n        )\n        cad_seq = Cad(construction_sequence=skex_seq)\n        # cad_seq.normalize()\n        return cad_seq",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "process_f360": {
          "name": "process_f360",
          "path": "rapidcadpy.f360gallery_processing.process_f360",
          "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/f360gallery_processing/process_f360.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "Fusion360GalleryParser": {
              "name": "Fusion360GalleryParser",
              "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "start_point_of_primitive",
                  "annotation": "dict",
                  "description": null,
                  "value": "{}"
                },
                {
                  "name": "end_point_of_primitive",
                  "annotation": "dict",
                  "description": null,
                  "value": "{}"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.__init__",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self):\n    self.start_point_of_primitive: dict = {}\n    self.end_point_of_primitive: dict = {}"
                },
                "load_json": {
                  "name": "load_json",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.load_json",
                  "signature": "(json_file_path)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "json_file_path",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef load_json(json_file_path):\n    with open(json_file_path) as fp:\n        return json.load(fp)"
                },
                "_find_orthogonal_vector": {
                  "name": "_find_orthogonal_vector",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser._find_orthogonal_vector",
                  "signature": "(normal)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "normal",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef _find_orthogonal_vector(normal):\n    # Ensure the normal vector is a numpy array\n    normal = np.asarray(normal)\n\n    # Check for special cases where normal vector has specific components equal to zero\n    if normal[0] != 0 or normal[1] != 0:\n        # Choose (1, 0, 0) or (0, 1, 0) as a candidate vector if normal[0] and normal[1] are not both zero\n        candidate = np.array([1, 0, 0])\n        if normal[0] == 0:\n            candidate = np.array([0, 1, 0])\n    else:\n        candidate = np.array([0, 1, 0])\n\n    return np.cross(normal, candidate)"
                },
                "parse_vector": {
                  "name": "parse_vector",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.parse_vector",
                  "signature": "(vector_dict)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "vector_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef parse_vector(vector_dict):\n    return Vector(vector_dict[\"x\"], vector_dict[\"y\"], vector_dict[\"z\"])"
                },
                "parse_curve": {
                  "name": "parse_curve",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.parse_curve",
                  "signature": "(self, curve_dict, point_dict, curve_name, curve_id=None) -> Circle | Line | Arc",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "curve_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "point_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "curve_name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "curve_id",
                      "annotation": "Optional[str]",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "rapidcadpy.primitive.Circle | rapidcadpy.primitive.Line | rapidcadpy.primitive.Arc",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def parse_curve(\n    self, curve_dict, point_dict, curve_name: str, curve_id: Optional[str] = None\n) -> Circle | Line | Arc:\n    if \"circle\" in curve_dict[\"type\"].lower():\n        center_point = point_dict[curve_dict[\"center_point\"]]\n        radius = curve_dict[\"radius\"]\n        return Circle(center_point, radius, name=f\"circle_{curve_name}\")\n    elif \"line\" in curve_dict[\"type\"].lower():\n        start_point = point_dict[curve_dict[\"start_point\"]]\n        end_point = point_dict[curve_dict[\"end_point\"]]\n        line = Line(start_point, end_point, name=\"line_\" + curve_name, id=curve_id)\n        self.start_point_of_primitive[start_point] = line\n        self.end_point_of_primitive[end_point] = line\n        return line\n    elif \"arc\" in curve_dict[\"type\"].lower():\n        start_point = point_dict[curve_dict[\"start_point\"]]\n        end_point = point_dict[curve_dict[\"end_point\"]]\n        center_point = point_dict[curve_dict[\"center_point\"]]\n        radius = curve_dict[\"radius\"]\n        start_angle = curve_dict[\"start_angle\"]\n        end_angle = curve_dict[\"end_angle\"]\n        reference_vector = Fusion360GalleryParser.parse_vector(\n            curve_dict[\"reference_vector\"]\n        )\n        return Arc(\n            radius=radius,\n            start_point=start_point,\n            end_point=end_point,\n            center=center_point,\n            start_angle=start_angle,\n            end_angle=end_angle,\n            ref_vec=reference_vector,\n            name=f\"arc_{curve_name}\",\n            ccw=None,\n            id=curve_id,\n        )"
                },
                "parse_loop_curve": {
                  "name": "parse_loop_curve",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.parse_loop_curve",
                  "signature": "(self, curve_dict, curve_name, curve_id=None) -> Circle | Line | Arc",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "curve_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "curve_name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "curve_id",
                      "annotation": "Optional[str]",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "rapidcadpy.primitive.Circle | rapidcadpy.primitive.Line | rapidcadpy.primitive.Arc",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def parse_loop_curve(\n    self, curve_dict, curve_name: str, curve_id: Optional[str] = None\n) -> Circle | Line | Arc:\n    if \"circle\" in curve_dict[\"type\"].lower():\n        center_point = Fusion360GalleryParser._parse_point(\n            curve_dict[\"center_point\"]\n        )\n        radius = curve_dict[\"radius\"]\n        return Circle(center_point, radius, name=f\"circle_{curve_name}\")\n    elif \"line\" in curve_dict[\"type\"].lower():\n        start_point = Fusion360GalleryParser._parse_point(curve_dict[\"start_point\"])\n        end_point = Fusion360GalleryParser._parse_point(curve_dict[\"end_point\"])\n        line = Line(start_point, end_point, name=\"line_\" + curve_name, id=curve_id)\n        self.start_point_of_primitive[start_point] = line\n        self.end_point_of_primitive[end_point] = line\n        return line\n    elif \"arc\" in curve_dict[\"type\"].lower():\n        start_point = Fusion360GalleryParser._parse_point(curve_dict[\"start_point\"])\n        end_point = Fusion360GalleryParser._parse_point(curve_dict[\"end_point\"])\n        center_point = Fusion360GalleryParser._parse_point(\n            curve_dict[\"center_point\"]\n        )\n        radius = curve_dict[\"radius\"]\n        start_angle = curve_dict[\"start_angle\"]\n        end_angle = curve_dict[\"end_angle\"]\n        reference_vector = Fusion360GalleryParser.parse_vector(\n            curve_dict[\"reference_vector\"]\n        )\n        return Arc(\n            radius=radius,\n            start_point=start_point,\n            end_point=end_point,\n            center=center_point,\n            start_angle=start_angle,\n            end_angle=end_angle,\n            ref_vec=reference_vector,\n            name=f\"arc_{curve_name}\",\n            ccw=None,\n            id=curve_id,\n        )\n    else:\n        raise NotImplementedError(\"NURBS, ellipses, are not supported\")"
                },
                "parse_constraint": {
                  "name": "parse_constraint",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.parse_constraint",
                  "signature": "(self, constraint, curve_dict, point_dict)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "constraint",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "curve_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "point_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def parse_constraint(self, constraint, curve_dict, point_dict):\n    if \"coincident\" in constraint[\"type\"].lower():\n        try:\n            point_1 = point_dict[constraint[\"entity\"]]\n            point_2 = point_dict[constraint[\"point\"]]\n            if (\n                point_1 in self.start_point_of_primitive\n                and point_2 in self.end_point_of_primitive\n            ):\n                return StartToEndCoincidenceConstraint(\n                    self.start_point_of_primitive[point_1],\n                    self.end_point_of_primitive[point_2],\n                )\n            elif (\n                point_1 in self.end_point_of_primitive\n                and point_2 in self.start_point_of_primitive\n            ):\n                return EndToStartCoincidenceConstraint(\n                    self.end_point_of_primitive[point_1],\n                    self.start_point_of_primitive[point_2],\n                )\n        except KeyError:\n            return None\n    if (\n        \"horizontal\" in constraint[\"type\"].lower()\n        and \"point\" not in constraint[\"type\"].lower()\n    ):\n        return HorizontalConstraint(\n            curve_dict[constraint[\"line\"]],\n        )\n    if (\n        \"vertical\" in constraint[\"type\"].lower()\n        and \"point\" not in constraint[\"type\"].lower()\n    ):\n        return VerticalConstraint(\n            curve_dict[constraint[\"line\"]],\n        )\n    if \"perpendicular\" in constraint[\"type\"].lower():\n        return PerpendicularConstraint(\n            curve_dict[constraint[\"line_one\"]],\n            curve_dict[constraint[\"line_two\"]],\n        )\n    if \"parallel\" in constraint[\"type\"].lower():\n        return ParallelConstraint(\n            curve_dict[constraint[\"line_one\"]],\n            curve_dict[constraint[\"line_two\"]],\n        )\n    if \"tangent\" in constraint[\"type\"].lower():\n        return TangentConstraint(\n            curve_dict[constraint[\"curve_one\"]],\n            curve_dict[constraint[\"curve_one\"]],\n        )"
                },
                "_parse_point": {
                  "name": "_parse_point",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser._parse_point",
                  "signature": "(point_dict)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "point_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef _parse_point(point_dict):\n    return Vertex(point_dict[\"x\"], point_dict[\"y\"], id=point_dict)"
                },
                "parse_face": {
                  "name": "parse_face",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.parse_face",
                  "signature": "(self, loops, curve_dict)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "loops",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "curve_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def parse_face(self, loops, curve_dict):\n    outer_loop = []\n    inner_loop_curve = []\n    num_outer_loop = 0\n    for loop in loops:\n        if loop[\"is_outer\"]:\n            num_outer_loop += 1\n            for curve in loop[\"profile_curves\"]:\n                outer_loop.append(curve_dict[curve[\"curve\"]])\n        elif not loop[\"is_outer\"]:\n            current_inner_loop = set()\n            for curve in loop[\"profile_curves\"]:\n                curve_obj = curve_dict[curve[\"curve\"]]\n                current_inner_loop.add(curve_obj)\n            inner_loop_curve.append(Wire(edges=list(current_inner_loop)))\n\n    if num_outer_loop > 1:\n        raise NotImplementedError(\"Multiple outer loops not supported\")\n    if num_outer_loop == 0:\n        raise ValueError(\"No outer loop found\")\n\n    return {\n        \"outer_wire\": Wire(outer_loop),\n        \"inner_wires\": inner_loop_curve,\n    }"
                },
                "parse_plane": {
                  "name": "parse_plane",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.parse_plane",
                  "signature": "(plane_dict, transform_dict)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "plane_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "transform_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef parse_plane(plane_dict, transform_dict):\n    origin = Fusion360GalleryParser.parse_vector(transform_dict[\"origin\"])\n    x_dir = Fusion360GalleryParser.parse_vector(transform_dict[\"x_axis\"])\n    y_dir = Fusion360GalleryParser.parse_vector(transform_dict[\"y_axis\"])\n    z_dir = Fusion360GalleryParser.parse_vector(transform_dict[\"z_axis\"])\n    return Plane(origin, x_dir, y_dir, z_dir)"
                },
                "build_seq_dict": {
                  "name": "build_seq_dict",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.build_seq_dict",
                  "signature": "(json_obj)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "json_obj",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef build_seq_dict(json_obj):\n    seq_dict = {seq[\"index\"]: seq for seq in json_obj[\"sequence\"]}\n    return OrderedDict(sorted(seq_dict.items(), key=lambda item: item[0]))"
                },
                "build_entity_dict": {
                  "name": "build_entity_dict",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.build_entity_dict",
                  "signature": "(json_obj)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "json_obj",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef build_entity_dict(json_obj):\n    return {entity_id: entity for entity_id, entity in json_obj[\"entities\"].items()}"
                },
                "process_sequences": {
                  "name": "process_sequences",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.process_sequences",
                  "signature": "(self, ordered_seq_dict, entity_dict) -> List[SketchExtrude]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "ordered_seq_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "entity_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.List[rapidcadpy.sketch_extrude.SketchExtrude]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def process_sequences(self, ordered_seq_dict, entity_dict) -> List[SketchExtrude]:\n    skex_seq = []\n    point_dict: Dict[str, Vertex] = {}\n    curve_dict: Dict[str, Circle | Line | Arc] = {}\n    face_dict: Dict[str, any] = {}\n    profile_dict = {}\n\n    for seq_index, seq in ordered_seq_dict.items():\n        entity = entity_dict[seq[\"entity\"]]\n        if entity[\"type\"].lower() == \"sketch\":\n            point_dict.update(\n                {\n                    point_id: Vertex(\n                        point[\"x\"],\n                        point[\"y\"],\n                        id=point_id,\n                        name=f\"vertex_{i}\",\n                    )\n                    for i, (point_id, point) in enumerate(entity[\"points\"].items())\n                }\n            )\n            for profile_id, profile in entity[\"profiles\"].items():\n                profile_dict[profile_id] = profile[\"loops\"]\n                for loop in entity[\"profiles\"][profile_id][\"loops\"]:\n                    for curve in loop[\"profile_curves\"]:\n                        curve_id = curve[\"curve\"]\n                        curve_obj = self.parse_loop_curve(\n                            curve, curve_name=curve_id, curve_id=curve_id\n                        )\n                        curve_dict[curve_id] = curve_obj\n\n            plane = Fusion360GalleryParser.parse_plane(\n                entity[\"reference_plane\"], entity[\"transform\"]\n            )\n            if \"constraints\" in entity:\n                constraint_dict = {\n                    constraint_id: constraint\n                    for constraint_id, constraint in entity[\"constraints\"].items()\n                }\n            else:\n                constraint_dict = {}\n        elif \"extrude\" in entity[\"type\"].lower():\n            extent_one = entity[\"extent_one\"][\"distance\"][\"value\"]\n            taper_angle_one = entity[\"extent_one\"][\"taper_angle\"][\"value\"]\n            extent_two = (\n                entity[\"extent_two\"][\"distance\"][\"value\"]\n                if \"extent_two\" in entity\n                else 0.0\n            )\n            extent_type = entity[\"extent_type\"]\n            extent_operation = entity[\"operation\"]\n            taper_angle_two = (\n                entity[\"extent_two\"][\"taper_angle\"][\"value\"]\n                if \"extent_two\" in entity\n                else 0.0\n            )\n            for profile in entity[\"profiles\"]:\n                parsed_face = self.parse_face(\n                    profile_dict[profile[\"profile\"]], curve_dict\n                )\n                constraints = []\n                for constraint in constraint_dict:\n                    try:\n                        parsed = self.parse_constraint(\n                            constraint_dict[constraint], curve_dict, point_dict\n                        )\n                        if parsed is not None:\n                            constraints.append(parsed)\n                    except KeyError:\n                        continue\n                sketch_entity_obj = Sketch(\n                    id=uuid.UUID(seq[\"entity\"]),\n                    outer_wire=parsed_face[\"outer_wire\"],\n                    inner_wires=parsed_face[\"inner_wires\"],\n                    sketch_plane=plane,\n                    constraints=constraints,\n                )\n\n                extent_obj = Extrude(\n                    extent_one=extent_one,\n                    extent_two=extent_two,\n                    extent_type=extent_type,\n                    operation=extent_operation,\n                    symmetric=(\n                        entity[\"extent_type\"] == \"SymmetricFeatureExtentType\"\n                    ),\n                    taper_angle_one=taper_angle_one,\n                    taper_angle_two=taper_angle_two,\n                )\n                skex_seq.append(\n                    SketchExtrude(sketch=[sketch_entity_obj], extrude=extent_obj)\n                )\n\n    return skex_seq"
                },
                "assemble_cad_sequence": {
                  "name": "assemble_cad_sequence",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.assemble_cad_sequence",
                  "signature": "(skex_seq, exploded=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "skex_seq",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "exploded",
                      "annotation": null,
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef assemble_cad_sequence(skex_seq, exploded=False):\n    from build123d import Compound\n\n    occ_object = skex_seq.assemble_3d()\n    if not exploded:\n        return Compound(children=occ_object)\n    return [Compound(children=[obj]) for obj in occ_object]"
                },
                "parse": {
                  "name": "parse",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.parse",
                  "signature": "(json_file_path) -> Cad",
                  "description": null,
                  "parameters": [
                    {
                      "name": "json_file_path",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "rapidcadpy.cad.Cad",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef parse(json_file_path) -> Cad:\n    json_obj = Fusion360GalleryParser.load_json(json_file_path)\n    ordered_seq_dict = Fusion360GalleryParser.build_seq_dict(json_obj)\n    entity_dict = Fusion360GalleryParser.build_entity_dict(json_obj)\n    parser = Fusion360GalleryParser()\n    skex_seq: List[SketchExtrude] = parser.process_sequences(\n        ordered_seq_dict, entity_dict\n    )\n    return Cad(construction_history=skex_seq)"
                },
                "process_json_data": {
                  "name": "process_json_data",
                  "path": "rapidcadpy.f360gallery_processing.process_f360.Fusion360GalleryParser.process_json_data",
                  "signature": "(json_data) -> Cad",
                  "description": null,
                  "parameters": [
                    {
                      "name": "json_data",
                      "annotation": "dict",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "rapidcadpy.cad.Cad",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef process_json_data(json_data: dict) -> Cad:\n    ordered_seq_dict = Fusion360GalleryParser.build_seq_dict(json_data)\n    entity_dict = Fusion360GalleryParser.build_entity_dict(json_data)\n    parser = Fusion360GalleryParser()\n    skex_seq: List[SketchExtrude] = parser.process_sequences(\n        ordered_seq_dict, entity_dict\n    )\n    return Cad(construction_sequence=skex_seq)"
                }
              },
              "source": "class Fusion360GalleryParser:\n    def __init__(self):\n        self.start_point_of_primitive: dict = {}\n        self.end_point_of_primitive: dict = {}\n\n    @staticmethod\n    def load_json(json_file_path):\n        with open(json_file_path) as fp:\n            return json.load(fp)\n\n    @staticmethod\n    def _find_orthogonal_vector(normal):\n        # Ensure the normal vector is a numpy array\n        normal = np.asarray(normal)\n\n        # Check for special cases where normal vector has specific components equal to zero\n        if normal[0] != 0 or normal[1] != 0:\n            # Choose (1, 0, 0) or (0, 1, 0) as a candidate vector if normal[0] and normal[1] are not both zero\n            candidate = np.array([1, 0, 0])\n            if normal[0] == 0:\n                candidate = np.array([0, 1, 0])\n        else:\n            candidate = np.array([0, 1, 0])\n\n        return np.cross(normal, candidate)\n\n    @staticmethod\n    def parse_vector(vector_dict):\n        return Vector(vector_dict[\"x\"], vector_dict[\"y\"], vector_dict[\"z\"])\n\n    def parse_curve(\n        self, curve_dict, point_dict, curve_name: str, curve_id: Optional[str] = None\n    ) -> Circle | Line | Arc:\n        if \"circle\" in curve_dict[\"type\"].lower():\n            center_point = point_dict[curve_dict[\"center_point\"]]\n            radius = curve_dict[\"radius\"]\n            return Circle(center_point, radius, name=f\"circle_{curve_name}\")\n        elif \"line\" in curve_dict[\"type\"].lower():\n            start_point = point_dict[curve_dict[\"start_point\"]]\n            end_point = point_dict[curve_dict[\"end_point\"]]\n            line = Line(start_point, end_point, name=\"line_\" + curve_name, id=curve_id)\n            self.start_point_of_primitive[start_point] = line\n            self.end_point_of_primitive[end_point] = line\n            return line\n        elif \"arc\" in curve_dict[\"type\"].lower():\n            start_point = point_dict[curve_dict[\"start_point\"]]\n            end_point = point_dict[curve_dict[\"end_point\"]]\n            center_point = point_dict[curve_dict[\"center_point\"]]\n            radius = curve_dict[\"radius\"]\n            start_angle = curve_dict[\"start_angle\"]\n            end_angle = curve_dict[\"end_angle\"]\n            reference_vector = Fusion360GalleryParser.parse_vector(\n                curve_dict[\"reference_vector\"]\n            )\n            return Arc(\n                radius=radius,\n                start_point=start_point,\n                end_point=end_point,\n                center=center_point,\n                start_angle=start_angle,\n                end_angle=end_angle,\n                ref_vec=reference_vector,\n                name=f\"arc_{curve_name}\",\n                ccw=None,\n                id=curve_id,\n            )\n\n    def parse_loop_curve(\n        self, curve_dict, curve_name: str, curve_id: Optional[str] = None\n    ) -> Circle | Line | Arc:\n        if \"circle\" in curve_dict[\"type\"].lower():\n            center_point = Fusion360GalleryParser._parse_point(\n                curve_dict[\"center_point\"]\n            )\n            radius = curve_dict[\"radius\"]\n            return Circle(center_point, radius, name=f\"circle_{curve_name}\")\n        elif \"line\" in curve_dict[\"type\"].lower():\n            start_point = Fusion360GalleryParser._parse_point(curve_dict[\"start_point\"])\n            end_point = Fusion360GalleryParser._parse_point(curve_dict[\"end_point\"])\n            line = Line(start_point, end_point, name=\"line_\" + curve_name, id=curve_id)\n            self.start_point_of_primitive[start_point] = line\n            self.end_point_of_primitive[end_point] = line\n            return line\n        elif \"arc\" in curve_dict[\"type\"].lower():\n            start_point = Fusion360GalleryParser._parse_point(curve_dict[\"start_point\"])\n            end_point = Fusion360GalleryParser._parse_point(curve_dict[\"end_point\"])\n            center_point = Fusion360GalleryParser._parse_point(\n                curve_dict[\"center_point\"]\n            )\n            radius = curve_dict[\"radius\"]\n            start_angle = curve_dict[\"start_angle\"]\n            end_angle = curve_dict[\"end_angle\"]\n            reference_vector = Fusion360GalleryParser.parse_vector(\n                curve_dict[\"reference_vector\"]\n            )\n            return Arc(\n                radius=radius,\n                start_point=start_point,\n                end_point=end_point,\n                center=center_point,\n                start_angle=start_angle,\n                end_angle=end_angle,\n                ref_vec=reference_vector,\n                name=f\"arc_{curve_name}\",\n                ccw=None,\n                id=curve_id,\n            )\n        else:\n            raise NotImplementedError(\"NURBS, ellipses, are not supported\")\n\n    def parse_constraint(self, constraint, curve_dict, point_dict):\n        if \"coincident\" in constraint[\"type\"].lower():\n            try:\n                point_1 = point_dict[constraint[\"entity\"]]\n                point_2 = point_dict[constraint[\"point\"]]\n                if (\n                    point_1 in self.start_point_of_primitive\n                    and point_2 in self.end_point_of_primitive\n                ):\n                    return StartToEndCoincidenceConstraint(\n                        self.start_point_of_primitive[point_1],\n                        self.end_point_of_primitive[point_2],\n                    )\n                elif (\n                    point_1 in self.end_point_of_primitive\n                    and point_2 in self.start_point_of_primitive\n                ):\n                    return EndToStartCoincidenceConstraint(\n                        self.end_point_of_primitive[point_1],\n                        self.start_point_of_primitive[point_2],\n                    )\n            except KeyError:\n                return None\n        if (\n            \"horizontal\" in constraint[\"type\"].lower()\n            and \"point\" not in constraint[\"type\"].lower()\n        ):\n            return HorizontalConstraint(\n                curve_dict[constraint[\"line\"]],\n            )\n        if (\n            \"vertical\" in constraint[\"type\"].lower()\n            and \"point\" not in constraint[\"type\"].lower()\n        ):\n            return VerticalConstraint(\n                curve_dict[constraint[\"line\"]],\n            )\n        if \"perpendicular\" in constraint[\"type\"].lower():\n            return PerpendicularConstraint(\n                curve_dict[constraint[\"line_one\"]],\n                curve_dict[constraint[\"line_two\"]],\n            )\n        if \"parallel\" in constraint[\"type\"].lower():\n            return ParallelConstraint(\n                curve_dict[constraint[\"line_one\"]],\n                curve_dict[constraint[\"line_two\"]],\n            )\n        if \"tangent\" in constraint[\"type\"].lower():\n            return TangentConstraint(\n                curve_dict[constraint[\"curve_one\"]],\n                curve_dict[constraint[\"curve_one\"]],\n            )\n\n    @staticmethod\n    def _parse_point(point_dict):\n        return Vertex(point_dict[\"x\"], point_dict[\"y\"], id=point_dict)\n\n    def parse_face(self, loops, curve_dict):\n        outer_loop = []\n        inner_loop_curve = []\n        num_outer_loop = 0\n        for loop in loops:\n            if loop[\"is_outer\"]:\n                num_outer_loop += 1\n                for curve in loop[\"profile_curves\"]:\n                    outer_loop.append(curve_dict[curve[\"curve\"]])\n            elif not loop[\"is_outer\"]:\n                current_inner_loop = set()\n                for curve in loop[\"profile_curves\"]:\n                    curve_obj = curve_dict[curve[\"curve\"]]\n                    current_inner_loop.add(curve_obj)\n                inner_loop_curve.append(Wire(edges=list(current_inner_loop)))\n\n        if num_outer_loop > 1:\n            raise NotImplementedError(\"Multiple outer loops not supported\")\n        if num_outer_loop == 0:\n            raise ValueError(\"No outer loop found\")\n\n        return {\n            \"outer_wire\": Wire(outer_loop),\n            \"inner_wires\": inner_loop_curve,\n        }\n\n    @staticmethod\n    def parse_plane(plane_dict, transform_dict):\n        origin = Fusion360GalleryParser.parse_vector(transform_dict[\"origin\"])\n        x_dir = Fusion360GalleryParser.parse_vector(transform_dict[\"x_axis\"])\n        y_dir = Fusion360GalleryParser.parse_vector(transform_dict[\"y_axis\"])\n        z_dir = Fusion360GalleryParser.parse_vector(transform_dict[\"z_axis\"])\n        return Plane(origin, x_dir, y_dir, z_dir)\n\n    @staticmethod\n    def build_seq_dict(json_obj):\n        seq_dict = {seq[\"index\"]: seq for seq in json_obj[\"sequence\"]}\n        return OrderedDict(sorted(seq_dict.items(), key=lambda item: item[0]))\n\n    @staticmethod\n    def build_entity_dict(json_obj):\n        return {entity_id: entity for entity_id, entity in json_obj[\"entities\"].items()}\n\n    def process_sequences(self, ordered_seq_dict, entity_dict) -> List[SketchExtrude]:\n        skex_seq = []\n        point_dict: Dict[str, Vertex] = {}\n        curve_dict: Dict[str, Circle | Line | Arc] = {}\n        face_dict: Dict[str, any] = {}\n        profile_dict = {}\n\n        for seq_index, seq in ordered_seq_dict.items():\n            entity = entity_dict[seq[\"entity\"]]\n            if entity[\"type\"].lower() == \"sketch\":\n                point_dict.update(\n                    {\n                        point_id: Vertex(\n                            point[\"x\"],\n                            point[\"y\"],\n                            id=point_id,\n                            name=f\"vertex_{i}\",\n                        )\n                        for i, (point_id, point) in enumerate(entity[\"points\"].items())\n                    }\n                )\n                for profile_id, profile in entity[\"profiles\"].items():\n                    profile_dict[profile_id] = profile[\"loops\"]\n                    for loop in entity[\"profiles\"][profile_id][\"loops\"]:\n                        for curve in loop[\"profile_curves\"]:\n                            curve_id = curve[\"curve\"]\n                            curve_obj = self.parse_loop_curve(\n                                curve, curve_name=curve_id, curve_id=curve_id\n                            )\n                            curve_dict[curve_id] = curve_obj\n\n                plane = Fusion360GalleryParser.parse_plane(\n                    entity[\"reference_plane\"], entity[\"transform\"]\n                )\n                if \"constraints\" in entity:\n                    constraint_dict = {\n                        constraint_id: constraint\n                        for constraint_id, constraint in entity[\"constraints\"].items()\n                    }\n                else:\n                    constraint_dict = {}\n            elif \"extrude\" in entity[\"type\"].lower():\n                extent_one = entity[\"extent_one\"][\"distance\"][\"value\"]\n                taper_angle_one = entity[\"extent_one\"][\"taper_angle\"][\"value\"]\n                extent_two = (\n                    entity[\"extent_two\"][\"distance\"][\"value\"]\n                    if \"extent_two\" in entity\n                    else 0.0\n                )\n                extent_type = entity[\"extent_type\"]\n                extent_operation = entity[\"operation\"]\n                taper_angle_two = (\n                    entity[\"extent_two\"][\"taper_angle\"][\"value\"]\n                    if \"extent_two\" in entity\n                    else 0.0\n                )\n                for profile in entity[\"profiles\"]:\n                    parsed_face = self.parse_face(\n                        profile_dict[profile[\"profile\"]], curve_dict\n                    )\n                    constraints = []\n                    for constraint in constraint_dict:\n                        try:\n                            parsed = self.parse_constraint(\n                                constraint_dict[constraint], curve_dict, point_dict\n                            )\n                            if parsed is not None:\n                                constraints.append(parsed)\n                        except KeyError:\n                            continue\n                    sketch_entity_obj = Sketch(\n                        id=uuid.UUID(seq[\"entity\"]),\n                        outer_wire=parsed_face[\"outer_wire\"],\n                        inner_wires=parsed_face[\"inner_wires\"],\n                        sketch_plane=plane,\n                        constraints=constraints,\n                    )\n\n                    extent_obj = Extrude(\n                        extent_one=extent_one,\n                        extent_two=extent_two,\n                        extent_type=extent_type,\n                        operation=extent_operation,\n                        symmetric=(\n                            entity[\"extent_type\"] == \"SymmetricFeatureExtentType\"\n                        ),\n                        taper_angle_one=taper_angle_one,\n                        taper_angle_two=taper_angle_two,\n                    )\n                    skex_seq.append(\n                        SketchExtrude(sketch=[sketch_entity_obj], extrude=extent_obj)\n                    )\n\n        return skex_seq\n\n    @staticmethod\n    def assemble_cad_sequence(skex_seq, exploded=False):\n        from build123d import Compound\n\n        occ_object = skex_seq.assemble_3d()\n        if not exploded:\n            return Compound(children=occ_object)\n        return [Compound(children=[obj]) for obj in occ_object]\n\n    @staticmethod\n    def parse(json_file_path) -> Cad:\n        json_obj = Fusion360GalleryParser.load_json(json_file_path)\n        ordered_seq_dict = Fusion360GalleryParser.build_seq_dict(json_obj)\n        entity_dict = Fusion360GalleryParser.build_entity_dict(json_obj)\n        parser = Fusion360GalleryParser()\n        skex_seq: List[SketchExtrude] = parser.process_sequences(\n            ordered_seq_dict, entity_dict\n        )\n        return Cad(construction_history=skex_seq)\n\n    @staticmethod\n    def process_json_data(json_data: dict) -> Cad:\n        ordered_seq_dict = Fusion360GalleryParser.build_seq_dict(json_data)\n        entity_dict = Fusion360GalleryParser.build_entity_dict(json_data)\n        parser = Fusion360GalleryParser()\n        skex_seq: List[SketchExtrude] = parser.process_sequences(\n            ordered_seq_dict, entity_dict\n        )\n        return Cad(construction_sequence=skex_seq)",
              "inherited_members": {}
            }
          },
          "functions": {}
        }
      },
      "classes": {},
      "functions": {}
    },
    "onshape_processing": {
      "name": "onshape_processing",
      "path": "rapidcadpy.onshape_processing",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/onshape_processing/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {
        "extrude_parser": {
          "name": "extrude_parser",
          "path": "rapidcadpy.onshape_processing.extrude_parser",
          "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/onshape_processing/extrude_parser.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "EXTENT_TYPE_MAP",
              "annotation": null,
              "description": null,
              "value": "{'BLIND': 'OneSideFeatureExtentType', 'SYMMETRIC': 'SymmetricFeatureExtentType'}"
            },
            {
              "name": "OPERATION_MAP",
              "annotation": null,
              "description": null,
              "value": "{'NEW': 'NewBodyFeatureOperation', 'ADD': 'JoinFeatureOperation', 'REMOVE': 'CutFeatureOperation', 'INTERSECT': 'IntersectFeatureOperation'}"
            }
          ],
          "modules": {},
          "classes": {
            "ExtrudeParser": {
              "name": "ExtrudeParser",
              "path": "rapidcadpy.onshape_processing.extrude_parser.ExtrudeParser",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "client",
                  "annotation": "CustomOnshapeClient",
                  "description": null,
                  "value": null
                },
                {
                  "name": "did",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "wid",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "eid",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "client",
                  "annotation": null,
                  "description": null,
                  "value": "client"
                },
                {
                  "name": "did",
                  "annotation": null,
                  "description": null,
                  "value": "did"
                },
                {
                  "name": "wid",
                  "annotation": null,
                  "description": null,
                  "value": "wid"
                },
                {
                  "name": "eid",
                  "annotation": null,
                  "description": null,
                  "value": "eid"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "rapidcadpy.onshape_processing.extrude_parser.ExtrudeParser.__init__",
                  "signature": "(self, client, did, wid, eid)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "client",
                      "annotation": "CustomOnshapeClient",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "did",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "wid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "eid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, client: CustomOnshapeClient, did, wid, eid):\n    self.client = client\n    self.did = did\n    self.wid = wid\n    self.eid = eid"
                },
                "parse_feature_param": {
                  "name": "parse_feature_param",
                  "path": "rapidcadpy.onshape_processing.extrude_parser.ExtrudeParser.parse_feature_param",
                  "signature": "(feat_param_data)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "feat_param_data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef parse_feature_param(feat_param_data):\n    param_dict = {}\n    for i, param_item in enumerate(feat_param_data):\n        param_msg = param_item[\"message\"]\n        param_id = param_msg[\"parameterId\"]\n        if \"queries\" in param_msg:\n            param_value = []\n            for i in range(len(param_msg[\"queries\"])):\n                param_value.extend(\n                    param_msg[\"queries\"][i][\"message\"][\"geometryIds\"]\n                )  # FIXME: could be error-prone\n        elif \"expression\" in param_msg:\n            param_value = param_msg[\"expression\"]\n        elif \"value\" in param_msg:\n            param_value = param_msg[\"value\"]\n        else:\n            raise NotImplementedError(\"param_msg:\\n{}\".format(param_msg))\n\n        param_dict.update({param_id: param_value})\n    return param_dict"
                },
                "parse": {
                  "name": "parse",
                  "path": "rapidcadpy.onshape_processing.extrude_parser.ExtrudeParser.parse",
                  "signature": "(self, feature_data)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "feature_data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def parse(self, feature_data):\n    param_dict = self.parse_feature_param(feature_data[\"message\"][\"parameters\"])\n    if \"hasOffset\" in param_dict and param_dict[\"hasOffset\"] is True:\n        raise NotImplementedError(\n            \"extrude with offset not supported: {}\".format(param_dict[\"hasOffset\"])\n        )\n\n    entities = param_dict[\"entities\"]  # geometryIds for target face\n\n    extent_one = self._expr2meter(param_dict[\"depth\"])\n    if param_dict[\"endBound\"] == \"SYMMETRIC\":\n        extent_one = extent_one / 2\n    if (\n        \"oppositeDirection\" in param_dict\n        and param_dict[\"oppositeDirection\"] is True\n    ):\n        extent_one = -extent_one\n    extent_two = 0.0\n    if param_dict[\"endBound\"] not in [\"BLIND\", \"SYMMETRIC\"]:\n        raise NotImplementedError(\n            \"endBound type not supported: {}\".format(param_dict[\"endBound\"])\n        )\n    elif (\n        \"hasSecondDirection\" in param_dict\n        and param_dict[\"hasSecondDirection\"] is True\n    ):\n        if param_dict[\"secondDirectionBound\"] != \"BLIND\":\n            raise NotImplementedError(\n                \"secondDirectionBound type not supported: {}\".format(\n                    param_dict[\"endBound\"]\n                )\n            )\n        extent_type = \"TwoSidesFeatureExtentType\"\n        extent_two = self._expr2meter(param_dict[\"secondDirectionDepth\"])\n        if (\n            \"secondDirectionOppositeDirection\" in param_dict\n            and str(param_dict[\"secondDirectionOppositeDirection\"]) == \"true\"\n        ):\n            extent_two = -extent_two\n    else:\n        extent_type = EXTENT_TYPE_MAP[param_dict[\"endBound\"]]\n\n    operation = OPERATION_MAP[param_dict[\"operationType\"]]\n\n    save_dict = {\n        \"name\": feature_data[\"message\"][\"name\"],\n        \"type\": \"ExtrudeFeature\",\n        \"entities\": entities,\n        \"operation\": operation,\n        \"start_extent\": {\"type\": \"ProfilePlaneStartDefinition\"},\n        \"extent_type\": extent_type,\n        \"extent_one\": {\n            \"distance\": {\n                \"type\": \"ModelParameter\",\n                \"value\": extent_one,\n                \"name\": \"none\",\n                \"role\": \"AlongDistance\",\n            },\n            \"taper_angle\": {\n                \"type\": \"ModelParameter\",\n                \"value\": 0.0,\n                \"name\": \"none\",\n                \"role\": \"TaperAngle\",\n            },\n            \"type\": \"DistanceExtentDefinition\",\n        },\n        \"extent_two\": {\n            \"distance\": {\n                \"type\": \"ModelParameter\",\n                \"value\": extent_two,\n                \"name\": \"none\",\n                \"role\": \"AgainstDistance\",\n            },\n            \"taper_angle\": {\n                \"type\": \"ModelParameter\",\n                \"value\": 0.0,\n                \"name\": \"none\",\n                \"role\": \"Side2TaperAngle\",\n            },\n            \"type\": \"DistanceExtentDefinition\",\n        },\n    }\n    return save_dict"
                },
                "_locateSketchProfile": {
                  "name": "_locateSketchProfile",
                  "path": "rapidcadpy.onshape_processing.extrude_parser.ExtrudeParser._locateSketchProfile",
                  "signature": "(self, geo_ids)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "geo_ids",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _locateSketchProfile(self, geo_ids):\n    return [{\"profile\": k, \"sketch\": self.profile2sketch[k]} for k in geo_ids]"
                },
                "_expr2meter": {
                  "name": "_expr2meter",
                  "path": "rapidcadpy.onshape_processing.extrude_parser.ExtrudeParser._expr2meter",
                  "signature": "(self, expr)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "expr",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _expr2meter(self, expr):\n    return self.client.exprextent2meter(self.did, self.wid, self.eid, expr)"
                }
              },
              "source": "class ExtrudeParser:\n    def __init__(self, client: CustomOnshapeClient, did, wid, eid):\n        self.client = client\n        self.did = did\n        self.wid = wid\n        self.eid = eid\n\n    @staticmethod\n    def parse_feature_param(feat_param_data):\n        param_dict = {}\n        for i, param_item in enumerate(feat_param_data):\n            param_msg = param_item[\"message\"]\n            param_id = param_msg[\"parameterId\"]\n            if \"queries\" in param_msg:\n                param_value = []\n                for i in range(len(param_msg[\"queries\"])):\n                    param_value.extend(\n                        param_msg[\"queries\"][i][\"message\"][\"geometryIds\"]\n                    )  # FIXME: could be error-prone\n            elif \"expression\" in param_msg:\n                param_value = param_msg[\"expression\"]\n            elif \"value\" in param_msg:\n                param_value = param_msg[\"value\"]\n            else:\n                raise NotImplementedError(\"param_msg:\\n{}\".format(param_msg))\n\n            param_dict.update({param_id: param_value})\n        return param_dict\n\n    def parse(self, feature_data):\n        param_dict = self.parse_feature_param(feature_data[\"message\"][\"parameters\"])\n        if \"hasOffset\" in param_dict and param_dict[\"hasOffset\"] is True:\n            raise NotImplementedError(\n                \"extrude with offset not supported: {}\".format(param_dict[\"hasOffset\"])\n            )\n\n        entities = param_dict[\"entities\"]  # geometryIds for target face\n\n        extent_one = self._expr2meter(param_dict[\"depth\"])\n        if param_dict[\"endBound\"] == \"SYMMETRIC\":\n            extent_one = extent_one / 2\n        if (\n            \"oppositeDirection\" in param_dict\n            and param_dict[\"oppositeDirection\"] is True\n        ):\n            extent_one = -extent_one\n        extent_two = 0.0\n        if param_dict[\"endBound\"] not in [\"BLIND\", \"SYMMETRIC\"]:\n            raise NotImplementedError(\n                \"endBound type not supported: {}\".format(param_dict[\"endBound\"])\n            )\n        elif (\n            \"hasSecondDirection\" in param_dict\n            and param_dict[\"hasSecondDirection\"] is True\n        ):\n            if param_dict[\"secondDirectionBound\"] != \"BLIND\":\n                raise NotImplementedError(\n                    \"secondDirectionBound type not supported: {}\".format(\n                        param_dict[\"endBound\"]\n                    )\n                )\n            extent_type = \"TwoSidesFeatureExtentType\"\n            extent_two = self._expr2meter(param_dict[\"secondDirectionDepth\"])\n            if (\n                \"secondDirectionOppositeDirection\" in param_dict\n                and str(param_dict[\"secondDirectionOppositeDirection\"]) == \"true\"\n            ):\n                extent_two = -extent_two\n        else:\n            extent_type = EXTENT_TYPE_MAP[param_dict[\"endBound\"]]\n\n        operation = OPERATION_MAP[param_dict[\"operationType\"]]\n\n        save_dict = {\n            \"name\": feature_data[\"message\"][\"name\"],\n            \"type\": \"ExtrudeFeature\",\n            \"entities\": entities,\n            \"operation\": operation,\n            \"start_extent\": {\"type\": \"ProfilePlaneStartDefinition\"},\n            \"extent_type\": extent_type,\n            \"extent_one\": {\n                \"distance\": {\n                    \"type\": \"ModelParameter\",\n                    \"value\": extent_one,\n                    \"name\": \"none\",\n                    \"role\": \"AlongDistance\",\n                },\n                \"taper_angle\": {\n                    \"type\": \"ModelParameter\",\n                    \"value\": 0.0,\n                    \"name\": \"none\",\n                    \"role\": \"TaperAngle\",\n                },\n                \"type\": \"DistanceExtentDefinition\",\n            },\n            \"extent_two\": {\n                \"distance\": {\n                    \"type\": \"ModelParameter\",\n                    \"value\": extent_two,\n                    \"name\": \"none\",\n                    \"role\": \"AgainstDistance\",\n                },\n                \"taper_angle\": {\n                    \"type\": \"ModelParameter\",\n                    \"value\": 0.0,\n                    \"name\": \"none\",\n                    \"role\": \"Side2TaperAngle\",\n                },\n                \"type\": \"DistanceExtentDefinition\",\n            },\n        }\n        return save_dict\n\n    def _locateSketchProfile(self, geo_ids):\n        return [{\"profile\": k, \"sketch\": self.profile2sketch[k]} for k in geo_ids]\n\n    def _expr2meter(self, expr):\n        return self.client.exprextent2meter(self.did, self.wid, self.eid, expr)",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "custom_onshape_client": {
          "name": "custom_onshape_client",
          "path": "rapidcadpy.onshape_processing.custom_onshape_client",
          "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/onshape_processing/custom_onshape_client.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "CustomOnshapeClient": {
              "name": "CustomOnshapeClient",
              "path": "rapidcadpy.onshape_processing.custom_onshape_client.CustomOnshapeClient",
              "description": null,
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "eval_compressed_query": {
                  "name": "eval_compressed_query",
                  "path": "rapidcadpy.onshape_processing.custom_onshape_client.CustomOnshapeClient.eval_compressed_query",
                  "signature": "(self, did, wid, eid, compressed_query=None)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "did",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "wid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "eid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "compressed_query",
                      "annotation": null,
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def eval_compressed_query(self, did, wid, eid, compressed_query=None):\n    fs_function = \"\"\"\n        function(context is Context, queries){\n            var id = makeId(\"FVJi9rnRrDg7IKN\");\n            return evOwnerSketchPlane(\n        }\n    \"\"\"\n\n    body = {\n        \"script\": fs_function,\n    }\n\n    result = self._api.request(\n        \"post\",\n        \"/api/partstudios/d/\" + did + \"/w/\" + wid + \"/e/\" + eid + \"/featurescript\",\n        body=body,\n    )\n\n    return result"
                },
                "get_entity_by_id": {
                  "name": "get_entity_by_id",
                  "path": "rapidcadpy.onshape_processing.custom_onshape_client.CustomOnshapeClient.get_entity_by_id",
                  "signature": "(self, did, wid, eid, geo_id, entity_type)",
                  "description": "get the parameters of geometry entity for specified entity id and type\n\nArgs:\n    - did (str): Document ID\n    - wid (str): Workspace ID\n    - eid (str): Element ID\n    - geo_id (str): geometry entity ID\n    - entity_type (str): 'VERTEX', 'EDGE' or 'FACE'\n\nReturns:\n    - requests.Response: OnShape response data",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "did",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "wid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "eid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "geo_id",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "entity_type",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_entity_by_id(self, did, wid, eid, geo_id, entity_type):\n    \"\"\"get the parameters of geometry entity for specified entity id and type\n\n    Args:\n        - did (str): Document ID\n        - wid (str): Workspace ID\n        - eid (str): Element ID\n        - geo_id (str): geometry entity ID\n        - entity_type (str): 'VERTEX', 'EDGE' or 'FACE'\n\n    Returns:\n        - requests.Response: OnShape response data\n    \"\"\"\n    func_dict = {\n        \"VERTEX\": (\"evVertexPoint\", \"vertex\"),\n        \"EDGE\": (\"evCurveDefinition\", \"edge\"),\n        \"FACE\": (\"evSurfaceDefinition\", \"face\"),\n    }\n    body = {\n        \"script\": \"function(context is Context, queries) { \"\n        + \"   var res_list = [];\"\n        \"   var q_arr = evaluateQuery(context, queries.id);\"\n        \"   for (var i = 0; i < size(q_arr); i+= 1){\"\n        '       var res = %s(context, {\"%s\": q_arr[i]});'\n        % (func_dict[entity_type][0], func_dict[entity_type][1])\n        + \"       res_list = append(res_list, res);\"\n        \"   }\"\n        \"   return res_list;\"\n        \"}\",\n        \"queries\": [{\"key\": \"id\", \"value\": geo_id}],\n    }\n    res = self._api.request(\n        \"post\",\n        \"/api/partstudios/d/\" + did + \"/w/\" + wid + \"/e/\" + eid + \"/featurescript\",\n        body=body,\n    )\n\n    return res"
                },
                "parse_coord_msg": {
                  "name": "parse_coord_msg",
                  "path": "rapidcadpy.onshape_processing.custom_onshape_client.CustomOnshapeClient.parse_coord_msg",
                  "signature": "(response)",
                  "description": "parse coordSystem parameters from OnShape response data",
                  "parameters": [
                    {
                      "name": "response",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef parse_coord_msg(response):\n    \"\"\"parse coordSystem parameters from OnShape response data\"\"\"\n    coord_param = {}\n    for item in response:\n        k_msg = item[\"message\"][\"key\"]\n        k = k_msg[\"message\"][\"value\"]\n        v_msg = item[\"message\"][\"value\"]\n        v = [round(x[\"message\"][\"value\"], 8) for x in v_msg[\"message\"][\"value\"]]\n        coord_param.update({k: v})\n    return coord_param"
                },
                "parse_face_msg": {
                  "name": "parse_face_msg",
                  "path": "rapidcadpy.onshape_processing.custom_onshape_client.CustomOnshapeClient.parse_face_msg",
                  "signature": "(response)",
                  "description": "parse face parameters from OnShape response data",
                  "parameters": [
                    {
                      "name": "response",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef parse_face_msg(response):\n    \"\"\"parse face parameters from OnShape response data\"\"\"\n    # data = response.json()['result']['message']['value']\n    data = [response] if not isinstance(response, list) else response\n    faces = []\n    for item in data:\n        face_msg = item[\"message\"][\"value\"]\n        face_type = item[\"message\"][\"typeTag\"]\n        face_param = {\"type\": face_type}\n        for msg in face_msg:\n            k = msg[\"message\"][\"key\"][\"message\"][\"value\"]\n            v_item = msg[\"message\"][\"value\"][\"message\"][\"value\"]\n            if k == \"coordSystem\":\n                v = CustomOnshapeClient.parse_coord_msg(v_item)\n            elif isinstance(v_item, list):\n                v = [round(x[\"message\"][\"value\"], 8) for x in v_item]\n            else:\n                if isinstance(v_item, float):\n                    v = round(v_item, 8)\n                else:\n                    v = v_item\n            face_param.update({k: v})\n        faces.append(face_param)\n    return faces"
                },
                "expr2meter": {
                  "name": "expr2meter",
                  "path": "rapidcadpy.onshape_processing.custom_onshape_client.CustomOnshapeClient.expr2meter",
                  "signature": "(self, did, wid, eid, expr)",
                  "description": "convert value expression to meter unit",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "did",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "wid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "eid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "expr",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def expr2meter(self, did, wid, eid, expr):\n    \"\"\"convert value expression to meter unit\"\"\"\n    body = {\n        \"script\": \"function(context is Context, queries) { \"\n        '   return lookupTableEvaluate(\"%s\") * meter;' % (expr) + \"}\",\n        \"queries\": [],\n    }\n\n    res = self._api.request(\n        \"post\",\n        \"/api/partstudios/d/\" + did + \"/w/\" + wid + \"/e/\" + eid + \"/featurescript\",\n        body=body,\n    ).json()\n    return res[\"result\"][\"message\"][\"value\"]"
                },
                "bodydetails": {
                  "name": "bodydetails",
                  "path": "rapidcadpy.onshape_processing.custom_onshape_client.CustomOnshapeClient.bodydetails",
                  "signature": "(self, did, wid, eid)",
                  "description": "get the body details for specified element id\n\nArgs:\n    - did (str): Document ID\n    - wid (str): Workspace ID\n    - eid (str): Element ID\n\nReturns:\n    - requests.Response: OnShape response data",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "did",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "wid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "eid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def bodydetails(self, did, wid, eid):\n    \"\"\"get the body details for specified element id\n\n    Args:\n        - did (str): Document ID\n        - wid (str): Workspace ID\n        - eid (str): Element ID\n\n    Returns:\n        - requests.Response: OnShape response data\n    \"\"\"\n    res = self._api.request(\n        \"get\",\n        \"/api/partstudios/d/\" + did + \"/w/\" + wid + \"/e/\" + eid + \"/bodydetails\",\n    )\n\n    return res"
                }
              },
              "source": "class CustomOnshapeClient(Client):\n    def eval_compressed_query(self, did, wid, eid, compressed_query=None):\n        fs_function = \"\"\"\n            function(context is Context, queries){\n                var id = makeId(\"FVJi9rnRrDg7IKN\");\n                return evOwnerSketchPlane(\n            }\n        \"\"\"\n\n        body = {\n            \"script\": fs_function,\n        }\n\n        result = self._api.request(\n            \"post\",\n            \"/api/partstudios/d/\" + did + \"/w/\" + wid + \"/e/\" + eid + \"/featurescript\",\n            body=body,\n        )\n\n        return result\n\n    def get_entity_by_id(self, did, wid, eid, geo_id, entity_type):\n        \"\"\"get the parameters of geometry entity for specified entity id and type\n\n        Args:\n            - did (str): Document ID\n            - wid (str): Workspace ID\n            - eid (str): Element ID\n            - geo_id (str): geometry entity ID\n            - entity_type (str): 'VERTEX', 'EDGE' or 'FACE'\n\n        Returns:\n            - requests.Response: OnShape response data\n        \"\"\"\n        func_dict = {\n            \"VERTEX\": (\"evVertexPoint\", \"vertex\"),\n            \"EDGE\": (\"evCurveDefinition\", \"edge\"),\n            \"FACE\": (\"evSurfaceDefinition\", \"face\"),\n        }\n        body = {\n            \"script\": \"function(context is Context, queries) { \"\n            + \"   var res_list = [];\"\n            \"   var q_arr = evaluateQuery(context, queries.id);\"\n            \"   for (var i = 0; i < size(q_arr); i+= 1){\"\n            '       var res = %s(context, {\"%s\": q_arr[i]});'\n            % (func_dict[entity_type][0], func_dict[entity_type][1])\n            + \"       res_list = append(res_list, res);\"\n            \"   }\"\n            \"   return res_list;\"\n            \"}\",\n            \"queries\": [{\"key\": \"id\", \"value\": geo_id}],\n        }\n        res = self._api.request(\n            \"post\",\n            \"/api/partstudios/d/\" + did + \"/w/\" + wid + \"/e/\" + eid + \"/featurescript\",\n            body=body,\n        )\n\n        return res\n\n    @staticmethod\n    def parse_coord_msg(response):\n        \"\"\"parse coordSystem parameters from OnShape response data\"\"\"\n        coord_param = {}\n        for item in response:\n            k_msg = item[\"message\"][\"key\"]\n            k = k_msg[\"message\"][\"value\"]\n            v_msg = item[\"message\"][\"value\"]\n            v = [round(x[\"message\"][\"value\"], 8) for x in v_msg[\"message\"][\"value\"]]\n            coord_param.update({k: v})\n        return coord_param\n\n    @staticmethod\n    def parse_face_msg(response):\n        \"\"\"parse face parameters from OnShape response data\"\"\"\n        # data = response.json()['result']['message']['value']\n        data = [response] if not isinstance(response, list) else response\n        faces = []\n        for item in data:\n            face_msg = item[\"message\"][\"value\"]\n            face_type = item[\"message\"][\"typeTag\"]\n            face_param = {\"type\": face_type}\n            for msg in face_msg:\n                k = msg[\"message\"][\"key\"][\"message\"][\"value\"]\n                v_item = msg[\"message\"][\"value\"][\"message\"][\"value\"]\n                if k == \"coordSystem\":\n                    v = CustomOnshapeClient.parse_coord_msg(v_item)\n                elif isinstance(v_item, list):\n                    v = [round(x[\"message\"][\"value\"], 8) for x in v_item]\n                else:\n                    if isinstance(v_item, float):\n                        v = round(v_item, 8)\n                    else:\n                        v = v_item\n                face_param.update({k: v})\n            faces.append(face_param)\n        return faces\n\n    def expr2meter(self, did, wid, eid, expr):\n        \"\"\"convert value expression to meter unit\"\"\"\n        body = {\n            \"script\": \"function(context is Context, queries) { \"\n            '   return lookupTableEvaluate(\"%s\") * meter;' % (expr) + \"}\",\n            \"queries\": [],\n        }\n\n        res = self._api.request(\n            \"post\",\n            \"/api/partstudios/d/\" + did + \"/w/\" + wid + \"/e/\" + eid + \"/featurescript\",\n            body=body,\n        ).json()\n        return res[\"result\"][\"message\"][\"value\"]\n\n    def bodydetails(self, did, wid, eid):\n        \"\"\"get the body details for specified element id\n\n        Args:\n            - did (str): Document ID\n            - wid (str): Workspace ID\n            - eid (str): Element ID\n\n        Returns:\n            - requests.Response: OnShape response data\n        \"\"\"\n        res = self._api.request(\n            \"get\",\n            \"/api/partstudios/d/\" + did + \"/w/\" + wid + \"/e/\" + eid + \"/bodydetails\",\n        )\n\n        return res",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "feature_list_parser": {
          "name": "feature_list_parser",
          "path": "rapidcadpy.onshape_processing.feature_list_parser",
          "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/onshape_processing/feature_list_parser.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "EXTENT_TYPE_MAP",
              "annotation": null,
              "description": null,
              "value": "{'BLIND': 'OneSideFeatureExtentType', 'SYMMETRIC': 'SymmetricFeatureExtentType'}"
            },
            {
              "name": "OPERATION_MAP",
              "annotation": null,
              "description": null,
              "value": "{'NEW': 'NewBodyFeatureOperation', 'ADD': 'JoinFeatureOperation', 'REMOVE': 'CutFeatureOperation', 'INTERSECT': 'IntersectFeatureOperation'}"
            }
          ],
          "modules": {},
          "classes": {
            "FeatureListParser": {
              "name": "FeatureListParser",
              "path": "rapidcadpy.onshape_processing.feature_list_parser.FeatureListParser",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "client",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "feature_list",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "did",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "wid",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "eid",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "feature_list",
                  "annotation": null,
                  "description": null,
                  "value": "feature_list"
                },
                {
                  "name": "client",
                  "annotation": null,
                  "description": null,
                  "value": "client"
                },
                {
                  "name": "did",
                  "annotation": null,
                  "description": null,
                  "value": "did"
                },
                {
                  "name": "wid",
                  "annotation": null,
                  "description": null,
                  "value": "wid"
                },
                {
                  "name": "eid",
                  "annotation": null,
                  "description": null,
                  "value": "eid"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "rapidcadpy.onshape_processing.feature_list_parser.FeatureListParser.__init__",
                  "signature": "(self, client, feature_list, did, wid, eid)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "client",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "feature_list",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "did",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "wid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "eid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, client, feature_list, did, wid, eid):\n    self.feature_list = feature_list\n    self.client = client\n    self.did = did\n    self.wid = wid\n    self.eid = eid"
                },
                "parse": {
                  "name": "parse",
                  "path": "rapidcadpy.onshape_processing.feature_list_parser.FeatureListParser.parse",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def parse(self):\n    result = {\"entities\": OrderedDict(), \"properties\": {}, \"sequence\": []}\n    sketch_parser = SketchParser(\n        client=self.client, did=self.did, wid=self.wid, eid=self.eid\n    )\n    extrude_parser = ExtrudeParser(\n        client=self.client, did=self.did, wid=self.wid, eid=self.eid\n    )\n    for i, feat_item in enumerate(self.feature_list[\"features\"]):\n        feat_type = feat_item[\"message\"][\"featureType\"]\n        feature_id = feat_item[\"message\"][\"featureId\"]\n\n        if feat_type == \"newSketch\":\n            sketch: Sketch = sketch_parser.parse(feat_item)\n            result[\"entities\"].update({feature_id: sketch})\n\n        elif feat_type == \"extrude\":\n            self.client.bodydetails(self.did, self.wid, self.eid).json()\n            extrude_dict = extrude_parser.parse(feat_item)\n            extruded_entity = result[\"entities\"][extrude_dict[\"entities\"][0]]\n            Extrude(\n                sketch=extruded_entity,\n                operation=extrude_dict[\"operation\"],\n                extent_type=extrude_dict[\"extent_type\"],\n                extent_one=extrude_dict[\"extent_one\"],\n                extent_two=extrude_dict[\"extent_two\"],\n            )\n            # result[\"entities\"].update({feature_id: extrude})\n\n        result[\"sequence\"].append({\"index\": i, \"entity\": feature_id})\n\n    return result"
                }
              },
              "source": "class FeatureListParser:\n    def __init__(self, client, feature_list, did, wid, eid):\n        self.feature_list = feature_list\n        self.client = client\n        self.did = did\n        self.wid = wid\n        self.eid = eid\n\n    def parse(self):\n        result = {\"entities\": OrderedDict(), \"properties\": {}, \"sequence\": []}\n        sketch_parser = SketchParser(\n            client=self.client, did=self.did, wid=self.wid, eid=self.eid\n        )\n        extrude_parser = ExtrudeParser(\n            client=self.client, did=self.did, wid=self.wid, eid=self.eid\n        )\n        for i, feat_item in enumerate(self.feature_list[\"features\"]):\n            feat_type = feat_item[\"message\"][\"featureType\"]\n            feature_id = feat_item[\"message\"][\"featureId\"]\n\n            if feat_type == \"newSketch\":\n                sketch: Sketch = sketch_parser.parse(feat_item)\n                result[\"entities\"].update({feature_id: sketch})\n\n            elif feat_type == \"extrude\":\n                self.client.bodydetails(self.did, self.wid, self.eid).json()\n                extrude_dict = extrude_parser.parse(feat_item)\n                extruded_entity = result[\"entities\"][extrude_dict[\"entities\"][0]]\n                Extrude(\n                    sketch=extruded_entity,\n                    operation=extrude_dict[\"operation\"],\n                    extent_type=extrude_dict[\"extent_type\"],\n                    extent_one=extrude_dict[\"extent_one\"],\n                    extent_two=extrude_dict[\"extent_two\"],\n                )\n                # result[\"entities\"].update({feature_id: extrude})\n\n            result[\"sequence\"].append({\"index\": i, \"entity\": feature_id})\n\n        return result",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "sketch_parser": {
          "name": "sketch_parser",
          "path": "rapidcadpy.onshape_processing.sketch_parser",
          "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/onshape_processing/sketch_parser.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "SketchParser": {
              "name": "SketchParser",
              "path": "rapidcadpy.onshape_processing.sketch_parser.SketchParser",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "client",
                  "annotation": "CustomOnshapeClient",
                  "description": null,
                  "value": null
                },
                {
                  "name": "did",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "wid",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "eid",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "client",
                  "annotation": null,
                  "description": null,
                  "value": "client"
                },
                {
                  "name": "did",
                  "annotation": null,
                  "description": null,
                  "value": "did"
                },
                {
                  "name": "wid",
                  "annotation": null,
                  "description": null,
                  "value": "wid"
                },
                {
                  "name": "eid",
                  "annotation": null,
                  "description": null,
                  "value": "eid"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "rapidcadpy.onshape_processing.sketch_parser.SketchParser.__init__",
                  "signature": "(self, client, did, wid, eid)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "client",
                      "annotation": "CustomOnshapeClient",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "did",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "wid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "eid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, client: CustomOnshapeClient, did, wid, eid):\n    self.client = client\n    self.did = did\n    self.wid = wid\n    self.eid = eid"
                },
                "_parse_parameter_list": {
                  "name": "_parse_parameter_list",
                  "path": "rapidcadpy.onshape_processing.sketch_parser.SketchParser._parse_parameter_list",
                  "signature": "(self, parameter_list)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parameter_list",
                      "annotation": "list",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _parse_parameter_list(self, parameter_list: list):\n    param_dict = {}\n    for i, param_item in enumerate(parameter_list):\n        param_msg = param_item[\"message\"]\n        param_id = param_msg[\"parameterId\"]\n        if \"queries\" in param_msg:\n            param_value = []\n            for i in range(len(param_msg[\"queries\"])):\n                param_value.extend(\n                    param_msg[\"queries\"][i][\"message\"][\"geometryIds\"]\n                )  # FIXME: could be error-prone\n        elif \"expression\" in param_msg:\n            param_value = param_msg[\"expression\"]\n        elif \"value\" in param_msg:\n            param_value = param_msg[\"value\"]\n        else:\n            raise NotImplementedError(\"param_msg:\\n{}\".format(param_msg))\n\n        param_dict.update({param_id: param_value})\n    return param_dict"
                },
                "_resolve_query": {
                  "name": "_resolve_query",
                  "path": "rapidcadpy.onshape_processing.sketch_parser.SketchParser._resolve_query",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _resolve_query(self):\n    return \"Dummy\""
                },
                "parse": {
                  "name": "parse",
                  "path": "rapidcadpy.onshape_processing.sketch_parser.SketchParser.parse",
                  "signature": "(self, feature_dict) -> Optional[Sketch]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "feature_dict",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Optional[rapidcadpy.cadseq.Sketch]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def parse(self, feature_dict) -> Optional[Sketch]:\n    feature_parameters = self._parse_parameter_list(\n        feature_dict[\"message\"][\"parameters\"]\n    )\n    plane: PlaneOld = self.parse_sketch_plane(feature_parameters)\n    primitive_entities = self.parse_primitive_entities(\n        feature_dict[\"message\"][\"entities\"]\n    )\n    constraints = self.parse_constraints(feature_dict[\"message\"][\"constraints\"])\n    # reference constraints to primitive entities\n    constraint_obj_list = []\n    for constraint in constraints:\n        constraint_type = constraint[\"type\"]\n        if (\"localFirst\" in constraint) and (\"localSecond\" in constraint):\n            local_first: Primitive = primitive_entities[\n                constraint[\"localFirst\"].split(\".\")[0]\n            ]\n            local_second: Primitive = primitive_entities[\n                constraint[\"localSecond\"].split(\".\")[0]\n            ]\n            if constraint[\"localFirst\"].endswith(\"start\"):\n                local_first: Vertex = local_first.start_point\n            else:\n                local_first: Vertex = local_first.end_point\n            if constraint[\"localSecond\"].endswith(\"start\"):\n                local_second: Vertex = local_second.start_point\n            else:\n                local_second: Vertex = local_second.end_point\n            options = {\n                \"COINCIDENT\": CoincidenceConstraint,\n            }\n            constraint_class = options.get(constraint_type, None)\n            if constraint_class is None:\n                continue\n            constraint_obj_list.append(constraint_class(local_first, local_second))\n\n    return Sketch(\n        constraints=constraint_obj_list,\n        sketch_plane=plane,\n        primitives=primitive_entities.values(),\n    )"
                },
                "parse_sketch_plane": {
                  "name": "parse_sketch_plane",
                  "path": "rapidcadpy.onshape_processing.sketch_parser.SketchParser.parse_sketch_plane",
                  "signature": "(self, feature_parameters)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "feature_parameters",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def parse_sketch_plane(self, feature_parameters):\n    geo_id = feature_parameters[\"sketchPlane\"][0]\n    response = self.client.get_entity_by_id(\n        self.did, self.wid, self.eid, [geo_id], \"FACE\"\n    )\n    plane_data = self.client.parse_face_msg(\n        response.json()[\"result\"][\"message\"][\"value\"]\n    )[0]\n    plane = PlaneOld.from_n_x_axis(\n        origin=plane_data[\"origin\"],\n        normal=plane_data[\"normal\"],\n        x_axis=plane_data[\"x\"],\n    )\n    return plane"
                },
                "parse_constraints": {
                  "name": "parse_constraints",
                  "path": "rapidcadpy.onshape_processing.sketch_parser.SketchParser.parse_constraints",
                  "signature": "(self, constraint_list)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "constraint_list",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def parse_constraints(self, constraint_list):\n    constraint_obj = []\n    for constraint in constraint_list:\n        result_dict = {}\n        result_dict[\"type\"] = constraint[\"message\"][\"constraintType\"]\n        constraint_parameters = self._parse_parameter_list(\n            constraint[\"message\"][\"parameters\"]\n        )\n        if \"localFirst\" in constraint_parameters:\n            result_dict[\"localFirst\"] = constraint_parameters[\"localFirst\"]\n\n        if \"localSecond\" in constraint_parameters:\n            result_dict[\"localSecond\"] = constraint_parameters[\"localSecond\"]\n\n        constraint_obj.append(result_dict)\n    return constraint_obj"
                },
                "parse_primitive_entities": {
                  "name": "parse_primitive_entities",
                  "path": "rapidcadpy.onshape_processing.sketch_parser.SketchParser.parse_primitive_entities",
                  "signature": "(self, primitive_entities_list)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "primitive_entities_list",
                      "annotation": "list",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def parse_primitive_entities(self, primitive_entities_list: list):\n    primitive_entities_obj: Dict[str, Primitive] = {}\n    for entity in primitive_entities_list:\n        entity_id = entity[\"message\"][\"entityId\"]\n        primitive_entities_obj[entity_id] = Primitive.from_dict(entity)\n    return primitive_entities_obj"
                }
              },
              "source": "class SketchParser:\n    def __init__(self, client: CustomOnshapeClient, did, wid, eid):\n        self.client = client\n        self.did = did\n        self.wid = wid\n        self.eid = eid\n\n    def _parse_parameter_list(self, parameter_list: list):\n        param_dict = {}\n        for i, param_item in enumerate(parameter_list):\n            param_msg = param_item[\"message\"]\n            param_id = param_msg[\"parameterId\"]\n            if \"queries\" in param_msg:\n                param_value = []\n                for i in range(len(param_msg[\"queries\"])):\n                    param_value.extend(\n                        param_msg[\"queries\"][i][\"message\"][\"geometryIds\"]\n                    )  # FIXME: could be error-prone\n            elif \"expression\" in param_msg:\n                param_value = param_msg[\"expression\"]\n            elif \"value\" in param_msg:\n                param_value = param_msg[\"value\"]\n            else:\n                raise NotImplementedError(\"param_msg:\\n{}\".format(param_msg))\n\n            param_dict.update({param_id: param_value})\n        return param_dict\n\n    def _resolve_query(self):\n        return \"Dummy\"\n\n    def parse(self, feature_dict) -> Optional[Sketch]:\n        feature_parameters = self._parse_parameter_list(\n            feature_dict[\"message\"][\"parameters\"]\n        )\n        plane: PlaneOld = self.parse_sketch_plane(feature_parameters)\n        primitive_entities = self.parse_primitive_entities(\n            feature_dict[\"message\"][\"entities\"]\n        )\n        constraints = self.parse_constraints(feature_dict[\"message\"][\"constraints\"])\n        # reference constraints to primitive entities\n        constraint_obj_list = []\n        for constraint in constraints:\n            constraint_type = constraint[\"type\"]\n            if (\"localFirst\" in constraint) and (\"localSecond\" in constraint):\n                local_first: Primitive = primitive_entities[\n                    constraint[\"localFirst\"].split(\".\")[0]\n                ]\n                local_second: Primitive = primitive_entities[\n                    constraint[\"localSecond\"].split(\".\")[0]\n                ]\n                if constraint[\"localFirst\"].endswith(\"start\"):\n                    local_first: Vertex = local_first.start_point\n                else:\n                    local_first: Vertex = local_first.end_point\n                if constraint[\"localSecond\"].endswith(\"start\"):\n                    local_second: Vertex = local_second.start_point\n                else:\n                    local_second: Vertex = local_second.end_point\n                options = {\n                    \"COINCIDENT\": CoincidenceConstraint,\n                }\n                constraint_class = options.get(constraint_type, None)\n                if constraint_class is None:\n                    continue\n                constraint_obj_list.append(constraint_class(local_first, local_second))\n\n        return Sketch(\n            constraints=constraint_obj_list,\n            sketch_plane=plane,\n            primitives=primitive_entities.values(),\n        )\n\n    def parse_sketch_plane(self, feature_parameters):\n        geo_id = feature_parameters[\"sketchPlane\"][0]\n        response = self.client.get_entity_by_id(\n            self.did, self.wid, self.eid, [geo_id], \"FACE\"\n        )\n        plane_data = self.client.parse_face_msg(\n            response.json()[\"result\"][\"message\"][\"value\"]\n        )[0]\n        plane = PlaneOld.from_n_x_axis(\n            origin=plane_data[\"origin\"],\n            normal=plane_data[\"normal\"],\n            x_axis=plane_data[\"x\"],\n        )\n        return plane\n\n    def parse_constraints(self, constraint_list):\n        constraint_obj = []\n        for constraint in constraint_list:\n            result_dict = {}\n            result_dict[\"type\"] = constraint[\"message\"][\"constraintType\"]\n            constraint_parameters = self._parse_parameter_list(\n                constraint[\"message\"][\"parameters\"]\n            )\n            if \"localFirst\" in constraint_parameters:\n                result_dict[\"localFirst\"] = constraint_parameters[\"localFirst\"]\n\n            if \"localSecond\" in constraint_parameters:\n                result_dict[\"localSecond\"] = constraint_parameters[\"localSecond\"]\n\n            constraint_obj.append(result_dict)\n        return constraint_obj\n\n    def parse_primitive_entities(self, primitive_entities_list: list):\n        primitive_entities_obj: Dict[str, Primitive] = {}\n        for entity in primitive_entities_list:\n            entity_id = entity[\"message\"][\"entityId\"]\n            primitive_entities_obj[entity_id] = Primitive.from_dict(entity)\n        return primitive_entities_obj",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "process_onshape": {
          "name": "process_onshape",
          "path": "rapidcadpy.onshape_processing.process_onshape",
          "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/onshape_processing/process_onshape.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "url",
              "annotation": null,
              "description": null,
              "value": "'https://cad.onshape.com/documents/12d7e85cddb60c8cdebe7c33/w/4170277dd65d229c60b56fee/e/41f95128c810bf7238d32d43'"
            },
            {
              "name": "client",
              "annotation": null,
              "description": null,
              "value": "CustomOnshapeClient(creds='/Users/eliasberger/Documents/PhD/brep2cad/rapidcadpy/creds.json')"
            },
            {
              "name": "v_list",
              "annotation": null,
              "description": null,
              "value": "url.split('/')"
            },
            {
              "name": "features",
              "annotation": null,
              "description": null,
              "value": "client.get_features(did=document_id, wid=workplace_id, eid=element_id)"
            },
            {
              "name": "ofs_data",
              "annotation": null,
              "description": null,
              "value": "client.get_features(document_id, workplace_id, element_id).json()"
            },
            {
              "name": "parser",
              "annotation": null,
              "description": null,
              "value": "FeatureListParser(client, features.json(), document_id, workplace_id, element_id)"
            }
          ],
          "modules": {},
          "classes": {},
          "functions": {}
        }
      },
      "classes": {},
      "functions": {}
    },
    "ports": {
      "name": "ports",
      "path": "rapidcadpy.ports",
      "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/ports/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {
        "sketch_port": {
          "name": "sketch_port",
          "path": "rapidcadpy.ports.sketch_port",
          "filepath": "/Users/elias.berger/rapidcadpy/rapidcadpy/ports/sketch_port.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "SketchPort": {
              "name": "SketchPort",
              "path": "rapidcadpy.ports.sketch_port.SketchPort",
              "description": null,
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "draw_line": {
                  "name": "draw_line",
                  "path": "rapidcadpy.ports.sketch_port.SketchPort.draw_line",
                  "signature": "(self, start_point, end_point)",
                  "description": "Draws a line from start_point to end_point.\n\nArgs:\n    start_point (tuple): The starting point of the line (x, y).\n    end_point (tuple): The ending point of the line (x, y).",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "start_point",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "end_point",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@abstractmethod\ndef draw_line(self, start_point, end_point):\n    \"\"\"\n    Draws a line from start_point to end_point.\n\n    Args:\n        start_point (tuple): The starting point of the line (x, y).\n        end_point (tuple): The ending point of the line (x, y).\n    \"\"\"\n    pass"
                },
                "draw_circle": {
                  "name": "draw_circle",
                  "path": "rapidcadpy.ports.sketch_port.SketchPort.draw_circle",
                  "signature": "(self, center, radius)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "center",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "radius",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@abstractmethod\ndef draw_circle(self, center, radius):\n    pass"
                },
                "draw_arc": {
                  "name": "draw_arc",
                  "path": "rapidcadpy.ports.sketch_port.SketchPort.draw_arc",
                  "signature": "(self, start_point, mid_point, end_point)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "start_point",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "mid_point",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "end_point",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@abstractmethod\ndef draw_arc(self, start_point, mid_point, end_point):\n    pass"
                }
              },
              "source": "class SketchPort(ABC):\n    @abstractmethod\n    def draw_line(self, start_point, end_point):\n        \"\"\"\n        Draws a line from start_point to end_point.\n\n        Args:\n            start_point (tuple): The starting point of the line (x, y).\n            end_point (tuple): The ending point of the line (x, y).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def draw_circle(self, center, radius):\n        pass\n\n    @abstractmethod\n    def draw_arc(self, start_point, mid_point, end_point):\n        pass",
              "inherited_members": {}
            }
          },
          "functions": {}
        }
      },
      "classes": {},
      "functions": {}
    }
  },
  "classes": {},
  "functions": {},
  "version": "0.1.0"
}