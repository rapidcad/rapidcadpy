---
title: FEA Example
description: Perform structural analysis on your CAD models with integrated FEA
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Step, Steps } from 'fumadocs-ui/components/steps';

# Finite Element Analysis (FEA)

RapidCAD-Py includes integrated Finite Element Analysis powered by **torch-fem**, enabling you to validate your designs with structural analysis directly in Python.

<Callout type="info">
FEA requires additional dependencies. Install with: `pip install -e ".[fea]"`
</Callout>

## Quick Start

Here's a complete example of creating a model and analyzing it:

```python
from rapidcadpy.integrations.occ import OpenCascadeApp
from rapidcadpy.fea import (
    TorchFEMKernel,
    FEAAnalyzer,
    Material,
    FixedConstraint,
    DistributedLoad,
)

# Create geometry
app = OpenCascadeApp()
box = app.work_plane("XY").rect(20, 100).extrude(10)

# Create analyzer with kernel (dependency injection)
kernel = TorchFEMKernel()
analyzer = FEAAnalyzer(box, Material.STEEL, kernel, mesh_size=2.0)

# Add boundary conditions using fluent API
analyzer.add_constraint(FixedConstraint("x_min"))
analyzer.add_load(DistributedLoad("top", force=-1000.0))

# Preview boundary conditions
analyzer.show()

# Run analysis
results = analyzer.solve()

# View results
print(f"Max stress: {results.max_stress:.2f} MPa")
print(f"Safety factor: {results.safety_factor():.2f}")
results.show(display='both')
```

## FEA Workflow

<Steps>

### Create Your Model

Start by creating a parametric CAD model using the fluent API:

```python
from rapidcadpy.integrations.occ import OpenCascadeApp

app = OpenCascadeApp()
wp = app.work_plane("XY")

# Create a cantilever beam
beam = wp.rect(width=10, height=100).extrude(thickness=10)
```

### Set Up the Analyzer

Create an `FEAAnalyzer` with dependency injection for the solver kernel:

```python
from rapidcadpy.fea import TorchFEMKernel, FEAAnalyzer, Material

# Create the FEA kernel (torch-fem backend)
kernel = TorchFEMKernel()

# Create analyzer with shape, material, and kernel
analyzer = FEAAnalyzer(
    shape=beam,
    material=Material.STEEL,
    kernel=kernel,
    mesh_size=2.0,        # Mesh element size (mm)
    element_type="tet4",  # Tetrahedral elements
)
```

### Define Material Properties

Choose from pre-defined materials or create custom ones:

<Tabs items={['Pre-defined Materials', 'Custom Material']}>
  <Tab value="Pre-defined Materials">
    ```python
    from rapidcadpy.fea import Material
    
    # Use built-in materials
    material = Material.STEEL              # Structural steel
    material = Material.ALUMINUM_6061      # Aluminum alloy
    material = Material.TITANIUM_GRADE_5   # Titanium
    material = Material.STAINLESS_STEEL_304
    material = Material.CARBON_FIBER
    ```
  </Tab>
  
  <Tab value="Custom Material">
    ```python
    from rapidcadpy.fea import MaterialProperties
    
    # Define custom material
    material = MaterialProperties(
        name="Custom Alloy",
        E=200000.0,              # Young's modulus (MPa)
        nu=0.3,                  # Poisson's ratio
        density=7.85,            # Density (g/cm¬≥)
        yield_strength=250.0,    # Yield strength (MPa)
        ultimate_strength=400.0  # Ultimate strength (MPa)
    )
    ```
  </Tab>
</Tabs>

### Define Constraints and Loads

Use the fluent API to add constraints and loads to the analyzer:

```python
from rapidcadpy.fea import (
    FixedConstraint, 
    DistributedLoad, 
    PointLoad
)

# Add constraints (fluent API - returns self for chaining)
analyzer.add_constraint(FixedConstraint("x_min"))

# Add loads
analyzer.add_load(DistributedLoad("top", force=-1000.0))

# Or chain multiple boundary conditions
analyzer.add_constraint(FixedConstraint("x_min")) \
        .add_load(DistributedLoad("top", force=-1000.0)) \
        .add_load(PointLoad(point=(5, 50, 10), force=(0, 0, -500)))
```



### Preview Boundary Conditions

Visualize constraints and loads before solving:

```python
# Show mesh with boundary conditions
analyzer.show()
```

Shows:
- üî¥ **Red spheres** - Fixed/constrained nodes
- üü¢ **Green spheres** - Loaded nodes
- ‚û°Ô∏è **Green arrows** - Force direction and magnitude

### Run Analysis

Execute the FEA solver:

```python
results = analyzer.solve()
```

### Analyze Results

Access results and check safety:

```python
# Get key metrics
max_disp = results.max_displacement  # mm
max_stress = results.max_stress      # MPa
mean_stress = results.mean_stress    # MPa

# Calculate safety factor
safety_factor = results.safety_factor()

# Print summary
print(results.summary())

# Visualize
results.show(display='both')         # Stress + displacement
results.show(display='conditions')    # Boundary conditions
```

</Steps>

## Results Analysis

### FEAResults Object

The `analyzer.solve()` method returns an `FEAResults` object with comprehensive data:

```python
results = analyzer.solve()

# Properties
results.max_displacement      # Maximum displacement (mm)
results.max_stress           # Maximum von Mises stress (MPa)
results.min_stress           # Minimum stress (MPa)
results.mean_stress          # Average stress (MPa)

# Mesh information
results.nodes                # Node coordinates tensor
results.elements             # Element connectivity tensor
results.mesh_size            # Mesh element size
results.element_type         # Element type (tet4, hex8, etc.)

# Solution data
results.displacement         # Nodal displacement tensor
results.stress              # Element stress tensor
results.von_mises_stress    # Von Mises stress tensor

# Geometry
results.bounding_box        # Model bounds
results.volume              # Volume (mm¬≥)
results.mass                # Mass (kg)

# Material
results.material            # Material properties used
```

### Safety Analysis

```python
# Calculate factor of safety
fos = results.safety_factor()

# With custom yield strength
fos = results.safety_factor(yield_strength=300.0)

# Make design decisions
if fos > 2.0:
    print("‚úì Design is safe with 2x safety margin")
    beam.export("approved_design.step")
elif fos > 1.0:
    print("‚ö† Design is marginal, consider strengthening")
else:
    print("‚úó Design failure predicted, redesign required")
```

### Text Summary

```python
# Generate comprehensive report
print(results.summary())
```

Output:
```
================================================================================
FEA ANALYSIS RESULTS SUMMARY
================================================================================

Material: Structural Steel
  E = 210,000 MPa
  ŒΩ = 0.3
  Density = 7.85 g/cm¬≥

Mesh:
  Nodes: 1,234
  Elements: 5,678
  Element type: tet4
  Mesh size: 2.0 mm

Geometry:
  Volume: 10000.00 mm¬≥
  Mass: 0.0785 kg (78.50 g)

Results:
  Max displacement: 1.234e-02 mm
  Max von Mises stress: 45.67 MPa
  Mean von Mises stress: 23.45 MPa

Safety Analysis:
  Yield strength: 250 MPa
  Factor of safety: 5.47
  Status: SAFE
================================================================================
```

### Export Results

```python
# Save screenshot
results.save_report('analysis_results.png')

# Export to VTK for ParaView
results.to_vtk('results.vtk')

# For Jupyter notebooks
results.show(display='both', jupyter_backend='static')
```

## Complete Examples

### Cantilever Beam

```python
from rapidcadpy.integrations.occ import OpenCascadeApp
from rapidcadpy.fea import (
    TorchFEMKernel,
    FEAAnalyzer,
    Material,
    FixedConstraint,
    DistributedLoad,
)

# Create beam
app = OpenCascadeApp()
beam = app.work_plane("XY").rect(10, 100).extrude(10)

# Set up analyzer
kernel = TorchFEMKernel()
analyzer = FEAAnalyzer(beam, Material.STEEL, kernel, mesh_size=2.0)

# Add boundary conditions
analyzer.add_constraint(FixedConstraint("x_min"))
analyzer.add_load(DistributedLoad("top", force=-1000.0))

# Preview setup
analyzer.show()

# Solve
results = analyzer.solve()

# Check results
print(f"Max deflection: {results.max_displacement:.4f} mm")
print(f"Max stress: {results.max_stress:.2f} MPa")
print(f"Safety factor: {results.safety_factor():.2f}")

results.show(display='both')
```

### Topology Optimization

Use SIMP (Solid Isotropic Material with Penalization) to optimize material distribution:

```python
from rapidcadpy.integrations.occ import OpenCascadeApp
from rapidcadpy.fea import (
    TorchFEMKernel,
    FEAAnalyzer,
    Material,
    FixedConstraint,
    DistributedLoad,
)

# Create design domain
app = OpenCascadeApp()
box = app.work_plane("XY").rect(20, 10).extrude(10)

# Set up analyzer
kernel = TorchFEMKernel()
analyzer = FEAAnalyzer(box, Material.STEEL, kernel, mesh_size=1.0)

# Add boundary conditions
analyzer.add_constraint(FixedConstraint("x_min"))
analyzer.add_load(DistributedLoad("top", force=-1000.0))

# Preview boundary conditions
analyzer.show()

# Run topology optimization
result = analyzer.optimize(
    volume_fraction=0.4,    # Target 40% of original volume
    num_iterations=50,      # Optimization iterations
    penalization=3.0,       # SIMP penalization factor
    filter_radius=1.5,      # Sensitivity filter radius
)

# View results
print(result.summary())
result.show(display="density")  # Show optimized density distribution
```

### Parametric Study

```python
import numpy as np
from rapidcadpy.integrations.occ import OpenCascadeApp
from rapidcadpy.fea import (
    TorchFEMKernel,
    FEAAnalyzer,
    Material,
    FixedConstraint,
    DistributedLoad,
)

def analyze_beam(width, height):
    """Analyze beam with given dimensions"""
    app = OpenCascadeApp()
    beam = app.work_plane("XY").rect(width, height).extrude(10)
    
    kernel = TorchFEMKernel()
    analyzer = FEAAnalyzer(beam, Material.ALUMINUM_6061, kernel, mesh_size=2.0)
    
    analyzer.add_constraint(FixedConstraint("x_min"))
    analyzer.add_load(DistributedLoad("top", force=-1000.0))
    
    results = analyzer.solve()
    
    return {
        'width': width,
        'height': height,
        'mass': results.mass,
        'max_stress': results.max_stress,
        'safety_factor': results.safety_factor()
    }

# Test different dimensions
dimensions = [(5, 50), (10, 100), (15, 150)]
results = [analyze_beam(w, h) for w, h in dimensions]

# Find optimal design
valid_designs = [r for r in results if r['safety_factor'] > 2.0]
optimal = min(valid_designs, key=lambda x: x['mass'])

print(f"Optimal design: {optimal['width']}x{optimal['height']} mm")
print(f"Mass: {optimal['mass']*1000:.2f} g")
print(f"Safety factor: {optimal['safety_factor']:.2f}")
```

### Bridge Structure

```python
from rapidcadpy.integrations.occ import OpenCascadeApp
from rapidcadpy.fea import (
    TorchFEMKernel,
    FEAAnalyzer,
    Material,
    FixedConstraint,
    DistributedLoad,
)

app = OpenCascadeApp()
wp = app.work_plane("XY")

# Create bridge deck
deck = wp.rect(20, 100).extrude(2)

# Add support beams
support1 = wp.move_to(0, 0).rect(20, 5).extrude(10)
support2 = wp.move_to(0, 95).rect(20, 5).extrude(10)

# Combine
bridge = deck.join(support1).join(support2)

# Set up analyzer
kernel = TorchFEMKernel()
analyzer = FEAAnalyzer(bridge, Material.STEEL, kernel, mesh_size=3.0)

# Add boundary conditions
analyzer.add_constraint(FixedConstraint("y_min"))  # Fix one end
analyzer.add_constraint(FixedConstraint("y_max"))  # Fix other end
analyzer.add_load(DistributedLoad("top", force=-5000.0))  # Traffic load

# Preview setup
analyzer.show()

# Solve
results = analyzer.solve()

# Validate design
if results.safety_factor() > 3.0:  # Higher safety for public structures
    print("‚úì Bridge design approved")
    bridge.export("bridge_approved.step")
    results.save_report("bridge_analysis.png")
else:
    print("‚úó Bridge needs reinforcement")
```

## Advanced Topics

### Mesh Control

```python
from rapidcadpy.fea import TorchFEMKernel, FEAAnalyzer, Material

kernel = TorchFEMKernel()

# Finer mesh for more accurate results
analyzer = FEAAnalyzer(
    shape=beam,
    material=Material.STEEL,
    kernel=kernel,
    mesh_size=1.0,  # Smaller = more elements, slower but more accurate
    element_type="tet4",
)

# Element types
# 'tet4'  - 4-node linear tetrahedron (default, fast)
# 'tet10' - 10-node quadratic tetrahedron (more accurate)
```

### Topology Optimization Parameters

Fine-tune the SIMP optimization:

```python
result = analyzer.optimize(
    volume_fraction=0.5,    # Target volume (0 < v < 1)
    num_iterations=100,     # More iterations = better convergence
    penalization=3.0,       # SIMP penalty (typically 3.0)
    filter_radius=1.5,      # Prevents checkerboard patterns
    move_limit=0.2,         # Max density change per iteration
    rho_min=1e-3,          # Minimum density to avoid singularity
    use_autograd=False,     # Use automatic differentiation
)

# Access optimization history
print(f"Final compliance: {result.compliance_history[-1]:.4e}")
print(f"Volume fraction achieved: {result.final_density.mean():.4f}")

# Visualize
result.show(display="density")      # Density distribution
result.show(display="compliance")   # Compliance convergence
```

### Custom Tolerance

```python
# Adjust tolerance for node selection
FixedConstraint(
    location='x_min',
    tolerance=0.5  # mm (default: 0.1)
)
```

### Dependency Injection Architecture

The FEA system uses dependency injection, allowing different solver backends:

```python
from rapidcadpy.fea import FEAAnalyzer, TorchFEMKernel

# TorchFEMKernel is the default (and currently only) backend
kernel = TorchFEMKernel()

# Check solver availability
if TorchFEMKernel.is_available():
    print(f"Using solver: {kernel.get_solver_name()}")
    
# Create analyzer with injected kernel
analyzer = FEAAnalyzer(shape, material, kernel)
```

### Reusing Analyzers

You can modify and re-run analysis without recreating the analyzer:

```python
# Initial analysis
analyzer = FEAAnalyzer(beam, Material.STEEL, kernel, mesh_size=2.0)
analyzer.add_constraint(FixedConstraint("x_min"))
analyzer.add_load(DistributedLoad("top", force=-500.0))
results1 = analyzer.solve()

# Add more loads and re-solve
analyzer.add_load(DistributedLoad("y_max", force=-500.0))
results2 = analyzer.solve()

# Compare results
print(f"Load 1: {results1.max_stress:.2f} MPa")
print(f"Load 2: {results2.max_stress:.2f} MPa")
```

## Troubleshooting

### Common Issues

**"No nodes found at location"**
- Increase `tolerance` parameter
- Verify location identifier matches your geometry
- Use `results.bounding_box` to check geometry bounds

**"mesh_size too large"**
- Reduce `mesh_size` for finer mesh
- Very small parts need smaller mesh sizes

**"Singular matrix / solver failed"**
- Check that constraints properly support the model
- Ensure loads are applied correctly
- Verify geometry is valid (no zero-thickness parts)

**"ImportError: FEA dependencies not available"**
- Install FEA support: `pip install -e ".[fea]"`

### Best Practices

1. **Start with coarser mesh** (`mesh_size=5.0`) for quick iterations
2. **Refine mesh** (`mesh_size=1.0`) for final validation
3. **Always check safety factor** before trusting results
4. **Visualize boundary conditions** first to verify setup
5. **Use appropriate safety factors** (typically 2.0-3.0 for structures)
6. **Validate with hand calculations** for simple cases

## API Reference

See the [Python API Reference](/docs/python) for detailed class and method documentation.

## Next Steps

- Explore [example scripts](https://github.com/rapidcad/rapidcadpy/tree/main/examples/fea)
- Learn about [parametric modeling](/docs/fluent-api)
- Understand [workplanes](/docs/workplanes)
