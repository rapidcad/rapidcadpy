---
title: Cad
---

## Attributes

<PyAttribute name={"construction_history"} type={null} value={"construction_sequence"} />

<PyAttribute name={"bbox"} type={null} value={"bounding_box"} />

## Functions

<PyFunction name={"__init__"} type={"(self, construction_sequence, bounding_box=None)"}>

<PySourceCode >

```python
def __init__(
    self, construction_sequence: List[Feature], bounding_box: Optional[Any] = None
):
    self.construction_history = construction_sequence
    self.bbox = bounding_box
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"construction_sequence"} type={"List[Feature]"} value={null} />
<PyParameter name={"bounding_box"} type={"Optional[Any]"} value={"None"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"__str__"} type={"(self)"}>

<PySourceCode >

```python
def __str__(self):
    construction_hist_str = "\n".join(
        [
            str(sketch_extrude)
            for i, sketch_extrude in enumerate(self.construction_history)
        ]
    )
    return construction_hist_str
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"create_edge_3d"} type={"(curve, sketch_plane)"}>

create a 3D edge

<PySourceCode >

```python
@staticmethod
def create_edge_3d(curve, sketch_plane: Plane):
    """create a 3D edge"""
    from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeEdge
    from OCC.Core.GC import GC_MakeArcOfCircle
    from OCC.Core.gp import gp_Ax2, gp_Circ, gp_Dir

    if isinstance(curve, Line):
        if np.allclose(curve.start_point, curve.end_point):
            return -1

        # translate to global coordinates
        start_point = (
            curve.start_point.x * sketch_plane.x_dir
            + curve.start_point.y * sketch_plane.y_dir
        ) + sketch_plane.origin
        end_point = (
            curve.end_point.x * sketch_plane.x_dir
            + curve.end_point.y * sketch_plane.y_dir
        ) + sketch_plane.origin

        start_point = gp_Pnt(*start_point)
        end_point = gp_Pnt(*end_point)

        topo_edge = BRepBuilderAPI_MakeEdge(start_point, end_point)
    elif isinstance(curve, Circle):
        center = (
            curve.center.x * sketch_plane.x_dir
            + curve.center.y * sketch_plane.y_dir
            + sketch_plane.origin
        )
        center = gp_Pnt(*center)
        axis = gp_Dir(*[float(v) for v in sketch_plane.z_dir])
        gp_circle = gp_Circ(gp_Ax2(center, axis), abs(float(curve.radius)))
        topo_edge = BRepBuilderAPI_MakeEdge(gp_circle)
    elif isinstance(curve, Arc):
        start_point = (
            curve.start_point.x * sketch_plane.x_dir
            + curve.start_point.y * sketch_plane.y_dir
        ) + sketch_plane.origin
        end_point = (
            curve.end_point.x * sketch_plane.x_dir
            + curve.end_point.y * sketch_plane.y_dir
        ) + sketch_plane.origin
        mid_point = (
            curve.mid_point.x * sketch_plane.x_dir
            + curve.mid_point.y * sketch_plane.y_dir
        ) + sketch_plane.origin

        start_point = gp_Pnt(*start_point)
        mid_point = gp_Pnt(*mid_point)
        end_point = gp_Pnt(*end_point)
        arc = GC_MakeArcOfCircle(start_point, mid_point, end_point).Value()

        topo_edge = BRepBuilderAPI_MakeEdge(arc)
    else:
        raise NotImplementedError(type(curve))
    return topo_edge.Edge()
```

</PySourceCode>

<div >

<PyParameter name={"curve"} type={null} value={null} />
<PyParameter name={"sketch_plane"} type={"Plane"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_create_profile_face"} type={"(outer_wire, inner_wires=None)"}>

create a face from a sketch profile and the sketch plane

<PySourceCode >

```python
@staticmethod
def _create_profile_face(outer_wire, inner_wires: List[TopoDS_Wire] = None):
    """create a face from a sketch profile and the sketch plane"""
    from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeFace

    topo_face = BRepBuilderAPI_MakeFace(outer_wire)
    if inner_wires:
        for inner_wire in inner_wires:
            topo_face.Add(inner_wire.Reversed())
    return topo_face.Face()
```

</PySourceCode>

<div >

<PyParameter name={"outer_wire"} type={null} value={null} />
<PyParameter name={"inner_wires"} type={"List[TopoDS_Wire]"} value={"None"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_create_loop_3d"} type={"(outer_wire, sketch_plane) -> TopoDS_Wire"}>

create a 3D sketch loop

<PySourceCode >

```python
@staticmethod
def _create_loop_3d(outer_wire: Wire, sketch_plane: Plane) -> TopoDS_Wire:
    """create a 3D sketch loop"""
    from OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeWire
    from OCC.Core.ShapeFix import ShapeFix_Wire

    topo_wire = BRepBuilderAPI_MakeWire()
    for edge in outer_wire.edges:
        topo_edge = Cad.create_edge_3d(edge, sketch_plane)
        if topo_edge == -1:  # omitted
            continue
        topo_wire.Add(topo_edge)
    wire = topo_wire.Wire()

    fixer = ShapeFix_Wire()
    fixer.Load(wire)
    fixer.FixReorder()  # Reorder edges
    fixer.FixConnected()  # Ensure continuity
    fixer.FixClosed()  # Ensure closure
    fixer.Perform()

    return fixer.Wire()
```

</PySourceCode>

<div >

<PyParameter name={"outer_wire"} type={"Wire"} value={null} />
<PyParameter name={"sketch_plane"} type={"Plane"} value={null} />

</div>

<PyFunctionReturn type={"OCC.Core.TopoDS.TopoDS_Wire"} />

</PyFunction>

<PyFunction name={"_create_by_extrude"} type={"(sk_ex)"}>

<PySourceCode >

```python
@staticmethod
def _create_by_extrude(sk_ex: SketchExtrude):
    from OCC.Core.BRepAlgoAPI import BRepAlgoAPI_Fuse
    from OCC.Core.BRepPrimAPI import BRepPrimAPI_MakePrism
    from OCC.Core.gp import gp_Vec

    """create a solid body from Extrude instance."""
    bodies = []
    for sketch in sk_ex.sketch:
        outer_wire = copy(sketch.outer_wire)
        sketch_plane = copy(sketch.sketch_plane)
        sketch_plane.origin = sketch.sketch_plane.origin
        try:
            outer_wire = Cad._create_loop_3d(outer_wire, sketch_plane)
            inner_wires: List[TopoDS_Wire] = []
            for inner_wire in sketch.inner_wires:
                inner_wires.append(Cad._create_loop_3d(inner_wire, sketch_plane))
            face = Cad._create_profile_face(outer_wire, inner_wires)

            normal = gp_Dir(
                *[float(v) * sk_ex.extrude.direction for v in sketch_plane.z_dir]
            )

            ext_vec = gp_Vec(normal).Multiplied(float(sk_ex.extrude.extent_one))

            body = BRepPrimAPI_MakePrism(face, ext_vec).Shape()
            bodies.append(body)
        except RuntimeError:
            continue

    # fuse bodies into one
    if len(bodies) > 1:
        body = bodies[0]
        for b in bodies[1:]:
            body = BRepAlgoAPI_Fuse(body, b).Shape()
    elif len(bodies) == 1:
        body = bodies[0]
    else:
        return None

    return body
```

</PySourceCode>

<div >

<PyParameter name={"sk_ex"} type={"SketchExtrude"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"to_occ"} type={"(self)"}>

<PySourceCode >

```python
def to_occ(self):
    from OCC.Core.BRepAlgoAPI import (
        BRepAlgoAPI_Common,
        BRepAlgoAPI_Cut,
        BRepAlgoAPI_Fuse,
    )

    bodies = []
    for sk_ex in self.construction_history:
        body = Cad._create_by_extrude(sk_ex)
        if body is not None:
            bodies.append(body)

    if len(bodies) == 0:
        return None
    elif len(bodies) == 1:
        return bodies[0]
    else:
        # fuse all bodies
        result = bodies[0]
        for body in bodies[1:]:
            if (
                sk_ex.extrude.operation == "NewBodyFeatureOperation"
                or sk_ex.extrude.operation == "JoinFeatureOperation"
            ):
                result = BRepAlgoAPI_Fuse(result, body).Shape()
            elif sk_ex.extrude.operation == "CutFeatureOperation":
                result = BRepAlgoAPI_Cut(result, body).Shape()
            elif sk_ex.extrude.operation == "IntersectFeatureOperation":
                result = BRepAlgoAPI_Common(result, body).Shape()
        return result
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"to_step"} type={"(self, filename)"}>

<PySourceCode >

```python
def to_step(self, filename: pathlib.Path | str):
    assert str(filename).endswith(".step") or str(filename).endswith(".stp")
    shape = self.to_occ()
    step_writer = STEPControl_Writer()
    step_writer.Transfer(shape, STEPControl_AsIs)
    success = step_writer.Write(str(filename)) == IFSelect_RetDone
    return success
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"filename"} type={"pathlib.Path | str"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"plot"} type={"(self, title='Sketch Extrude', bounding_box=False)"}>

<PySourceCode >

```python
def plot(self, title="Sketch Extrude", bounding_box=False):
    fig = go.Figure()
    for sketch_extrude in self.construction_history:
        for sketch in sketch_extrude.sketch:
            for trace in sketch.plot(return_fig=True):
                if trace is not None:
                    fig.add_trace(trace)
    fig.update_layout(
        title=title,
        scene=dict(aspectmode="cube"),
        xaxis=dict(scaleanchor="y", title="X Axis"),
        yaxis=dict(title="Y Axis"),
        showlegend=False,
        autosize=True,
    )
    fig.show()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"title"} type={null} value={"'Sketch Extrude'"} />
<PyParameter name={"bounding_box"} type={null} value={"False"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"show_3d"} type={"(self)"}>

<PySourceCode >

```python
def show_3d(self):
    display, start_display, add_menu, add_function_to_menu = init_display()
    compounds = self.to_occ()
    display.DisplayShape(compounds, color=rgb_color(0.9, 0.9, 0.9))
    start_display()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"from_dict"} type={"(all_stat)"}>

construct CADSequence from json data

<PySourceCode >

```python
@staticmethod
def from_dict(all_stat):
    """construct CADSequence from json data"""

    # Loop through all the sequence

    sketch_seq = []
    extrude_seq = []

    for item in all_stat["seq"]:
        if item["type"] == "ExtrudeFeature":
            extrude_ops = Extrude.from_dict(
                all_stat, item["entity"]
            )  # Passes the whole data and id
            uid_pairs = extrude_ops.get_profile_uids()
            if len(uid_pairs) == 0:
                continue
            extrude_seq.append(extrude_ops)

            sketch_ops = Sketch.from_dict(all_stat, uid_pairs)
            sketch_seq.append(sketch_ops)

    # Combine sketch and extrude operations
    sketch_extrude_list = []
    for i in range(len(sketch_seq)):
        sketch_extrude_list.append(
            SketchExtrude(sketch=sketch_seq[i], extrude=extrude_seq[i])
        )

    return Cad(construction_sequence=sketch_extrude_list)
```

</PySourceCode>

<div >

<PyParameter name={"all_stat"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"numericalize"} type={"(self, n=256)"}>

<PySourceCode >

```python
def numericalize(self, n=256):
    for sketch_extrude in self.construction_history:
        for sketch in sketch_extrude.sketch:
            sketch.numericalize(n)
        sketch_extrude.extrude.numericalize(n)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"n"} type={null} value={"256"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"normalize"} type={"(self) -> None"}>

Normalize the CAD sequence to a common scale and center

<PySourceCode >

```python
def normalize(self) -> None:
    """
    Normalize the CAD sequence to a common scale and center
    """
    # find largest bounding box size
    global_min = np.array([float("inf"), float("inf")])
    global_max = np.array([-float("inf"), -float("inf")])
    for sketch_extrude in self.construction_history:
        sketch_extrude: SketchExtrude
        bbox_max = sketch_extrude.bbox[1]
        bbox_min = sketch_extrude.bbox[0]
        global_max = np.maximum(global_max, bbox_max)
        global_min = np.minimum(global_min, bbox_min)

    # scale into unit cube
    global_width = global_max[0] - global_min[0]
    global_height = global_max[1] - global_min[1]
    scale = 1 / max(global_width, global_height)

    # global_center = (global_max + global_min) / 2
    first_origin = self.construction_history[0].sketch[0].sketch_plane.origin
    for sketch_extrude in self.construction_history:
        sketch_extrude.extrude.transform(scale=scale)
        for sketch in sketch_extrude.sketch:
            # first center
            sketch.sketch_plane.origin -= first_origin
            # then scale down into unit square
            sketch.normalize(translation=np.zeros(2), scale=scale)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"apply_data_cleaning"} type={"(self, visualize_steps=True)"}>

<PySourceCode >

```python
def apply_data_cleaning(self, visualize_steps=True):
    for sketch_extrude in self.construction_history:
        for sketch in sketch_extrude.sketch:
            sketch.fix_start_end_points()
    self.plot("After Fixing Start and End Points") if visualize_steps else None
    for sketch_extrude in self.construction_history:
        for sketch in sketch_extrude.sketch:
            sketch.remove_coincidences()
    self.plot("After Removing Coincidences") if visualize_steps else None
    for sketch_extrude in self.construction_history:
        for sketch in sketch_extrude.sketch:
            sketch.order_edges()
    self.plot("After Ordering Edges") if visualize_steps else None
    return self
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"visualize_steps"} type={null} value={"True"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"to_png"} type={"(self)"}>

<PySourceCode >

```python
def to_png(self):
    occ_obj = self.to_occ()
    display, start_display, add_menu, add_function_to_menu = init_display()
    display.DisplayShape(occ_obj, update=True)

    # Set background color (optional)
    display.Context.SetBackgroundColor(rgb_color(1.0, 1.0, 1.0))  # White background

    # Fit view and render
    display.FitAll()
    display.View.MustBeResized()
    display.Context.UpdateCurrentViewer()

    # Create an image and dump the view
    img = Image_AlienPixMap()
    width, height = 800, 600
    img.InitTrash(width, height, True)
    display.View.Dump(img, width, height)

    # Save to file
    output_path = "box_render.png"
    img.Save(output_path)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"render_3d"} type={"(self, title=None)"}>

<PySourceCode >

```python
def render_3d(self, title: Optional[str] = None):
    import io

    import cairosvg
    from matplotlib import pyplot as plt
    from PIL import Image

    parts = self.to_occ()
    from scripts.visualization.visualize_output import render_result

    render_result(parts, file_name="temp.svg")

    # Convert the SVG to PNG bytes
    png_bytes = cairosvg.svg2png(
        file_obj=open("temp.svg", "rb"),  # Open in binary mode
        dpi=300,
    )

    # Use BytesIO to convert bytes to a file-like object
    image_stream = io.BytesIO(png_bytes)

    # Open the image using PIL
    image = Image.open(image_stream)

    # Convert the image to a NumPy array
    image_array = np.array(image)

    # Display the image using imshow
    plt.imshow(image_array)
    plt.axis("off")  # Turn off the axis
    if title:
        plt.title(title)
    plt.show()  # Show the image

    return png_bytes
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"title"} type={"Optional[str]"} value={"None"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"to_json"} type={"(self)"}>

<PySourceCode >

```python
def to_json(self):
    return {
        "seq": [
            s.to_json(index=i) for i, s in enumerate(self.construction_history)
        ],
    }
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"from_json"} type={"(json_data)"}>

<PySourceCode >

```python
@staticmethod
def from_json(json_data):
    seq = []
    for i, sketch_extrude in enumerate(json_data["seq"]):
        sketch = Sketch.from_json(sketch_extrude["sketch"])
        extrude = Extrude.from_json(sketch_extrude["extrude"])
        seq.append(SketchExtrude(sketch=sketch, extrude=extrude))
    return Cad(construction_sequence=seq)
```

</PySourceCode>

<div >

<PyParameter name={"json_data"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"to_python"} type={"(self)"}>

<PySourceCode >

```python
def to_python(self):
    sketch_extrude_code = ""
    for i, sketch_extrude in enumerate(self.construction_history):
        sketch_extrude_code += "\n" + sketch_extrude.to_python(index=i)

    cs = sketch_extrude_code
    cs_variables = ", ".join(
        [f"sketch_extrude_{i}" for i in range(len(self.construction_history))]
    )
    cs += f"\ncad = Cad([{cs_variables}])\n"
    return cs
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"to_build123d"} type={"(self)"}>

<PySourceCode >

```python
def to_build123d(self):
    from build123d import Compound

    parts = []
    from build123d import extrude

    for i, sketch_extrude in enumerate(self.construction_history):
        sketch_extrude: SketchExtrude
        build123d_face = sketch_extrude.sketch[0].to_build123d()
        parts.append(
            extrude(
                to_extrude=build123d_face,
                amount=sketch_extrude.extrude.extent_one,
                both=False,
                dir=sketch_extrude.sketch[0].sketch_plane.z_dir,
                taper=sketch_extrude.extrude.taper_angle_one,
            )
        )
    return Compound(parts)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"to_svg"} type={"(self, file_name=None)"}>

<PySourceCode >

```python
def to_svg(self, file_name: Optional[str] = None):
    import cairosvg
    from scripts.visualization.visualize_output import render_result

    shape = self.to_build123d()
    render_result(shape, file_name="temp.svg")

    # Convert the SVG to PNG bytes
    png_bytes = cairosvg.svg2png(
        file_obj=open("temp.svg", "rb"),  # Open in binary mode
        dpi=300,
    )

    # Use BytesIO to convert bytes to a file-like object
    image_stream = io.BytesIO(png_bytes)

    # Open the image using PIL
    image = Image.open(image_stream)

    # Convert the image to a NumPy array
    image_array = np.array(image)

    # Display the image using imshow
    plt.imshow(image_array)
    plt.axis("off")  # Turn off the axis
    plt.show()  # Show the image

    return png_bytes
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"file_name"} type={"Optional[str]"} value={"None"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"denumericalize"} type={"(self, n=256)"}>

Reverse the numericalization process by dividing all numericalized values by n.
This should be called after numericalize() to restore the original values.

Args:
    n: The same normalization factor used in numericalize() (default: 256)

<PySourceCode >

```python
def denumericalize(self, n=256):
    """
    Reverse the numericalization process by dividing all numericalized values by n.
    This should be called after numericalize() to restore the original values.

    Args:
        n: The same normalization factor used in numericalize() (default: 256)
    """
    for sketch_extrude in self.construction_history:
        for sketch in sketch_extrude.sketch:
            if hasattr(sketch, "denumericalize"):
                sketch.denumericalize(n)
            else:
                # Fallback in case sketch doesn't have denumericalize method
                sketch.numericalize(1)  # Reset to unnormalized values

        if hasattr(sketch_extrude.extrude, "denumericalize"):
            sketch_extrude.extrude.denumericalize(n)
        else:
            # Fallback in case extrude doesn't have denumericalize method
            sketch_extrude.extrude.numericalize(1)  # Reset to unnormalized values
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"n"} type={null} value={"256"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"round"} type={"(self, decimals=6)"}>

Round all float values in the CAD object and its children to the specified number of decimal places.

Args:
    decimals: Number of decimal places to round to (default: 6)

<PySourceCode >

```python
def round(self, decimals: int = 6):
    """
    Round all float values in the CAD object and its children to the specified number of decimal places.

    Args:
        decimals: Number of decimal places to round to (default: 6)
    """
    for sketch_extrude in self.construction_history:
        # Round sketch extrude parameters
        if hasattr(sketch_extrude.extrude, "extent_one"):
            sketch_extrude.extrude.extent_one = round(
                sketch_extrude.extrude.extent_one, decimals
            )
        if hasattr(sketch_extrude.extrude, "extent_two"):
            sketch_extrude.extrude.extent_two = round(
                sketch_extrude.extrude.extent_two, decimals
            )
        if hasattr(sketch_extrude.extrude, "direction"):
            sketch_extrude.extrude.direction = round(
                sketch_extrude.extrude.direction, decimals
            )

        for sketch in sketch_extrude.sketch:
            # Round sketch plane parameters
            if hasattr(sketch.sketch_plane, "origin"):
                sketch.sketch_plane.origin.round(decimals)
            if hasattr(sketch.sketch_plane, "x_dir"):
                sketch.sketch_plane.x_dir.round(decimals)
            if hasattr(sketch.sketch_plane, "y_dir"):
                sketch.sketch_plane.y_dir.round(decimals)
            if hasattr(sketch.sketch_plane, "z_dir"):
                sketch.sketch_plane.z_dir.round(decimals)

            # Round wires and curves
            if hasattr(sketch, "outer_wire") and sketch.outer_wire is not None:
                self._round_wire(sketch.outer_wire, decimals)

            if hasattr(sketch, "inner_wires") and sketch.inner_wires is not None:
                for wire in sketch.inner_wires:
                    self._round_wire(wire, decimals)

    # Round bounding box if it exists
    if self.bbox is not None:
        self.bbox = np.round_(self.bbox, decimals)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"decimals"} type={"int"} value={"6"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_round_wire"} type={"(self, wire, decimals)"}>

Helper method to round all points in a wire's edges.

<PySourceCode >

```python
def _round_wire(self, wire, decimals):
    """Helper method to round all points in a wire's edges."""
    for edge in wire.edges:
        if hasattr(edge, "start_point"):
            edge.start_point.round(decimals)
        if hasattr(edge, "end_point"):
            edge.end_point.round(decimals)

        if hasattr(edge, "mid_point"):
            edge.mid_point.round(decimals)

        if hasattr(edge, "center"):
            edge.center.round(decimals)

        if hasattr(edge, "radius"):
            edge.radius = round(edge.radius, decimals)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"wire"} type={null} value={null} />
<PyParameter name={"decimals"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"add_machining_feature_json"} type={"(self, mf_json)"}>

<PySourceCode >

```python
def add_machining_feature_json(self, mf_json):
    for index, mf in enumerate(mf_json):
        cad_operations = mf["CAD Operations"]
        parameters = mf["Dimensions"]
        feature_name = mf["Feature"]
        if feature_name.contains("Parallel Keyway"):
            for cad_operation in cad_operations:
                if cad_operation.startswith("Extrusion"):
                    extrude_index = int(cad_operation[len("Extrusion") :])
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"mf_json"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>